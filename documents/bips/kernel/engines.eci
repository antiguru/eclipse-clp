% BEGIN LICENSE BLOCK
% Version: CMPL 1.1
%
% The contents of this file are subject to the Cisco-style Mozilla Public
% License Version 1.1 (the "License"); you may not use this file except
% in compliance with the License.  You may obtain a copy of the License
% at www.eclipse-clp.org/license.
% 
% Software distributed under the License is distributed on an "AS IS"
% basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See
% the License for the specific language governing rights and limitations
% under the License. 
% 
% The Original Code is  The ECLiPSe Constraint Logic Programming System. 
% The Initial Developer of the Original Code is  Cisco Systems, Inc. 
% Portions created by the Initial Developer are
% Copyright (C) 2006 Cisco Systems, Inc.  All Rights Reserved.
% 
% Contributor(s): 
% 
% END LICENSE BLOCK

:- comment(alias, "Engines and Threads").
:- comment(summary, "Built-ins for controlling independent engines and threads").
:- comment(categories, ["Built-In Predicates"]).



%----------------------------------------------------------------------
% Engines
%----------------------------------------------------------------------
:- comment(desc, html("\
<H3>Engines</H3>
<P>
An 'engine' is an entity with independent control flow and data areas.
This implies:
<UL>
    <LI>backtracking in one engine does not affect another</LI>
    <LI>engines can operate in a concurrent or interleaved fashion</LI>
    <LI>communication between engines is explicit</LI>
    <LI>data transferred between engines is copied, variables cannot
        be shared</LI>
</UL>
</P><P>
On the other hand, engines share or can share the following:
<UL>
    <LI>loaded modules and predicates</LI>
    <LI>non-logical storage such as global variables, records,
      stores, shelves</LI>
    <LI>global settings (set_flag/2,3)</LI>
    <LI>streams</LI>
</UL>
Traditionally, ECLiPSe had only one (implicit) engine per process.
The multi-engine model is a slight generalization of the engine model
in the ECLiPSe foreign language interfaces.
</P><P>
Engines can be created, instructed to execute ECLiPSe code, and
their status and results queried.  The programming paradigm is
that of an engine as a co-routine, which is either running
or stopped.  An engine is set running using a resume-operation,
and will then run until it comes to a stop (which can be for
several reasons, and is encoded in the engine status).
</P><P>
Example:
<PRE>
    ?-  engine_create([], E),
        engine_resume(E, writeln(hello), Status).
    hello

    E = 'HANDLE'(16'84be2000)
    Status = true
    Yes (0.00s cpu)
</PRE>
Here, an engine E is created, and set running (resumed) with a goal
to execute.  When the engine terminates, the engine_resume/3 returns
with a status code.  Since the goal succeeded, the status is 'true'.
</P><P>
A more interesting case is where the engine executes a nondeterministic
goal:
<PRE>
    ?-  engine_create([], E),
        engine_resume(E, (member(X,[one,two]), writeln(X)), S1),
            writeln(first_resume:S1),
        engine_resume(E, fail, S2),
            writeln(second_resume:S2),
        engine_resume(E, fail, S3),
            writeln(third_resume:S3).
    one
    first_resume : true
    two
    second_resume : true
    third_resume : false
</PRE>
On the first resume, the engine executes the goal and succeeds with
the first solution.  At this point, despite returning from the resume,
the engine retains all computation state associated with the success
of the executed goal.  In particular, it can be made to backtrack, and
deliver another solution.  This is done by resuming with a 'fail'. 
This second resume returns again with a status of 'true', indicating
another solution.  The third resume returns 'false', indicating no
further solution.  The engine is now in the same state as just after
creation.
</P>


<H3>Engines and Threads</H3>
<P>
Engines can be created with the 'thread' option, which enables them
to run concurrently with others, in a separate thread.
</P><P>
Example:
<PRE>
    ?-  engine_create([thread], E),
        engine_resume_thread(E, writeln(hello)),
            % possibly do other stuff here
        engine_join(E, block, Status).
    hello

    E = 'HANDLE'(16'84be2000)
    Status = true
    Yes (0.00s cpu)
</PRE>
The only difference from above is that the engine_resume/3 operation
is now split into engine_resume_thread/2 and engine_join/3.
The engine_resume_thread/2 sets the engine running in its own thread,
and returns immediately.  The main program can now do work independently
of the separately running engine.  To re-synchronize, engine_join/3
is called, which, if necessary, will wait for the engine to stop,
and report its status.
</P><P>
The backtracking example above works equally well by replacing the
engine_resume/3 calls with pairs of engine_resume_thread/2 and engine_join/3.
</P><P>



<H3>Engine status</H3>
<P>
An engine can be in one of the following states:
<DL>
    <DT><B>running</B></DT><DD>
       Engine is running and cannot be used, except for
       engine_join/3, engine_status/2 and engine_post_event/2.</DD>

    <DT><B>true</B></DT><DD>
       Engine is stopped after success of its goals.
       Engine is ready to be resumed with new (additional) goals,
       which form a conjunction with the already succeeded goals.</DD>

    <DT><B>false</B></DT><DD>
       Engine is stopped after failure of its goals.
       Engine is ready to be resumed with new goals.
       This is also the initial state of a new engine.</DD>

    <DT><B>exception(Term)</B></DT><DD>
       Engine is stopped after an uncaught throw(Term).
       Engine is ready to be resumed with new goals.</DD>

    <DT><B>yielded(Out)</B></DT><DD>
       Engine is stopped in a yield(Out,In) call.  The term Out is a
       copy of the Out argument of the yield/2 call.
       The engine is ready to be resumed.  When resumed, the yield/2
       call will succeed, with its In argument unified with a copy of
       the resume's Term argument.</DD>

    <DT><B>flushio(Stream)</B></DT><DD>
       Engine is stopped in a flush operation of the queue Stream.
       Data is ready to be read from the Stream, after which the
       engine should be resumed.  After resume, the engine will
       continue after the flush operation.  Any term passed to the
       resume is ignored.</DD>

    <DT><B>waitio(Stream)</B></DT><DD>
       Engine is stopped in a read operation of the empty queue Stream.
       Data is expected to be written to the Stream, after which the
       engine should be resumed.  After resume, the engine will
       continue with its read operation.  Any term passed to the
       resume is ignored.</DD>

    <DT><B>exited(Term)</B></DT><DD>
       Engine has stopped following an exit(Term) or engine_exit(E,Term).
       Term is a copy of the exit argument.
       The engine cannot be resumed.</DD>
</DL>
The status can also be obtained by engine_properties/2.
</P>


<H3>Communication via yield/2</H3>
<P>
The yield/2 built-in is used in combination with resume to synchronize
execution and exchange data between two engines:
<PRE>
    ?-  engine_create([], E),
        engine_resume(E, (yield(hello,In),writeln(received(In))), S1),
        writeln(S1),
        engine_resume(E, dear, S2),
        writeln(S2).
    yielded(hello)
    received(dear)
    true
</PRE>
</P><P>
The next example does the same as findall/3, using an auxiliary engine:
<PRE>
    engine_findall(X, Goal, Xs) :-
        engine_create([], E),
        engine_resume(E, (Goal,yield(X,Cont),Cont), Status),
        (
            fromto(Status,yielded(Sol),Status1,false),
            foreach(Sol,Xs),
            param(E)
        do
            engine_resume(E, fail, Status1)
        ).
</PRE>
</P><P>
The next example adds solutions lazily to a list:
<PRE>
    lazy_findall(X, Goal, Xs) :-
        engine_create([thread], E),
        engine_resume_thread(E, (Goal,yield(X,_),fail)),
        solutions(E, Xs).

    delay solutions(_,Xs) if var(Xs).
    solutions(E, Xs) :-
        engine_join(E, block, Status),
        ( Status = yielded(X) ->
            Xs = [X|Xs1],
            engine_resume_thread(E, fail),
            solutions(E, Xs1)
        ; Status = false ->
            Xs = []
        ;
            throw(unexpected_status(Status))
        ).


    ?- lazy_findall(X, member(X,[a,b,c]), Xs), Xs = [A,B|T].
    Xs = [a, b|T]
    A = a
    B = b
    T = T
    Delayed goals:
            solutions('HANDLE'(16'6670e000), T)
    Yes (0.00s cpu)
</PRE>
</P>


<H3>Communication via queue streams</H3>
<P>
The flushio and waitio functionality refers to queue-streams, which
can be used for communication.  These should be set up as follows:
<PRE>
    open(queue(\"\"), update, Stream, [yield(on)])
</PRE>
This should be done in the main program, and the Stream handle passed
as an argument to the goal during resume.
</P><P>
Example for returning data from an engine via a queue:
<PRE>
    ?-  open(queue(\"\"), update, Q, [yield(on)]),
        engine_create([], E),
        engine_resume(E, (write(Q,hello),flush(Q)), Status),
        ( Status = flushio(Stream) ->
            read(Stream, Result)
        ;
            writeln(unexpected:Status)
        ).

    Q = $&(stream(13))
    E = 'HANDLE'(16'65ee8000)
    Status = flushio(13)
    Result = hello
</PRE>
</P><P>
Example for passing data to engine via a queue:
<PRE>
    ?-  open(queue(\"\"), update, Q, [yield(on)]),
        engine_create([], E),
        engine_resume(E, (read(Q,Term),writeln(received(Term))), Status),
        ( Status = waitio(Stream) ->
            write(Stream, hello),
            engine_resume(E, unused, _)
        ;
            writeln(unexpected:Status)
        ).

    received(hello)

    Q = $&(stream(9))
    E = 'HANDLE'(16'4a59b000)
    Status = waitio(9)
</PRE>
</P>


<H3>Communication via shared data structures</H3>
<P>
Data can be transferred via non-backtrackable storage, i.e. bags,
stores, shelves, or records:
<PRE>
    ?-  bag_create(B),
        engine_create([thread], E),
        engine_resume_thread(E, (between(1,20,1,X),bag_enter(B,X),fail)),
        engine_join(E, block, Status),
        bag_retrieve(B, Xs).

    B = 'BAG'(16'4a5dc1f0)
    E = 'HANDLE'(16'4a59f000)
    Status = false
    Xs = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, ...]
</PRE>
The anonymous (handle-based) versions of these facilities should be used,
as they are more efficient and are disposed of automatically by garbage
collection.
The use of dynamic predicates and assert/retract is not recommended.
</P>


<H3>Synchronisation</H3>
<P>
Operations on non-backtrackable storage objects (bags, shelves, stores)
and streams are atomic for their basic operations.  To make larger
code sections atomic, use with_mutex/2.  As most objects internally
contain a mutex, their handles themselves can be used as the mutex.
In the following example we make sure that a sequence of write operations
cannot be interrupted by another thread writing to the same stream:
<PRE>
    atomic_write_list(Stream, Xs) :-
        with_mutex(Stream, write_list(Stream, Xs)).

    write_list(Stream, Xs) :-
        ( foreach(X,Xs), param(Stream) do writeln(Stream, X) ).
</PRE>
Without with_mutex/2, each writeln/2 would be atomic, but another thread
that has the same stream handle could write to the stream between these
writeln-calls.
</P><P>
Here is an example of how to make a read-modify-write operation on a
store thread-safe:
<PRE>
    add_to_store(Store, Key, Increment) :-
        with_mutex(Store, (
            store_get(Store, Key, OldVal),
            NewVal is OldVal+Increment,
            store_set(Store, Key, OldVal)
        )).
</PRE>
</P>

A couple of common atomic operations have been introduced as new primitives:
<DL>
<DT>shelf_get_and_dec(+Shelf,+Index,-Value)</DT><DD>
    get and post-decrement an integer stored in a shelf slot
</DD>
<DT>shelf_inc_and_get</DT>(+Shelf,+Index,-Value)<DD>
    pre-increment an get an integer stored in a shelf slot
</DD>
<DT>shelf_test_and_set</DT>(+Shelf,+Index,+Old,+New)<DD>
    if the old shelved value is identical to Old, set it to New, else fail
</DD>
</DL>


<H3>Waiting for Conditions</H3>
<P>
The following predicates cause a the calling engine-thread to block
until a particular continuation condition arises:
<DL>
    <DT>sleep(Seconds)</DT><DD>
        puts the thread to sleep for the given time.
    </DD>
    <DT>stream_select(Streams,Timeout,ReadyStreams)</DT><DD>
        puts the thread to sleep until streams are ready for I/O.
    </DD>
    <DT>engine_join(Engine,Timeout,Status)</DT><DD>
        puts the current thread to sleep until Engine stops running.
    </DD>
</DL>
</P>


<H3>Interrupting Running Engines</H3>
<P>
ECLiPSe's event mechanism can be used to interrupt a running engine and to
insert an arbitrary goal into the execution.  This is the same mechanism
used for timer-controlled after-events and for signal-triggered events.
</P><P>
Use engine_post_event/2 to post an event (an atom, or an event created
using event_create/3) to a particular engine:
<PRE>
?- engine_create([thread],E),
   engine_resume_thread(E, (repeat,fail)),   % run forever
   sleep(3),
   engine_post_event(E, abort),
   engine_join(E, block, Status).

E = 'ENGINE'(16'315bd10f)
Status = exception(abort)
Yes (3.00s cpu)
</PRE>
</P>
")).

%------------------------------------------------------------------------

:- comment( engine_create/2, [
    amode:(engine_create(++,-) is det),
    args:[
        "Options":"A list of option terms",
        "Engine":"Output: an engine handle"
    ],
    summary:"Create a new ECLiPSe engine",
    desc:html("<P>\
    An 'engine' is an entity that can execute goals, but has its own
    independent control flow and data areas.  This implies:
<UL>
    <LI>  backtracking in one engine does not affect another
    <LI>  engines can operate in a concurrent or interleaved fashion
    <LI>  communication between engines is explicit
    <LI>  data transferred between engines is copied, variables cannot be shared
</UL>
    On the other hand, engines share (or can share) the following:
<UL>
    <LI>  loaded modules and predicates
    <LI>  non-logical storage such as global variables, records, stores, shelves
    <LI>  global settings (set_flag/2,3)
    <LI>  streams
</UL>
    Engines can be created, instructed to execute ECLiPSe code, and
    their status and results queried.  The programming paradigm is
    that of an engine as a co-routine, which is either running
    or stopped.  An engine is set running using a resume-operation,
    and will then run until it comes to a stop (which can be for
    several reasons, encoded in the engine status).
</P><P>
    ECLiPSe initially starts up with a single (implicitly created) engine,
    which executes all code.  This predicate creates additional engines.
</P><P>
    The following Options are recognized:
<DL>
    <DT><B>thread</B> or <B>thread(Bool)</B></DT><DD>
        If true, the engine is associated with its own thread and can
        run concurrently with other engines.  If false, the engine is
        passive and can only run interleaved with a parent's engine's
        execution (as a co-routine).  Default is false.
        </DD>
    <DT><B>detached</B> or <B>detached(Bool)</B></DT><DD>
        Destroy engine as soon as it finishes running, instead of waiting
        for engine_join/3.  Default is false.  This option is mostly for
        compatibility, as ECLiPSe will automatically destroy unreferenced
        engines on failure and garbage collection.
        </DD>
    <DT><B>global(KiBytes)</B></DT><DD>
        size limit of the engine's global/trail stack in KiB.
        Corresponds to ECLiPSe's -g command line option. 
        Defaults to the parent's engine's value (max_global_trail).
        </DD>
    <DT><B>local(KiBytes)</B></DT><DD>
        size limit of the engine's local/control stack in KiB.
        Corresponds to ECLiPSe's -l command line option. 
        Defaults to the parent's engine's value (max_local_control).
        </DD>
    <DT><B>verbose</DT></B><DD>
        Print messages on log_output when engine is created, shared
        or deallocated.
        </DD>
</DL>
</P><P>
    A newly created engine has status 'false', and is ready to be
    resumed and execute goals.  An engine lives as long as its handle
    is accessible, or as long as it is running, whichever is longer. 
    It is normally not necessary to destroy engines explicitly.
</P><P>
    An engine inherits its parent engine's pseudo-random generator state.
</P>"),
    exceptions:[
        4 : "Options is not fully instantiated.",
        5 : "Options is not a list of atoms or compound terms.",
        5 : "An option contains an unexpected type.",
        6 : "An option is not recognized."
    ],
    eg:"
    ?- engine_create([], E).
    E = 'HANDLE'(16'17610000)
    Yes (0.00s cpu)

    ?- engine_create([thread], E).
    E = 'HANDLE'(16'17610000)
    Yes (0.00s cpu)

    ?- engine_create([local(1000),global(10000)], E).
    E = 'HANDLE'(16'17610000)
    Yes (0.00s cpu)
",
    see_also:[engine_properties/2, engine_resume/3,engine_resume_thread/2,
                engine_join/3,engine_status/2]]).


:- comment( engine_resume/3, [
    amode:(engine_resume(+,?,-) is det),
    args:["Engine":"An engine handle",
        "Term":"A term passed to the engine",
        "Status":"Status term returned from the engine"
    ],
    summary:"Resume execution of an engine",
    desc:html("<P>\
    Resume execution of the given engine, and return with a status
    code once execution has stopped.  The computation is performed
    by the same thread that is calling engine_resume/3.
</P><P>
    This predicate can be used with any engine, independent of whether
    the engine was created with or without the 'thread' option.
</P><P>
    For details about the returned Status, see engine_status/2.  All
    status codes except 'running' are possible.
</P><P>
    Term is an arbitrary term, a copy of which is is passed to the
    resumed engine.  The way the resumed engine interprets Term
    depends on its status at resumption time:
<DL>
    <DT><B>false</B> and <B>exception(_)</B></DT><DD>
        Term is interpreted as a goal, and called.  This is the case
        for a newly created engine.
    <DT><B>true</B></DT><DD>
        Term is also interpreted as a goal and called, but it forms a
        conjunction with the previously succeeded goals (i.e. if it fails,
        it backtracks into the goal given in the previous resume).
    <DT><B>yielded(_)</B></DT><DD>
        Term is unified with the second argument of the yield/2 call
        in which the engine was stopped.
    <DT><B>flushio(_)</B> and <B>waitio(_)</B></DT><DD>
        Term is ignored.
    <DT><B>exited(_)</B></DT><DD>
        Engine cannot be resumed (error).
</DL>
    In the cases where Term is executed as a goal, note that the engine
    works on a copy of Term, therefore any variable bindings performed
    by the engine will not be visible to the caller of engine_resume/3.
    Any results must be returned explicitly, either via yield/2, via
    stream communication, or via nonlogical storage.
</P>"),
    exceptions:[
        4 : "Engine is not instantiated",
        5 : "Engine is not an engine handle",
        180 : "Engine is busy (running)"],
        182 : "Engine dead/exited"],
    eg:"
    ?- engine_create([], E), engine_resume(E, writeln(hello), S).
    hello
    E = 'HANDLE'(16'17610000)
    S = true
    Yes (0.00s cpu)

    ?- engine_create([thread], E), engine_resume(E, writeln(hello), S).
    hello
    E = 'HANDLE'(16'17610000)
    S = true
    Yes (0.00s cpu)

    ?- engine_create([], E), engine_resume(E, 3=4, S).
    E = 'HANDLE'(16'17610000)
    S = false
    Yes (0.00s cpu)

    ?- engine_create([], E), engine_resume(E, throw(ball), S).
    E = 'HANDLE'(16'16e06000)
    S = exception(ball)
    Yes (0.00s cpu)

    ?- engine_create([], E), engine_resume(E, throw(ball), S).
    E = 'HANDLE'(16'16e06000)
    S = exception(ball)
    Yes (0.00s cpu)

    ?- engine_create([], E),
       engine_resume(E, (member(X,[a,b]),writeln(X)), S1),
       writeln(first_resume->S1),
       engine_resume(E, fail, S2),
       writeln(second_resume->S2),
       engine_resume(E, fail, S3),
       writeln(third_resume->S3).
    a
    first_resume -> true
    b
    second_resume -> true
    third_resume -> false

",
    see_also:[engine_create/2,engine_resume_thread/2,engine_status/2]]).


:- comment( engine_resume_thread/2, [
    amode:(engine_resume_thread(+,?) is det),
    args:["Engine":"An engine handle",
        "Term":"A term passed to the engine"
    ],
    summary:"Asynchronously resume execution of an engine",
    desc:html("<P>\
    Resume execution of the given engine in a separate thread.
    The predicate returns immediately, while the resumed engine
    enters the 'running' state.  To wait for the engine to stop,
    and to retrieve its status, use engine_join/3.
</P><P>
    This predicate can only be used with an engine that was created
    with the 'thread' option.
</P><P>
    Term is an arbitrary term, a copy of which is is passed to the
    resumed engine.  The way the resumed engine interprets Term
    depends on the status it was in:
<DL>
    <DT><B>false</B> and <B>exception(_)</B></DT><DD>
        Term is interpreted as a goal, and called.  This is the case
        for a newly created engine.
    <DT><B>true</B></DT><DD>
        Term is also interpreted as a goal and called, but it forms a
        conjunction with the previously succeeded goals (i.e. if it fails,
        it backtracks into the goal given in the previous resume).
    <DT><B>yielded(_)</B></DT><DD>
        Term is unified with the second argument of the yield/2 call
        in which the engine was stopped.
    <DT><B>flushio(_)</B> and <B>waitio(_)</B></DT><DD>
        Term is ignored.
    <DT><B>running(_)</B>, <B>destroyed</B> and <B>exited</B></DT><DD>
        Engine cannot be resumed (error).
</DL>
    In the cases where Term is executed as a goal, note that the engine
    works on a copy of Term, therefore any variable bindings performed by
    the engine will not be visible to the caller of engine_resume_thread/2.
    Any results must be returned explicitly, either via yield/2, via
    stream communication, or via nonlogical storage.
</P>"),
    exceptions:[
        4 : "Engine is not instantiated",
        5 : "Engine is not an engine handle",
        180 : "Engine is busy (running)",
        181 : "Engine is not an asynchronous engine"],
    eg:"
    ?- engine_create([thread], E),
       engine_resume_thread(E, writeln(hello)),
       engine_join(E, block Status).
    hello
    E = 'HANDLE'(16'17610000)
    Status = true
    Yes (0.00s cpu)

    ?- engine_create([thread], E),
       engine_resume_thread(E, (writeln(hello),sleep(1),writeln(done))),
       engine_status(E, Status1),
       writeln(Status1),
       engine_join(E, block Status2).
    running
    hello
    done
    E = 'HANDLE'(16'17610000)
    Status1 = running
    Status2 = true
    Yes (0.00s cpu)
",
    see_also:[engine_create/2,engine_resume/3,engine_status/2]]).


:- comment( engine_self/1, [
    amode:(engine_self(-) is det),
    args:["Engine":"Output: engine handle"],
    summary:"Get a handle of the engine executing the call",
    desc:html("<P>\
    Gets a handle of the engine executing the call.  This handle can
    be used like the handles returned from engine_create/2, i.e. all
    operations that are defined for engine handles.  Note that holding a
    reference to an engine can prevent it from being garbage collected.
    </P>"),
    eg:"
    ?- engine_self(E), engine_status(E,S).
    E = 'ENGINE'(16'00000555)
    S = running
    Yes (0.00s cpu)
",
    see_also:[engine_create/2,engine_resume/3,engine_status/2]]).


:- comment( engine_status/2, [
    amode:(engine_status(+,-) is det),
    args:["Engine":"An engine handle",
        "Status":"Output: engine status term"
    ],
    summary:"Obtain the status of an engine",
    desc:html("<P>\
    Obtains the status of an engine without waiting, and unifies
    it with Status.  The engine may be running or stopped
    (to wait for the engine to stop, use engine_join/3).
</P><P>
    The different status codes and their descriptors are:
<DL>
    <DT><B>running</B></DT><DD>
       Engine is still running and cannot be used, except for
       engine_join/3 and engine_status/2.  Note that this status
       is unreliable, because an asynchronous engine can stop
       running any time.</DD>

    <DT><B>true</B></DT><DD>
       Engine is stopped after success of its goals.
       Engine is ready to be resumed with new (additional) goals,
       which form a conjunction with the already succeeded goals.</DD>

    <DT><B>false</B></DT><DD>
       Engine is stopped after failure of its goals.
       Engine is ready to be resumed with new goals.
       This is also the initial state of a new engine.</DD>

    <DT><B>exception(Term)</B></DT><DD>
       Engine is stopped after an uncaught throw(Term).
       Engine is ready to be resumed with new goals.</DD>

    <DT><B>yielded(Out)</B></DT><DD>
       Engine is stopped in a yield(Out,In) call.  The term Out is a
       copy of the Out argument of the yield/2 call.
       The engine is ready to be resumed.  When resumed, the yield/2
       call will succeed with its In argument unified with a copy of
       the resume's Term argument.</DD>

    <DT><B>flushio(Stream)</B></DT><DD>
       Engine is stopped in a flush operation of the queue Stream.
       Data is ready to be read from the Stream, after which the
       engine should be resumed.  After resume, the engine will
       continue after the flush operation.  Any term passed to the
       resume is ignored.</DD>

    <DT><B>waitio(Stream)</B></DT><DD>
       Engine is stopped in a read operation of the empty queue Stream.
       Data is expected to be written to the Stream, after which the
       engine should be resumed.  After resume, the engine will
       continue with its read operation.  Any term passed to the
       resume is ignored.</DD>

    <DT><B>exited(Term)</B></DT><DD>
       Engine has stopped following an exit(Term) or engine_exit(E,Term).
       Term is a copy of the exit argument.
       The engine cannot be resumed.</DD>

    <DT><B>destroyed</B></DT><DD>
       Engine has been destroyed and can no longer be used.</DD>
</DL>
    A non-running engine will retain its status until it is resumed again.
</P>"),
    exceptions:[
        4 : "Engine is not instantiated",
        5 : "Engine is not an engine handle"],
    eg:"
    ?- engine_create([], E), engine_status(E, Status).
    E = 'HANDLE'(16'17610000)
    Status = false
    Yes (0.00s cpu)

    ?- engine_create([], E),
       engine_resume(E, writeln(hello), Status1),
       engine_status(E, Status2).
    hello
    E = 'HANDLE'(16'17610000)
    Status1 = true
    Status2 = true
    Yes (0.00s cpu)

    ?- engine_create([], E),
       engine_resume(E, yield(hello,_), Status1),
       engine_status(E, Status2).
    E = 'ENGINE'(16'6bbe06c0)
    Status1 = yielded(hello)
    Status2 = yielded(hello)
    Yes (0.00s cpu)

    ?- engine_create([], E),
       ( engine_resume(E, throw(foo(bar)), true)
       ; engine_status(E, Status)
       ).
    E = 'ENGINE'(16'6bbe06c0)
    Status = exception(foo(bar))
    Yes (0.00s cpu)

    ?- engine_create([thread], E),
       engine_resume_thread(E, (writeln(hello),sleep(1),writeln(done))),
       engine_status(E, Status1),
       writeln(Status1),
       engine_join(E, block, Status2).
    running
    hello
    done
    
    Status1 = running
    Status2 = true
    Yes (0.00s cpu)
",
    see_also:[engine_create/2,engine_resume/3,engine_join/3,
        engine_properties/2]]).


/*
:- comment( engine_join/2, [
    amode:(engine_join(+,-) is det),
    args:["Engine":"An engine handle",
        "Status":"Output: engine status term"
    ],
    summary:"Wait for an engine to stop running, and return its status",
    desc:html("<P>\
    Waits for an (asynchronously resumed) engine to stop executing, then
    returns its status.  The status descriptors are the same as in
    engine_status/2, except that 'running' never occurs.
</P><P>
    It is an error if the engine was not asynchronously resumed (i.e. it
    is stopped or running synchronously), if another thread has called
    engine_join and is already waiting for the engine, or if an engine
    is trying to join itself.
</P><P>
    This predicate is defined as
<PRE>
    engine_join(Engine, Status) :-
        engine_join(Engine, block, Status).
</PRE>
</P>"),
    exceptions:[
        4 : "Engine is not instantiated",
        5 : "Engine is not an engine handle",
        180 : "Another engine_join is already waiting for the engine",
        180 : "Engine is the same as the engine executing the call",
        181 : "Engine is not an asynchronous engine"],
    eg:"
    ?- engine_create([thread], E),
       engine_resume_thread(E, writeln(hello)),
       engine_join(E, Status).
    hello
    E = 'HANDLE'(16'17610000)
    Status = true
    Yes (0.00s cpu)

    ?- engine_create([thread], E),
       engine_resume_thread(E, 1=2),
       engine_join(E, Status).
    E = 'HANDLE'(16'17610000)
    Status = false
    Yes (0.00s cpu)

    ?- engine_create([thread], E),
       engine_resume_thread(E, yield(hello,_)),
       engine_status(E, Status1),
       engine_resume_thread(E, true),
       engine_join(E, Status2).
    E = 'HANDLE'(16'17610000)
    Status1 = yielded(hello)
    Status2 = true
    Yes (0.00s cpu)
",
    see_also:[engine_create/2,engine_join/3,engine_resume_thread/2,engine_status/2]]).
*/

:- comment( engine_join/3, [
    amode:(engine_join(+,+,-) is semidet),
    args:["Engine":"An engine handle",
        "Timeout":"Timeout in seconds (integer or float)",
        "Status":"Output: engine status term"
    ],
    summary:"Wait for an engine to stop running, and return its status",
    desc:html("<P>\
    Waits for an (asynchronously resumed) engine to stop executing, then
    returns its status.  The status descriptors are the same as in
    engine_status/2, except that 'running' never occurs.  If the engine
    does not stop within Timeout seconds, the predicate fails.
    If the engine is already stopped at the time of the join, it succeeds
    immediately.
</P><P>
    It is an error if the engine is running, but was not asynchronously
    resumed (e.g. it was resumed using engine_resume/3 by another thread).
    Moreover, an engine cannot join itself.
</P><P>
    If multiple joins are waiting for the same engine, they will all
    succeed when the engine stops.
</P><P>
    If Timeout is the atom 'block', no timeout is used, the operation
    can block indefinitely, and never fails.
</P>"),
    fail_if:"Fails if timeout occurs before engine stops",
    exceptions:[
        4 : "Engine or Timeout is not instantiated",
        5 : "Engine is not an engine handle",
        5 : "Timeout is neither integer, float, nor the atom 'block'",
        6 : "Timeout is a negative number",
        180 : "Engine running, but cannot be joined",
        181 : "Engine is not an asynchronous engine"],
    eg:"
    ?- engine_create([thread], E),
       engine_resume_thread(E, (repeat,fail)),
       ( engine_join(E, 5, S) -> writeln(status=S) ; writeln(timeout) ).
   timeout

   E = 'ENGINE'(16'6c98d3f2)
   S = S
   Yes (5.00s cpu)
",
    see_also:[engine_create/2,engine_resume_thread/2,engine_status/2]]).


:- comment( engine_post_event/2, [
    amode:(engine_post_event(+,+) is det),
    args:["Engine":"An engine handle",
          "Event" :"Atom or event handle"
    ],
    summary:"Post an event to an engine",
    desc:html("<P>\
    Posts an event to the specified engine.  The receiving engine can be
    in any state.  If the receiving engine is running, the event will be
    handled at the next synchronous point in execution, usually the next
    predicate call.  If the receiving engine is stopped, the event will
    be handled immediately after it is resumed.
</P><P>
    The event handler should either succeed or throw an exception (throw/1).
    It makes little sense for the handler to fail, because it is inserted
    in an unknown position during execution and the scope of the failure is
    not known.  The considerations are similar to those for after-events.
</P><P>
    The most likely use for this mechanism is to abort an asynchronously
    running engine.  But one could also cause the engine to initiate an
    exchange of information (via yield/2, streams or shared storage objects).
</P><P>
    Note that the event/1 built-in could be defined as
<PRE>
    event(Event) :-
        engine_self(Engine),
        engine_post_event(Engine, Event).
</PRE>
</P>
    "),
    eg:"
    ?- engine_create([thread],E),
       engine_resume_thread(E, (repeat,fail)),   % run forever
       sleep(3),
       engine_post_event(E, abort),
       engine_join(E, block, Status).

    E = 'ENGINE'(16'315bd10f)
    Status = exception(abort)
    Yes (3.00s cpu)
",
    see_also:[event/1,event_after/2,event_create/3,engine_create/2,engine_resume_thread/2,engine_join/3]]).


:- comment( engine_properties/2, [
    amode:(engine_properties(+,-) is det),
    args:["Engine":"An engine handle",
          "Properties" :"Output: a list of terms"
    ],
    summary:"Obtain a list of the engine's properties",
    desc:html("<P>\
    Obtains a list of the properties and status of the given engine.
    The list contains the engine options described in engine_create/2,
    plus the terms
<DL>
    <DT><B>status(Status)</B></DT><DD>
        where Status is the same value returned by engine_status/2
        (true, false, exception(E), yielded(Val), ...)
    <DD>
    <DT><B>references(Count)</B></DT><DD>
        where Count is the number of entities holding a reference to
        the engine.  The engine will be garbage collected once this
        count reaches zero.
    <DD>
</DL>
</P>
    "),
    eg:"
    ?- engine_create([],E), engine_properties(E,Ps).
    E = 'ENGINE'(16'3157da58)
    Ps = [status(false), references(1), thread(false),
            detached(false), local 131072, global 524288]
    Yes (0.00s cpu)
",
    see_also:[engine_create/2,engine_self/1]]).


:- comment( yield / 2, [
    summary:"Yield control to the caller of the running ECLiPSe engine, and wait for resume.",
    amode:(yield(+, -) is det),
    args:["ToParent" : "A term.",
        "FromParent" : "A variable to be unified with term from parent."],
    desc:html("<P>
   All ECLiPSe programs are executed by an ECLiPSe engine.  This engine can
   be embedded in a host program, which is either in a different language
   (C/C++, Tcl, Java), or is itself an ECLiPSe program.  In either case,
   the interaction between the ECLiPSe engine and the parent execution
   follows a resume-yield model of control flow: the parent execution
   transfers control to the engine via a 'resume' operation, and the engine
   returns control to the parent via a 'yield' operation.  Sometimes, the
   yield operation is implicit (such as when the engine execution succeeds,
   fails or aborts), but it can also be performed explicitly with the
   yield/2 predicate.
</P><P>
   An ECLiPSe engine that executes this predicate yields control to the
   parent program (which previously resumed this engine) and then waits
   until it is resumed again by the parent program.
</P><P>
   Data can be passed both ways: the ToParent argument is passed from
   the engine to the parent on yielding, the FromParent argument receives
   a term from the parent on resumption.
</P>

<H3>Use with engine_resume/3</H3>
<P>
   When the parent is an ECLiPSe program, engine_resume/3 handles the
   parent side of the interaction:  In response to a yield/2, it succeeds
   with a status of yielded(ToParent).  When the parent calls engine_resume/3
   again, its second argument is passed to the resumed engine and is unified
   with FromParent when the waiting yield/2 succeeds.
</P>

<H3>Use in a Host Language Embedding</H3>
<P>
   When ECLiPSe is used as an embedded component within an application
   written in C/C++, the ECLiPSe execution is conceptually a thread.
   On the C/C++ side, the ec_resume()/EC_resume() functions pass
   control to the ECLiPSe thread, while on the ECLiPSe side, the
   yield/2 predicate is used to pass control back.
   Data can be passed both ways: the ToParent argument of yield/2 is passed
   to C/C++ via the second argument of ec_resume()/EC_resume() when it
   returns. Similarly a ec_resume()/EC_resume() first argument is
   passed to ECLiPSe as the FromParent argument of yield/2.
</P><P>
   Note that, by default, ECLiPSe is set up as a server which calls
   posted goals after resume. This is such a general mechanism that it
   is often not necessary to explicitly use yield/2.
<P>
"),
    eg:"
% Communication between engines

    ?- engine_create([], E),
       engine_resume(E, (yield(to_parent,From),writeln(received(From))), S1),
       engine_resume(E, from_parent, S2).

    received(from_parent)

    E = 'HANDLE'(16'16e06000)
    S1 = yielded(to_parent)
    S2 = true
    Yes (0.00s cpu)


% Embedding situation: ECLiPSe server code

    start_server :-
        eclipse_server(dummy).

    eclipse_server(PrevResult) :-
        yield(PrevResult, Request),
        process_request(Request, NewResult),
        eclipse_server(NewResult).


    // C++ client code
    ec_init();
    post_goal(\"start_server\");
    if (EC_resume() == EC_yield)
    {
        for(;;)
        {
            // create a request
            ...
            if (EC_resume(request, result) != EC_yield);
                break;
            ...
            // use the result
        }
    }
",
    see_also:[engine_resume/3, engine_status/2]]).


/*
:- comment(mutex_create / 2, [
    summary:"Create a mutual exclusion object",
    amode:(mutex_create(-,++) is det),
    args:[
        "Mutex" : "Output: a mutex handle",
        "Options":"A list of option terms"],
    desc:html("<P>
   Creates a 'mutex' object that can be used in with_mutex/2 to implement
   mutual exclusion between concurrent threads or parallel workers.
</P><P>
   Note that the creation of an explicit mutex object is often not
   necessary, because many other object handles (streams, bags, stores,
   shelves), have a built-in mutex and can be used instead.
</P><P>
   Options supported:
<DL>
    <DT>currently none</DT><DD></DD>
</DL>
</P>
    "),
    eg:"
    ?- mutex_create(M, []).
    ",
    exceptions:[
        4 : "Options is not fully instantiated.",
        5 : "Options is not a list of atoms or compound terms.",
        5 : "An option contains an unexpected type.",
        6 : "An option is not recognized."],
    see_also:[with_mutex/2]]).
*/

:- comment(with_mutex / 2, [
    summary:"Equivalent to once(Goal) but with mutual exclusion",
    amode:(with_mutex(++,+) is semidet),
    args:[
        "Mutex" : "Handle",
        "Goal" : "Callable term"],
    desc:html("<P>
   This built-in can be used in multithreaded or parallel programs to
   implement mutual exclusion between concurrently running engines.
   Goals that are protected via with_mutex/2 on the same Mutex object
   can only be executed by one engine at a time.
</P><P>
   Note that in a side effect free program there is no need ever to worry
   about mutual exclusion.  Also, individual calls to built-ins performing
   side-effects (stream I/O operations, operations on nonlogical storage, etc)
   do not need extra protection, because they internally lock the object
   they operate on.  The purpose of with_mutex/2 is therefore to make a
   sequence of multiple side-effects atomic, when this is necessary to
   maintain consistency of shared data structures.
</P><P>
   The following object handles can be used as Mutex:
<DL>
    <DT>stream</DT><DD>
        If necessary, obtain a stream handle using get_stream/2.
    </DD>
    <DT>shelf</DT><DD>
        Only anonymous (handle-based) shelves.
    </DD>
    <DT>store</DT><DD>
        Only anonymous (handle-based) stores.
    </DD>
    <DT>bag</DT><DD>
        Bag handle.
    </DD>
    <DT>engine</DT><DD>
        Useful if multiple asynchronous engines want to resume
	a synchronous engine using engine_resume/3.
    </DD>
</DL>
</P><P>
   Mutexes are recursive, nested calls to with_mutex/2 within a thread
   are allowed.
<P>
"),
    fail_if:"Fails if Goal fails",
    exceptions:[
        4 : "Goal is not instantiated.",
        5 : "Goal is not an atom or a compound term.",
        5 : "Mutex is not an object handle.",
        141: "Mutex refers to an object that does not support this operation"
        ],
    eg:"

    % make sure a list is printed in one chunk
    % use the stream's own mutex for exclusion
    atomic_write_list(Stream, List) :-
        with_mutex(Stream, write_list(Stream, List)).

    write_list(Stream, []) :- nl(Stream).
    write_list(Stream, [X|Xs]) :- writeln(Stream, X), write_list(Stream, Xs).



",
        see_also:[(once) / 1]]).

