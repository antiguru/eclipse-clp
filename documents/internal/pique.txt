# BEGIN LICENSE BLOCK
# Version: CMPL 1.1
#
# The contents of this file are subject to the Cisco-style Mozilla Public
# License Version 1.1 (the "License"); you may not use this file except
# in compliance with the License.  You may obtain a copy of the License
# at www.eclipse-clp.org/license.
# 
# Software distributed under the License is distributed on an "AS IS"
# basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See
# the License for the specific language governing rights and limitations
# under the License. 
# 
# The Original Code is  The ECLiPSe Constraint Logic Programming System. 
# The Initial Developer of the Original Code is  Cisco Systems, Inc. 
# Portions created by the Initial Developer are
# Copyright (C) 2006 Cisco Systems, Inc.  All Rights Reserved.
# 
# Contributor(s): 
# 
# END LICENSE BLOCK

From - Fri Sep 24 12:23:57 1999
Return-Path: <micha@scorpio>
Received: from lyra.ecrc.de by scorpio.ecrc.de (4.1/SMI-3.2)
	id AA01379; Mon, 7 Mar 94 11:22:03 +0100
Date: Mon, 7 Mar 94 11:22:03 +0100
From: Micha Meier <micha@scorpio>
Message-Id: <9403071022.AA01379@scorpio.ecrc.de>
To: joachim
Subject: compilation prolog vers C
Content-Length: 12760
X-Lines: 434
Status: RO


----- Begin Included Message -----

>From jfp@gia.univ-mrs.fr Sun Mar  6 20:16:53 1994
Date: Sun, 6 Mar 94 20:17:59 +0100
From: jfp@gia.univ-mrs.fr (Jean Francois Pique)
To: Micha.Meier@ecrc.de
Subject: compilation prolog vers C

Hello,

I have not yet published a paper on this topic, the idea has been described in
Esprit project 5246 April 992 Report on Working Package 1. Unfortunately  I 
am afraid it has the state 'Confidential', so it is not a good reference. 
Therefore,  I send you a copy of a draft memo on this subject. It is 
clearly very far from
something that can be published, but you will find there all the information 
that you need.
--------------------------------
COMPILATION DE PROGRAMMES PROLOG VERS DU LANGAGE C
Draft memo

Jean Francois PIQUE
Groupe Intelligence Artificielle
Faculte des Sciences - case 901
163 Avenue de Luminy
13288 Marseille CEDEX 9

Email: jfp@gia.univ-mrs.fr



1	Introduction


2 Panorama des differentes methodes de compilation vers C

- Le programme Prolog dans une seule fonction C, branchement par switch
  (PTC Prolog de Paralogic).
-   ""   avec branchement par goto indirect (gcc).
- Methode par exemplarisation des queues de clause (Mali, C-Log IBM).
- Par representation fonctionnelle (AKCL).
....
- Ma methode.

3	Idees de base proposees pour la structure du code genere

LUunite de regroupement de code WIC (Wam Inline Code) est le litteral de la regle: 
chaque litteral est represente par une fonction C (de meme que dans la Wam, le litteral
de tete et le premier litteral de queue sont consideres comme un seul litteral).
On distingue trois types de fonctions:

-	Fonctions representant un litteral de tete et contenant des
instructions dUunification.

-	Fonctions representant un litteral de queue et contenant le code pour
la construction dUargument et lUappel de procedure Prolog (ou paquet).

-	Fonctions representant lUentree dUun paquet et realisant
lUindexation, les points de choix et lUappel des fonctions litteraux de tete.

Chaque fonction renvoie lUadresse de la fonction (litteral) suivante, le
controle se faisant uniquement par lUenchainement des appels de fonction,
sans utilisation particuliere de la pile C (il nUy a pas notamment dUappels
recursifs a ce niveau). 
Cette methode a un overhead tres faible car:

 -- L'appel de fonctions feuilles sans arguments est tres peu couteux.
 -- Le retour d'une valeur atomique de fonction est fait dans un registre hote
    pour toutes les implantations.
 -- La granularite des appels est assez grosse (plusieurs instructions Wam) pour
    que le cot d'appel de fonction soit negligeable par rapport au reste, et
    suffisamment faible pour que la taille des fonctions permettent d'utiliser
    les options d'optimisation maximale avec un temps raisonnable de compilation.
 -- De nombreuses optimisations sont possibles dans le cas frequent des clauses
    binaires.

Pour simplifier lUecriture de lUindexation et des
fonctions associees au paquet, les alternatives sont reperees dans les points
de choix par le nom de la procedure et un numero dUetiquette: une etiquette
est associee a chaque alternative, et la creation des points de choix est
regroupee dans une seule fonction (ceci facilite egalement les
optimisations).

Les instructions WIC sont representees par des macros: une fonction representant un
litteral est donc composee dUune suite dUappels de macros WIC.

Exemple de code genere pour un programme Prolog:

a(0).                           % R1
a(1) :- b(0), c(1), c(2).       % R2

b(0).                           % R3

c(X) :- write(X).               % R4

?- a.

Afin de distinguer les litteraux de meme nom, ils sont reperes par le numero
de regle et le numero du litteral dans la regle:

On rappelle que dans la WAM l'instruction SWITCH_ON_TERM realise la
dereference du premier argument. Afin de mieux optimiser le code produit
la dereference n'est pas inclue dans les instructions d'unification
telles que GET_INTEGER [Van Roy].

listing x:
-----------------------------
typedef void *PROCPTR;
typedef PROCPTR (*ADRFUNC)();


#define CALL(p,cont)      { cp = cont; return p; }
#define EXECUTE(p)        return p;
#define PROCEED           return cp;

#define PUT_INTEGER(n,x)  x = INTEGER(n);
#define PUSH_INTEGER(n)   *S++ = INTEGER(n);
#define GET_INTEGER(n,x)  {if (VAR(x))  {TRAIL(x); *x = INTEGER(n);} \
			   else if (x!=INTEGER(n))  return fail;}
...

ADRFUNC cp;
PROCPTR fail();

goal_thread(ADRFUNC goal)
{
  for (;;)
    goal = (*goal)();
}
--------------------------------

listing y:
-------------------------------
/* --- Compiled Prolog Program --- */
PROCPTR a_1(),		R1_a_1(), a_1_choice2(),	R2_a_1(), R2goal2_c_1(), R2goal3_c_1();
PROCPTR b_1();
PROCPTR c_1();

/* procedure a/1 indexing and choicepoint */
PROCPTR a_1()
{
  SWITCH_ON_TERM( TRY_ME_ELSE( a_1_choice2 )			                   /* var */
                  EXECUTE( R1_a_1 ) 
		              , if      ( A1 == INTEGER(0) )	EXECUTE( R1_a_1 )  /* cst */
		                else if ( A1 == INTEGER(1) )	EXECUTE( R2_a_1 )
		                else				EXECUTE( fail )
		              , EXECUTE( fail )				                             /* list */
		              , EXECUTE( fail )				                             /* struct */
		              )
}

PROCPTR a_1_choice2()
{
  TRUST_ME
  EXECUTE( R2_a_1 )
}

				/* a(0). */
PROCPTR R1_a_1()
{
  GET_INTEGER( 0, A1 )
  PROCEED
}
				/* a(1) :- b(0), c(1), c(2). */
PROCPTR R2_a_1()
{
  GET_INTEGER( 1, A1 )
  ALLOCATE( 0 )
  PUT_INTEGER( 0, A1 )
  CALL( b_1, R2goal2_c_1 )
}

PROCPTR R2goal2_c_1()
{
  PUT_INTEGER( 1, A1 )
  CALL( c_1, R2goal3_c_1 )
}

PROCPTR R2goal3_c_1()
{
  PUT_INTEGER( 2, A1 )
  DEALLOCATE
  EXECUTE( c_1 )
}

				/* b(0). */
PROCPTR b_1()
{
  DEREF( A1 )
  GET_INTEGER( 0, A1 )
  PROCEED
}

				/* c(X) :- write(X). */
PROCPTR c_1()
{
  EXECUTE( write_1 )
}

				/* query */
main()
{
  init_state();
  goal_thread( a_1 );
}
----------------------------------------
---------NOTE:
Quand une des regles est un fait, on peut expanser son code dans les 
fonctions d'index:

f(0).		% R1
f(1).		% R2

PROCPTR f_1()
{
  SWITCH_ON_CST( goto choice1;				         /* var */ 
		             , if ( A1 == INTEGER(0) )		 /* cst,list,struct */
			                 PROCEED
		               else if ( A1 == INTEGER(1) )
			                 PROCEED
		               else
			                 EXECUTE( fail )
		             )
  choice1:
    TRY_ME_ELSE( f_1_choice2 )
    GET_INTEGER( 0, A1 )
    PROCEED
}

PROCPTR f_1_choice2()
{
  TRUST_ME
  GET_INTEGER( 1, A1 )
  PROCEED
}

---------- Optimisations
La localisation de l'ensemble des instructions d'unification dans une seule
fonction C permet plusieurs optimisations faciles a realiser et dont le
benefice est important (les % representent la variation du nombre
d'inferences par seconde sur le bench-mark naive reverse):

- Regroupement des flots read et write des suites d'instruction 'unify' (+45%).

- Declaration locale en mode 'register' du registre S de la WAM (+58% lorsque
  combinee avec la precedente).

- Declaration locale de quelques registres temporaires.

- Optimisation des procedures ayant une clause binaire tail-recursive 
(ou assimilable, cad lorsque les premiers litteraux de la queue sont
des built-in deterministes) en faisant du "last call indexing".

Les clauses binaires sont tres frequentes dans les programmes Prolog 
et meritent donc qu'on s'y attarde. 
Un exemple typique est celui de 'naive reverse' ou
99% du temps est passe dans la seconde clause de append.
A elle seule l'optimisation decrite ci-dessous ne represente que +11%
pour ces programmes, mais combinee aux optimisations decrites ci-dessus,
on observe une amelioration de +90% (quasi doublement de la
vitesse d'execution).

Dans la WAM, la recursion de 'append' est transformee en une simple boucle 
grace a l'indexation sur le premier argument et l'optimisation de l'appel
terminal. Ce ne sera pas une boucle C dans notre premier schema car 
l'indexation est faite
dans une fonction separee: a chaque recursion on aura donc passage du 
controle entre la fonction d'indexation et la fonction contenant la regle
binaire recursive. 
Il est cependant possible de construire une boucle C
moyennant une transformation que nous decrirons
sur l'exemple simplifie suivant:

zerolist( [] ).					                         % R1
zerolist( [0|L] ) :- zerolist( L ).		        % R2

Le code produit par la methode que nous avons decrite est donnee listing 1.
On remarquera que le code a ete genere avec la premiere optimisation
(depliage de mode). Le second argument de la macro-instruction GET_LIST
represente l'instruction C a executer lorsque le premier argument n'est pas
une variable. 

listing 1:

PROCPTR zerolist_1()
{
  SWITCH_ON_TERM( TRY_ME_ELSE( zerolist_1_choice2 )	       /* var */
		                EXECUTE( R1_zerolist_1 ) 
		              , EXECUTE( R1_zerolist_1 )		               /* cst */
		              , EXECUTE( R2_zerolist_1 )		               /* list pair */
		              , EXECUTE( fail )			                       /* struct */
		              )
}

PROCPTR zerolist_1_choice2()
{
  TRUST_ME
  EXECUTE( R2_zerolist_1 )
}

PROCPTR R1_zerolist_1()
{
  GET_NIL( A1 )
  PROCEED
}

PROCPTR R2_zerolist_1()
{
  GET_LIST( A1, goto rd_mode_arg1; )
wr_mode_arg1:
	   PUSH_INTEGER( 0 )
	   PUSH_VARIABLE( A1 )
	   goto end_arg1;
rd_mode_arg1:
	   RD_UNIFY_INTEGER( 0 )
	   RD_UNIFY_VARIABLE( A1 )
end_arg1:
  EXECUTE( zerolist_1 ) 
}



La mise en boucle se fait en reportant (une partie de) la
sequence d'indexation
avant l'appel recursif: la recursion directe est transformee en un simple
branchement dans la meme fonction C.
Cette transformation ouvre la voie a de nombreuses autres optimisations:
il est ainsi possible de realiser a l'entree de la procedure une copie
locale des registres de la WAM ce qui permet a un bon compilateur C de 
generer un code quasi optimal (registres WAM mappes dans les 
registres de la machine hote).

Dans l'exemple ci-dessous, la macro-expression 'LISTPOINTER(A)' renvoie 0 
si 'A' n'est pas une paire
pointee, l'adresse du premier element sinon.

PROCPTR R2_zerolist_1()
{
  register heappointer S;
  register CELL localA1 = A1;

  GET_LIST( localA1, goto rd_mode_arg1; )
	    PUSH_INTEGER( 0 )
	    PUSH_VARIABLE( localA1 )
	    goto end_arg1;
rd_mode_arg1:
	    RD_UNIFY_INTEGER( 0 )
	    RD_UNIFY_VARIABLE( localA1 )
end_arg1:
					/* tail indexing */
  DEREF( localA1 )
  if ( S = LISTPOINTER(localA1) )
     goto rd_mode_arg1;	              /* LOOP WHILE arg1 is LIST */

  A1 = localA1;
  EXECUTE( zerolist_1 )			/* less need to optimize other cases */
}



Ici le code peut encore etre ameliore en tirant partie du fait qu'en write
mode, 'push_variable' cree une nouvelle variable. En expansant completement
la sequence d'indexation, on obtient:

PROCPTR R2_zerolist_1()
{
  register heappointer S;
  register CELL localA1 = A1;

  GET_LIST( localA1, goto rd_mode_arg1; )
	    PUSH_INTEGER( 0 )
	    PUSH_VARIABLE( localA1 )
	    goto goal_arg1_is_var;
rd_mode_arg1:
	    RD_UNIFY_INTEGER( 0 )
	    RD_UNIFY_VARIABLE( localA1 )
  DEREF( localA1 )                        /* last call indexing */
  if ( S = LISTPOINTER(localA1) )
      goto rd_mode_arg1;                  /* LOOP WHILE arg1 is a list */
  else if ( localA1 == NIL )
      PROCEED
  else if ( ! VAR(localA1) )
      EXECUTE( fail )
  else {
goal_arg1_is_var:                        /* localA1 reference a var */
	    A1 = localA1;
	    TRY_ME_ELSE( zerolist_1_choice2 )
	    GET_NIL( A1 )				                   /* inline expansion of R1 */
	    PROCEED
	    }
}

On notera que:
- Le registre argument global A1 doit etre restaure avant la creation
du point de choix si ce dernier n'est pas expanse en ligne. 
La restauration n'est pas
necessaire dans les autres cas puisque la duree de vie des registres
arguments n'excede pas l'appel de procedure.

- s'il y a plusieurs arguments, la fin de la sequence write mode du 
premier argument ne peut brancher directement sur la creation du point 
de choix.

- l'utilisation des 'else' est facultative puisque les instructions
executees lorsque la condition est vraie sont toutes 
des instructions de rupture de sequence.


Des appels de fonction peuvent etre supprimes en remontant dans les
fonctions d'index le code des faits:

PROCPTR zerolist_1()
{
  SWITCH_ON_TERM( goto choice1;				/* var */ 
		              , goto r1_zerolist_1;			/* cst */
		              , EXECUTE( R2_zerolist_1 )		/* list pair */
		              , EXECUTE( fail )			/* struct */
		              )
choice1:
    TRY_ME_ELSE( zerolist_1_choice2 )
r1_zerolist_1:
    GET_NIL( A1 )
    PROCEED
}
----------------------------------------------

Best regards    

Jean Francois Pique


----- End Included Message -----


