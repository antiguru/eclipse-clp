
------ Test 1 -------
p :-
	p(A).

p / 0:
label(L0):
	put_variable             a(1) 
	jmp                      p / 1 

------ Test 2 -------
p :-
	p(A),
	q(A),
	r(A).

p / 0:
label(L0):
	allocate                 1 
	put_global_variable      a(1)     y(1) 
	callf                    p / 1     Y[1] 
	move                     y(1)     a(1) 
	callf                    q / 1     Y[1] 
	move                     y(1)     a(1) 
	chain                    r / 1 

------ Test 3 -------
p :-
	(
	    q(A)
	;
	    r(A)
	).

p / 0:
label(L0):
	allocate                 0 
	try_me_else              0     0     ref(L2) 
label(L1):
	put_variable             a(1) 
	callf                    q / 1     Y[] 
	branch                   ref(L4) 
label(L2):
	trust_me_inline          0     Y[] 
label(L3):
	put_variable             a(1) 
	callf                    r / 1     Y[] 
label(L4):
	exit                 

------ Test 4 -------
p :-
	p(A),
	(
	    q(A)
	;
	    r(A)
	).

p / 0:
label(L0):
	allocate                 1 
	put_global_variable      a(1)     y(1) 
	callf                    p / 1     Y[1] 
	try_me_else              0     0     ref(L2) 
label(L1):
	move                     y(1)     a(1) 
	callf                    q / 1     Y[] 
	branch                   ref(L4) 
label(L2):
	trust_me_inline          0     Y[1] 
label(L3):
	move                     y(1)     a(1) 
	callf                    r / 1     Y[] 
label(L4):
	exit                 

------ Test 5 -------
p :-
	(
	    q(A)
	;
	    r(A)
	),
	p(A).

p / 0:
label(L0):
	allocate                 1 
	try_me_else              0     0     ref(L2) 
label(L1):
	put_global_variable      a(1)     y(1) 
	callf                    q / 1     Y[1] 
	branch                   ref(L4) 
label(L2):
	trust_me_inline          0     Y[] 
label(L3):
	put_global_variable      a(1)     y(1) 
	callf                    r / 1     Y[1] 
label(L4):
	move                     y(1)     a(1) 
	chain                    p / 1 

------ Test 6 -------
p :-
	(
	    q(A),
	    r(A)
	;
	    s(A),
	    t(A)
	).

p / 0:
label(L0):
	allocate                 1 
	try_me_else              0     0     ref(L2) 
label(L1):
	put_global_variable      a(1)     y(1) 
	callf                    q / 1     Y[1] 
	move                     y(1)     a(1) 
	callf                    r / 1     Y[] 
	branch                   ref(L4) 
label(L2):
	trust_me_inline          0     Y[] 
label(L3):
	put_global_variable      a(1)     y(1) 
	callf                    s / 1     Y[1] 
	move                     y(1)     a(1) 
	callf                    t / 1     Y[] 
label(L4):
	exit                 

------ Test 7 -------
p :-
	f(A),
	(
	    q(A),
	    r(A)
	;
	    s(A),
	    t(A)
	).

p / 0:
label(L0):
	allocate                 1 
	put_global_variable      a(1)     y(1) 
	callf                    f / 1     Y[1] 
	try_me_else              0     0     ref(L2) 
label(L1):
	move                     y(1)     a(1) 
	callf                    q / 1     Y[1] 
	move                     y(1)     a(1) 
	callf                    r / 1     Y[] 
	branch                   ref(L4) 
label(L2):
	trust_me_inline          0     Y[1] 
label(L3):
	move                     y(1)     a(1) 
	callf                    s / 1     Y[1] 
	move                     y(1)     a(1) 
	callf                    t / 1     Y[] 
label(L4):
	exit                 

------ Test 8 -------
p :-
	(
	    q(A),
	    r(A)
	;
	    s(A),
	    t(A)
	),
	f(A).

p / 0:
label(L0):
	allocate                 1 
	try_me_else              0     0     ref(L2) 
label(L1):
	put_global_variable      a(1)     y(1) 
	callf                    q / 1     Y[1] 
	move                     y(1)     a(1) 
	callf                    r / 1     Y[1] 
	branch                   ref(L4) 
label(L2):
	trust_me_inline          0     Y[] 
label(L3):
	put_global_variable      a(1)     y(1) 
	callf                    s / 1     Y[1] 
	move                     y(1)     a(1) 
	callf                    t / 1     Y[1] 
label(L4):
	move                     y(1)     a(1) 
	chain                    f / 1 

------ Test 9 -------
p :-
	(
	    a(A)
	;
	    (
		b(A)
	    ;
		c(A)
	    ),
	    (
		d(A)
	    ;
		e(A)
	    )
	).

p / 0:
label(L0):
	allocate                 1 
	try_me_else              0     0     ref(L2) 
label(L1):
	put_variable             a(1) 
	callf                    a / 1     Y[] 
	branch                   ref(L12) 
label(L2):
	trust_me_inline          0     Y[] 
label(L3):
	try_me_else              0     0     ref(L5) 
label(L4):
	put_global_variable      a(1)     y(1) 
	callf                    b / 1     Y[1] 
	branch                   ref(L7) 
label(L5):
	trust_me_inline          0     Y[] 
label(L6):
	put_global_variable      a(1)     y(1) 
	callf                    c / 1     Y[1] 
label(L7):
	try_me_else              0     0     ref(L9) 
label(L8):
	move                     y(1)     a(1) 
	callf                    d / 1     Y[] 
	branch                   ref(L11) 
label(L9):
	trust_me_inline          0     Y[1] 
label(L10):
	move                     y(1)     a(1) 
	callf                    e / 1     Y[] 
label(L11):
label(L12):
	exit                 

------ Test 10 -------
p(a, A) :-
	q(A).
p(b, A) :-
	r(A).

INDEXES for disjunction [2]
1. Quality 1.3
    [] - []
    [atom] - []
    [atom, a] - [1]
    [atom, b] - [2]
    [var] - [1, 2]
p / 2:
label(L0):
	allocate                 0 
label(L1):
	atom_switch              a(1) 
		a: 	ref(L3)
		b: 	ref(L5)
		default: 	ref(fail)

label(L2):
	try_me_else              0     2     ref(L4) 
label(L3):
	get_atom                 a(1)     a 
	move                     a(2)     a(1) 
	callf                    q / 1     Y[] 
	branch                   ref(L6) 
label(L4):
	trust_me_inline          0     Y[] 
label(L5):
	get_atom                 a(1)     b 
	move                     a(2)     a(1) 
	callf                    r / 1     Y[] 
label(L6):
	exit                 

------ Test 11 -------
p :-
	p(A, A).

p / 0:
label(L0):
	put_variable             a(1) 
	move                     a(1)     a(2) 
	jmp                      p / 2 

------ Test 12 -------
p :-
	p(A, A),
	q(A, A),
	r(A, A).

p / 0:
label(L0):
	allocate                 1 
	put_global_variable      a(1)     y(1) 
	move                     a(1)     a(2) 
	callf                    p / 2     Y[1] 
	move                     y(1)     a(1) 
	move                     a(1)     a(2) 
	callf                    q / 2     Y[1] 
	move                     y(1)     a(1) 
	move                     a(1)     a(2) 
	chain                    r / 2 

------ Test 13 -------
p :-
	(
	    q(A, A)
	;
	    r(A, A)
	).

p / 0:
label(L0):
	allocate                 0 
	try_me_else              0     0     ref(L2) 
label(L1):
	put_variable             a(1) 
	move                     a(1)     a(2) 
	callf                    q / 2     Y[] 
	branch                   ref(L4) 
label(L2):
	trust_me_inline          0     Y[] 
label(L3):
	put_variable             a(1) 
	move                     a(1)     a(2) 
	callf                    r / 2     Y[] 
label(L4):
	exit                 

------ Test 14 -------
p :-
	p(A, A),
	(
	    q(A, A)
	;
	    r(A, A)
	).

p / 0:
label(L0):
	allocate                 1 
	put_global_variable      a(1)     y(1) 
	move                     a(1)     a(2) 
	callf                    p / 2     Y[1] 
	try_me_else              0     0     ref(L2) 
label(L1):
	move                     y(1)     a(1) 
	move                     a(1)     a(2) 
	callf                    q / 2     Y[] 
	branch                   ref(L4) 
label(L2):
	trust_me_inline          0     Y[1] 
label(L3):
	move                     y(1)     a(1) 
	move                     a(1)     a(2) 
	callf                    r / 2     Y[] 
label(L4):
	exit                 

------ Test 15 -------
p :-
	(
	    q(A, A)
	;
	    r(A, A)
	),
	p(A, A).

p / 0:
label(L0):
	allocate                 1 
	try_me_else              0     0     ref(L2) 
label(L1):
	put_global_variable      a(1)     y(1) 
	move                     a(1)     a(2) 
	callf                    q / 2     Y[1] 
	branch                   ref(L4) 
label(L2):
	trust_me_inline          0     Y[] 
label(L3):
	put_global_variable      a(1)     y(1) 
	move                     a(1)     a(2) 
	callf                    r / 2     Y[1] 
label(L4):
	move                     y(1)     a(1) 
	move                     a(1)     a(2) 
	chain                    p / 2 

------ Test 16 -------
p :-
	(
	    q(A, A),
	    r(A, A)
	;
	    s(A, A),
	    t(A, A)
	).

p / 0:
label(L0):
	allocate                 1 
	try_me_else              0     0     ref(L2) 
label(L1):
	put_global_variable      a(1)     y(1) 
	move                     a(1)     a(2) 
	callf                    q / 2     Y[1] 
	move                     y(1)     a(1) 
	move                     a(1)     a(2) 
	callf                    r / 2     Y[] 
	branch                   ref(L4) 
label(L2):
	trust_me_inline          0     Y[] 
label(L3):
	put_global_variable      a(1)     y(1) 
	move                     a(1)     a(2) 
	callf                    s / 2     Y[1] 
	move                     y(1)     a(1) 
	move                     a(1)     a(2) 
	callf                    t / 2     Y[] 
label(L4):
	exit                 

------ Test 17 -------
p :-
	f(A, A),
	(
	    q(A, A),
	    r(A, A)
	;
	    s(A, A),
	    t(A, A)
	).

p / 0:
label(L0):
	allocate                 1 
	put_global_variable      a(1)     y(1) 
	move                     a(1)     a(2) 
	callf                    f / 2     Y[1] 
	try_me_else              0     0     ref(L2) 
label(L1):
	move                     y(1)     a(1) 
	move                     a(1)     a(2) 
	callf                    q / 2     Y[1] 
	move                     y(1)     a(1) 
	move                     a(1)     a(2) 
	callf                    r / 2     Y[] 
	branch                   ref(L4) 
label(L2):
	trust_me_inline          0     Y[1] 
label(L3):
	move                     y(1)     a(1) 
	move                     a(1)     a(2) 
	callf                    s / 2     Y[1] 
	move                     y(1)     a(1) 
	move                     a(1)     a(2) 
	callf                    t / 2     Y[] 
label(L4):
	exit                 

------ Test 18 -------
p :-
	(
	    q(A, A),
	    r(A, A)
	;
	    s(A, A),
	    t(A, A)
	),
	f(A, A).

p / 0:
label(L0):
	allocate                 1 
	try_me_else              0     0     ref(L2) 
label(L1):
	put_global_variable      a(1)     y(1) 
	move                     a(1)     a(2) 
	callf                    q / 2     Y[1] 
	move                     y(1)     a(1) 
	move                     a(1)     a(2) 
	callf                    r / 2     Y[1] 
	branch                   ref(L4) 
label(L2):
	trust_me_inline          0     Y[] 
label(L3):
	put_global_variable      a(1)     y(1) 
	move                     a(1)     a(2) 
	callf                    s / 2     Y[1] 
	move                     y(1)     a(1) 
	move                     a(1)     a(2) 
	callf                    t / 2     Y[1] 
label(L4):
	move                     y(1)     a(1) 
	move                     a(1)     a(2) 
	chain                    f / 2 

------ Test 19 -------
p :-
	a(A),
	(
	    a(A, B)
	;
	    a(A, B, B)
	).

p / 0:
label(L0):
	allocate                 1 
	put_global_variable      a(1)     y(1) 
	callf                    a / 1     Y[1] 
	try_me_else              0     0     ref(L2) 
label(L1):
	put_variable             a(2) 
	move                     y(1)     a(1) 
	callf                    a / 2     Y[] 
	branch                   ref(L4) 
label(L2):
	trust_me_inline          0     Y[1] 
label(L3):
	put_variable             a(2) 
	move                     a(2)     a(3) 
	move                     y(1)     a(1) 
	callf                    a / 3     Y[] 
label(L4):
	exit                 

------ Test 30 -------
p :-
	p,
	+(1, 2, 3).

p / 0:
label(L0):
	allocate                 0 
	callf                    ref(L0)     Y[] 
	put_integer              a(1)     1 
	put_integer              a(2)     2 
	put_integer              a(3)     3 
	bi_add                   a(1)     a(2)     a(3) 
	exit                 

------ Test 31 -------
p :-
	p(A),
	q,
	+(A, 2, 3).

p / 0:
label(L0):
	allocate                 1 
	put_global_variable      a(1)     y(1) 
	callf                    p / 1     Y[1] 
	callf                    q / 0     Y[1] 
	put_integer              a(1)     2 
	put_integer              a(2)     3 
	move                     y(1)     a(3) 
	bi_add                   a(3)     a(1)     a(2) 
	exit                 

------ Test 32 -------
p(A, A, B) :-
	q(a, b, A).

p / 3:
label(L0):
	get_value                a(2)     a(1) 
	move                     a(1)     a(3) 
	put_atom                 a(1)     a 
	put_atom                 a(2)     b 
	jmp                      q / 3 

------ Test 33 -------
p(A, A) :-
	+(B, C, 1),
	q(a, b, A).

p / 2:
label(L0):
	get_value                a(2)     a(1) 
	put_variable             a(4) 
	put_variable             a(5) 
	put_integer              a(6)     1 
	bi_add                   a(4)     a(5)     a(6) 
	move                     a(1)     a(3) 
	put_atom                 a(1)     a 
	put_atom                 a(2)     b 
	jmp                      q / 3 

------ Test 34 -------
p(A, B, C) :-
	+(D, E, F),
	p(A, B, C).

p / 3:
label(L0):
	put_variable             a(4) 
	put_variable             a(5) 
	put_variable             a(6) 
	bi_add                   a(4)     a(5)     a(6) 
	jmp                      ref(L0) 

------ Test 35 -------
p(A) :-
	(
	    q(A)
	;
	    r(A)
	).

p / 1:
label(L0):
	allocate                 1 
	move                     a(1)     y(1) 
	try_me_else              0     0     ref(L2) 
label(L1):
	move                     y(1)     a(1) 
	callf                    q / 1     Y[] 
	branch                   ref(L4) 
label(L2):
	trust_me_inline          0     Y[1] 
label(L3):
	move                     y(1)     a(1) 
	callf                    r / 1     Y[] 
label(L4):
	exit                 

------ Test 36 -------
p :-
	A = B,
	q,
	r(B).

p / 0:
label(L0):
	allocate                 1 
	put_global_variable      y(1) 
	callf                    q / 0     Y[1] 
	move                     y(1)     a(1) 
	chain                    r / 1 

------ Test 37 -------
p :-
	A = B,
	q(A),
	r(B).

p / 0:
label(L0):
	allocate                 1 
	put_global_variable      a(1)     y(1) 
	callf                    q / 1     Y[1] 
	move                     y(1)     a(1) 
	chain                    r / 1 

------ Test 38 -------
p(A) :-
	q,
	r(A).

p / 1:
label(L0):
	allocate                 1 
	move                     a(1)     y(1) 
	callf                    q / 0     Y[1] 
	move                     y(1)     a(1) 
	chain                    r / 1 

------ Test 39 -------
p(A) :-
	B = A,
	q(B),
	r(A).

p / 1:
label(L0):
	allocate                 1 
	move                     a(1)     a(2) 
	move                     a(1)     y(1) 
	move                     a(2)     a(1) 
	callf                    q / 1     Y[1] 
	move                     y(1)     a(1) 
	chain                    r / 1 

------ Test 40 -------
p :-
	q(A),
	(
	    r1(B),
	    r2(A, B)
	;
	    s(A)
	).

p / 0:
label(L0):
	allocate                 2 
	put_global_variable      a(1)     y(1) 
	callf                    q / 1     Y[1] 
	try_me_else              0     0     ref(L2) 
label(L1):
	put_global_variable      a(1)     y(2) 
	callf                    r1 / 1     Y[1,2] 
	move                     2     y(1)     a(1) 
	callf                    r2 / 2     Y[] 
	branch                   ref(L4) 
label(L2):
	trust_me_inline          0     Y[1] 
label(L3):
	move                     y(1)     a(1) 
	callf                    s / 1     Y[] 
label(L4):
	exit                 

------ Test 41 -------
p :-
	(
	    !
	;
	    p(A),
	    p(A),
	    !
	).

p / 0:
label(L0):
	allocate                 2 
	savecut                  y(1) 
	try_me_else              0     0     ref(L2) 
label(L1):
	cut                      y(1)     2 
	branch                   ref(L4) 
label(L2):
	trust_me_inline          0     Y[1] 
label(L3):
	put_global_variable      a(1)     y(2) 
	callf                    p / 1     Y[1,2] 
	move                     y(2)     a(1) 
	callf                    p / 1     Y[1] 
	cut                      y(1)     2 
label(L4):
	exit                 

------ Test 42 -------
p(A, B) :-
	!.
p(A, B) :-
	p(A),
	p(B),
	!.

p / 2:
label(L0):
	allocate                 2 
	savecut                  y(1) 
	try_me_else              0     2     ref(L2) 
label(L1):
	cut                      y(1)     2 
	branch                   ref(L4) 
label(L2):
	trust_me_inline          0     Y[1] 
label(L3):
	move                     a(2)     y(2) 
	callf                    p / 1     Y[1,2] 
	move                     y(2)     a(1) 
	callf                    p / 1     Y[1] 
	cut                      y(1)     2 
label(L4):
	exit                 

------ Test 43 -------
p :-
	s(A),
	(
	    c(A)
	;
	    p(B),
	    p(B),
	    c(A)
	).

p / 0:
label(L0):
	allocate                 2 
	put_global_variable      a(1)     y(1) 
	callf                    s / 1     Y[1] 
	try_me_else              0     0     ref(L2) 
label(L1):
	move                     y(1)     a(1) 
	callf                    c / 1     Y[] 
	branch                   ref(L4) 
label(L2):
	trust_me_inline          0     Y[1] 
label(L3):
	put_global_variable      a(1)     y(2) 
	callf                    p / 1     Y[1,2] 
	move                     y(2)     a(1) 
	callf                    p / 1     Y[1] 
	move                     y(1)     a(1) 
	callf                    c / 1     Y[] 
label(L4):
	exit                 

------ Test 44 -------
p :-
	s(A),
	(
	    c(A)
	;
	    p(B),
	    p(A),
	    c(B)
	).

p / 0:
label(L0):
	allocate                 2 
	put_global_variable      a(1)     y(1) 
	callf                    s / 1     Y[1] 
	try_me_else              0     0     ref(L2) 
label(L1):
	move                     y(1)     a(1) 
	callf                    c / 1     Y[] 
	branch                   ref(L4) 
label(L2):
	trust_me_inline          0     Y[1] 
label(L3):
	put_global_variable      a(1)     y(2) 
	callf                    p / 1     Y[1,2] 
	move                     y(1)     a(1) 
	callf                    p / 1     Y[2] 
	move                     y(2)     a(1) 
	callf                    c / 1     Y[] 
label(L4):
	exit                 

------ Test 45 -------
p :-
	s(A),
	(
	    p(A),
	    q,
	    r
	;
	    (
		p,
		q(A),
		r
	    ;
		p,
		q,
		r(A)
	    )
	).

p / 0:
label(L0):
	allocate                 1 
	put_global_variable      a(1)     y(1) 
	callf                    s / 1     Y[1] 
	try_me_else              0     0     ref(L2) 
label(L1):
	move                     y(1)     a(1) 
	callf                    p / 1     Y[] 
	callf                    q / 0     Y[] 
	callf                    r / 0     Y[] 
	branch                   ref(L6) 
label(L2):
	retry_me_inline          0     ref(L4)     Y[1] 
label(L3):
	callf                    ref(L0)     Y[1] 
	move                     y(1)     a(1) 
	callf                    q / 1     Y[] 
	callf                    r / 0     Y[] 
	branch                   ref(L6) 
label(L4):
	trust_me_inline          0     Y[1] 
label(L5):
	callf                    ref(L0)     Y[1] 
	callf                    q / 0     Y[1] 
	move                     y(1)     a(1) 
	callf                    r / 1     Y[] 
label(L6):
	exit                 

------ Test 46 -------
p :-
	s(A),
	(
	    p,
	    q,
	    r(A)
	;
	    (
		p,
		q(A),
		r
	    ;
		p(A),
		q,
		r
	    )
	).

p / 0:
label(L0):
	allocate                 1 
	put_global_variable      a(1)     y(1) 
	callf                    s / 1     Y[1] 
	try_me_else              0     0     ref(L2) 
label(L1):
	callf                    ref(L0)     Y[1] 
	callf                    q / 0     Y[1] 
	move                     y(1)     a(1) 
	callf                    r / 1     Y[] 
	branch                   ref(L6) 
label(L2):
	retry_me_inline          0     ref(L4)     Y[1] 
label(L3):
	callf                    ref(L0)     Y[1] 
	move                     y(1)     a(1) 
	callf                    q / 1     Y[] 
	callf                    r / 0     Y[] 
	branch                   ref(L6) 
label(L4):
	trust_me_inline          0     Y[1] 
label(L5):
	move                     y(1)     a(1) 
	callf                    p / 1     Y[] 
	callf                    q / 0     Y[] 
	callf                    r / 0     Y[] 
label(L6):
	exit                 

------ Test 47 -------
p :-
	s(A),
	(
	    p,
	    q(A),
	    r
	;
	    (
		p,
		q,
		r(A)
	    ;
		p,
		q,
		r(A)
	    )
	).

p / 0:
label(L0):
	allocate                 1 
	put_global_variable      a(1)     y(1) 
	callf                    s / 1     Y[1] 
	try_me_else              0     0     ref(L2) 
label(L1):
	callf                    ref(L0)     Y[1] 
	move                     y(1)     a(1) 
	callf                    q / 1     Y[] 
	callf                    r / 0     Y[] 
	branch                   ref(L6) 
label(L2):
	retry_me_inline          0     ref(L4)     Y[1] 
label(L3):
	callf                    ref(L0)     Y[1] 
	callf                    q / 0     Y[1] 
	move                     y(1)     a(1) 
	callf                    r / 1     Y[] 
	branch                   ref(L6) 
label(L4):
	trust_me_inline          0     Y[1] 
label(L5):
	callf                    ref(L0)     Y[1] 
	callf                    q / 0     Y[1] 
	move                     y(1)     a(1) 
	callf                    r / 1     Y[] 
label(L6):
	exit                 

------ Test 50 -------
p :-
	s(A),
	(
	    p(A),
	    q(B),
	    r(B)
	;
	    p(B),
	    q(B, C),
	    r(C)
	).

p / 0:
label(L0):
	allocate                 3 
	put_global_variable      a(1)     y(1) 
	callf                    s / 1     Y[1] 
	try_me_else              0     0     ref(L2) 
label(L1):
	move                     y(1)     a(1) 
	callf                    p / 1     Y[] 
	put_global_variable      a(1)     y(2) 
	callf                    q / 1     Y[2] 
	move                     y(2)     a(1) 
	callf                    r / 1     Y[] 
	branch                   ref(L4) 
label(L2):
	trust_me_inline          0     Y[] 
label(L3):
	put_global_variable      a(1)     y(3) 
	callf                    p / 1     Y[3] 
	put_global_variable      a(2)     y(2) 
	move                     y(3)     a(1) 
	callf                    q / 2     Y[2] 
	move                     y(2)     a(1) 
	callf                    r / 1     Y[] 
label(L4):
	exit                 

------ Test 51 -------
p :-
	s(A),
	(
	    p(A),
	    q(B),
	    r(B)
	;
	    (
		p1(A),
		q1(C),
		q1(C)
	    ;
		p(B),
		q(B, D),
		r(D)
	    )
	).

p / 0:
label(L0):
	allocate                 3 
	put_global_variable      a(1)     y(1) 
	callf                    s / 1     Y[1] 
	try_me_else              0     0     ref(L2) 
label(L1):
	move                     y(1)     a(1) 
	callf                    p / 1     Y[] 
	put_global_variable      a(1)     y(2) 
	callf                    q / 1     Y[2] 
	move                     y(2)     a(1) 
	callf                    r / 1     Y[] 
	branch                   ref(L6) 
label(L2):
	retry_me_inline          0     ref(L4)     Y[1] 
label(L3):
	move                     y(1)     a(1) 
	callf                    p1 / 1     Y[] 
	put_global_variable      a(1)     y(2) 
	callf                    q1 / 1     Y[2] 
	move                     y(2)     a(1) 
	callf                    q1 / 1     Y[] 
	branch                   ref(L6) 
label(L4):
	trust_me_inline          0     Y[] 
label(L5):
	put_global_variable      a(1)     y(3) 
	callf                    p / 1     Y[3] 
	put_global_variable      a(2)     y(2) 
	move                     y(3)     a(1) 
	callf                    q / 2     Y[2] 
	move                     y(2)     a(1) 
	callf                    r / 1     Y[] 
label(L6):
	exit                 

------ Test 52 -------
p :-
	(
	    p(A)
	;
	    q
	),
	(
	    p(A)
	;
	    q
	).

p / 0:
label(L0):
	allocate                 1 
	try_me_else              0     0     ref(L2) 
label(L1):
	put_global_variable      a(1)     y(1) 
	callf                    p / 1     Y[1] 
	branch                   ref(L4) 
label(L2):
	trust_me_inline          0     Y[] 
label(L3):
	callf                    q / 0     Y[] 
	put_global_variable      y(1) 
label(L4):
	try_me_else              0     0     ref(L6) 
label(L5):
	move                     y(1)     a(1) 
	callf                    p / 1     Y[] 
	branch                   ref(L8) 
label(L6):
	trust_me_inline          0     Y[] 
label(L7):
	callf                    q / 0     Y[] 
label(L8):
	exit                 

------ Test 53 -------
p :-
	(
	    p(A)
	;
	    q(A)
	),
	(
	    p(A)
	;
	    q
	).

p / 0:
label(L0):
	allocate                 1 
	try_me_else              0     0     ref(L2) 
label(L1):
	put_global_variable      a(1)     y(1) 
	callf                    p / 1     Y[1] 
	branch                   ref(L4) 
label(L2):
	trust_me_inline          0     Y[] 
label(L3):
	put_global_variable      a(1)     y(1) 
	callf                    q / 1     Y[1] 
label(L4):
	try_me_else              0     0     ref(L6) 
label(L5):
	move                     y(1)     a(1) 
	callf                    p / 1     Y[] 
	branch                   ref(L8) 
label(L6):
	trust_me_inline          0     Y[] 
label(L7):
	callf                    q / 0     Y[] 
label(L8):
	exit                 

------ Test 54 -------
p(A) :-
	A = a,
	p,
	p(A).

p / 1:
label(L0):
	allocate                 1 
	get_atom                 a(1)     a 
	move                     a(1)     y(1) 
	callf                    p / 0     Y[1] 
	move                     y(1)     a(1) 
	chain                    ref(L0) 

------ Test 55 -------
p(A) :-
	A = B,
	p(B),
	p(A).

p / 1:
label(L0):
	allocate                 1 
	move                     a(1)     a(2) 
	move                     a(1)     y(1) 
	move                     a(2)     a(1) 
	callf                    ref(L0)     Y[1] 
	move                     y(1)     a(1) 
	chain                    ref(L0) 

------ Test 56 -------
p(A, B) :-
	A = B,
	p(B),
	p(A).

p / 2:
label(L0):
	allocate                 1 
	get_value                a(1)     a(2) 
	move                     a(1)     y(1) 
	move                     a(2)     a(1) 
	callf                    p / 1     Y[1] 
	move                     y(1)     a(1) 
	chain                    p / 1 

------ Test 57 -------
p(A, B) :-
	A = B,
	p,
	p(A, B).

p / 2:
label(L0):
	allocate                 2 
	get_value                a(1)     a(2) 
	move                     2     a(1)     y(1) 
	callf                    p / 0     Y[1,2] 
	move                     2     y(1)     a(1) 
	chain                    ref(L0) 

------ Test 58 -------
p(A) :-
	A = B,
	p,
	p(A, B).

p / 1:
label(L0):
	allocate                 2 
	move2                    a(1)     y(1)     a(1)     y(2) 
	callf                    p / 0     Y[1,2] 
	move2                    y(2)     a(1)     y(1)     a(2) 
	chain                    p / 2 

------ Test 59 -------
p(A) :-
	A = B,
	p,
	p(A).

p / 1:
label(L0):
	allocate                 1 
	move                     a(1)     y(1) 
	callf                    p / 0     Y[1] 
	move                     y(1)     a(1) 
	chain                    ref(L0) 

------ Test 60 -------
p :-
	A = B,
	p,
	p(A, B).

p / 0:
label(L0):
	allocate                 2 
	put_global_variable      y(1) 
	move                     y(1)     y(2) 
	callf                    ref(L0)     Y[1,2] 
	move                     2     y(1)     a(1) 
	chain                    p / 2 

------ Test 101 -------
p :-
	p(A),
	q(B, A),
	r(B),
	t(B).

p / 0:
label(L0):
	allocate                 2 
	put_global_variable      a(1)     y(2) 
	callf                    p / 1     Y[2] 
	put_global_variable      a(1)     y(1) 
	move                     y(2)     a(2) 
	callf                    q / 2     Y[1] 
	move                     y(1)     a(1) 
	callf                    r / 1     Y[1] 
	move                     y(1)     a(1) 
	chain                    t / 1 

------ Test 102 -------
p :-
	p(A),
	q(A, B, C),
	r(B, D),
	t(D).

p / 0:
label(L0):
	allocate                 3 
	put_global_variable      a(1)     y(3) 
	callf                    p / 1     Y[3] 
	put_variable             a(3) 
	put_global_variable      a(2)     y(2) 
	move                     y(3)     a(1) 
	callf                    q / 3     Y[2] 
	put_global_variable      a(2)     y(1) 
	move                     y(2)     a(1) 
	callf                    r / 2     Y[1] 
	move                     y(1)     a(1) 
	chain                    t / 1 

------ Test 103 -------
p :-
	(
	    f(A),
	    g(A),
	    a(B)
	;
	    b(C),
	    c(C),
	    d(B)
	),
	e(B).

p / 0:
label(L0):
	allocate                 2 
	try_me_else              0     0     ref(L2) 
label(L1):
	put_global_variable      a(1)     y(2) 
	callf                    f / 1     Y[2] 
	move                     y(2)     a(1) 
	callf                    g / 1     Y[] 
	put_global_variable      a(1)     y(1) 
	callf                    a / 1     Y[1] 
	branch                   ref(L4) 
label(L2):
	trust_me_inline          0     Y[] 
label(L3):
	put_global_variable      a(1)     y(2) 
	callf                    b / 1     Y[2] 
	move                     y(2)     a(1) 
	callf                    c / 1     Y[] 
	put_global_variable      a(1)     y(1) 
	callf                    d / 1     Y[1] 
label(L4):
	move                     y(1)     a(1) 
	chain                    e / 1 

------ Test 104 -------
p :-
	(
	    f(A),
	    g(A),
	    a(B)
	;
	    b(C),
	    c(C)
	),
	e(B).

p / 0:
label(L0):
	allocate                 2 
	try_me_else              0     0     ref(L2) 
label(L1):
	put_global_variable      a(1)     y(2) 
	callf                    f / 1     Y[2] 
	move                     y(2)     a(1) 
	callf                    g / 1     Y[] 
	put_global_variable      a(1)     y(1) 
	callf                    a / 1     Y[1] 
	branch                   ref(L4) 
label(L2):
	trust_me_inline          0     Y[] 
label(L3):
	put_global_variable      a(1)     y(2) 
	callf                    b / 1     Y[2] 
	move                     y(2)     a(1) 
	callf                    c / 1     Y[] 
	put_global_variable      y(1) 
label(L4):
	move                     y(1)     a(1) 
	chain                    e / 1 

------ Test 105 -------
p :-
	(
	    f(A),
	    g(A),
	    a(B)
	;
	    b(C),
	    c(C)
	),
	e(B),
	f(B).

p / 0:
label(L0):
	allocate                 2 
	try_me_else              0     0     ref(L2) 
label(L1):
	put_global_variable      a(1)     y(2) 
	callf                    f / 1     Y[2] 
	move                     y(2)     a(1) 
	callf                    g / 1     Y[] 
	put_global_variable      a(1)     y(1) 
	callf                    a / 1     Y[1] 
	branch                   ref(L4) 
label(L2):
	trust_me_inline          0     Y[] 
label(L3):
	put_global_variable      a(1)     y(2) 
	callf                    b / 1     Y[2] 
	move                     y(2)     a(1) 
	callf                    c / 1     Y[] 
	put_global_variable      y(1) 
label(L4):
	move                     y(1)     a(1) 
	callf                    e / 1     Y[1] 
	move                     y(1)     a(1) 
	chain                    f / 1 

------ Test 106 -------
p :-
	a(A),
	(
	    b(A),
	    c(B)
	;
	    d(A),
	    e(B)
	),
	f(B).

p / 0:
label(L0):
	allocate                 2 
	put_global_variable      a(1)     y(2) 
	callf                    a / 1     Y[2] 
	try_me_else              0     0     ref(L2) 
label(L1):
	move                     y(2)     a(1) 
	callf                    b / 1     Y[] 
	put_global_variable      a(1)     y(1) 
	callf                    c / 1     Y[1] 
	branch                   ref(L4) 
label(L2):
	trust_me_inline          0     Y[2] 
label(L3):
	move                     y(2)     a(1) 
	callf                    d / 1     Y[] 
	put_global_variable      a(1)     y(1) 
	callf                    e / 1     Y[1] 
label(L4):
	move                     y(1)     a(1) 
	chain                    f / 1 

------ Test 107 -------
p :-
	a(A),
	(
	    b(A),
	    c(B)
	;
	    d(A),
	    e(B)
	),
	f(C).

p / 0:
label(L0):
	allocate                 1 
	put_global_variable      a(1)     y(1) 
	callf                    a / 1     Y[1] 
	try_me_else              0     0     ref(L2) 
label(L1):
	move                     y(1)     a(1) 
	callf                    b / 1     Y[] 
	put_variable             a(1) 
	callf                    c / 1     Y[] 
	branch                   ref(L4) 
label(L2):
	trust_me_inline          0     Y[1] 
label(L3):
	move                     y(1)     a(1) 
	callf                    d / 1     Y[] 
	put_variable             a(1) 
	callf                    e / 1     Y[] 
label(L4):
	put_variable             a(1) 
	chain                    f / 1 

------ Test 108 -------
p :-
	a(A),
	(
	    b(A)
	;
	    c
	),
	d.

p / 0:
label(L0):
	allocate                 1 
	put_global_variable      a(1)     y(1) 
	callf                    a / 1     Y[1] 
	try_me_else              0     0     ref(L2) 
label(L1):
	move                     y(1)     a(1) 
	callf                    b / 1     Y[] 
	branch                   ref(L4) 
label(L2):
	trust_me_inline          0     Y[] 
label(L3):
	callf                    c / 0     Y[] 
label(L4):
	chain                    d / 0 

------ Test 109 -------
p :-
	a,
	b(A),
	c(B),
	d(A),
	e(B),
	f.

p / 0:
label(L0):
	allocate                 2 
	callf                    a / 0     Y[] 
	put_global_variable      a(1)     y(2) 
	callf                    b / 1     Y[2] 
	put_global_variable      a(1)     y(1) 
	callf                    c / 1     Y[1,2] 
	move                     y(2)     a(1) 
	callf                    d / 1     Y[1] 
	move                     y(1)     a(1) 
	callf                    e / 1     Y[] 
	chain                    f / 0 

------ Test 110 -------
p :-
	a(A),
	a(A, B, C),
	(
	    a
	;
	    (
		b(B),
		c(B)
	    ;
		(
		    d(D),
		    e(D)
		;
		    f(E),
		    g(E)
		)
	    )
	),
	f(D, C, F),
	g(F).

p / 0:
label(L0):
	allocate                 6 
	put_global_variable      a(1)     y(6) 
	callf                    a / 1     Y[6] 
	put_global_variable      a(2)     y(4) 
	put_global_variable      a(3)     y(3) 
	move                     y(6)     a(1) 
	callf                    a / 3     Y[3,4] 
	try_me_else              0     0     ref(L2) 
label(L1):
	callf                    a / 0     Y[3] 
	put_global_variable      y(2) 
	branch                   ref(L8) 
label(L2):
	retry_me_inline          0     ref(L4)     Y[3,4] 
label(L3):
	move                     y(4)     a(1) 
	callf                    b / 1     Y[3,4] 
	move                     y(4)     a(1) 
	callf                    c / 1     Y[3] 
	put_global_variable      y(2) 
	branch                   ref(L8) 
label(L4):
	retry_me_inline          0     ref(L6)     Y[3] 
label(L5):
	put_global_variable      a(1)     y(2) 
	callf                    d / 1     Y[2,3] 
	move                     y(2)     a(1) 
	callf                    e / 1     Y[2,3] 
	branch                   ref(L8) 
label(L6):
	trust_me_inline          0     Y[3] 
label(L7):
	put_global_variable      a(1)     y(5) 
	callf                    f / 1     Y[3,5] 
	move                     y(5)     a(1) 
	callf                    g / 1     Y[3] 
	put_global_variable      y(2) 
label(L8):
	put_global_variable      a(3)     y(1) 
	move                     2     y(2)     a(1) 
	callf                    f / 3     Y[1] 
	move                     y(1)     a(1) 
	chain                    g / 1 

------ Test 120 -------
sentence(A, B, C, D, E) :-
	declarative(A, B, F, D, G),
	terminator(., F, C, G, E).

sentence / 5:
label(L0):
	allocate                 4 
	move2                    a(3)     y(3)     a(5)     y(4) 
	put_global_variable      a(3)     y(1) 
	put_global_variable      a(5)     y(2) 
	callf                    declarative / 5     Y[1,2,3,4] 
	put_atom                 a(1)     . 
	move3                    y(1)     a(2)     y(3)     a(3)     y(2)     a(4) 
	move                     y(4)     a(5) 
	chain                    terminator / 5 

------ Test 200 -------
p :-
	a(A, A).

p / 0:
label(L0):
	put_variable             a(1) 
	move                     a(1)     a(2) 
	jmp                      a / 2 

------ Test 201 -------
p :-
	a(f(A), A).

p / 0:
label(L0):
	put_structure            a(1)     f / 1 
	push_variable            a(2) 
	jmp                      a / 2 

------ Test 202 -------
p :-
	a(f(A), A),
	b(f(A), A),
	c(A, f(A)).

p / 0:
label(L0):
	allocate                 1 
	put_structure            a(1)     f / 1 
	push_variable            y(1) 
	move                     y(1)     a(2) 
	callf                    a / 2     Y[1] 
	put_structure            a(1)     f / 1 
	push_local_value         y(1) 
	move                     y(1)     a(2) 
	callf                    b / 2     Y[1] 
	put_structure            a(2)     f / 1 
	push_local_value         y(1) 
	move                     y(1)     a(1) 
	chain                    c / 2 

------ Test 203 -------
p :-
	a(f(A), g(A)),
	b(f(g(A), A)),
	c(f(A, g(A))).

p / 0:
label(L0):
	allocate                 1 
	put_structure            a(1)     f / 1 
	push_variable            y(1) 
	put_structure            a(2)     g / 1 
	push_local_value         y(1) 
	callf                    a / 2     Y[1] 
	put_structure            a(1)     f / 2 
	push_structure           2 
	push_local_value         y(1) 
	write_did                g / 1 
	push_local_value         y(1) 
	callf                    b / 1     Y[1] 
	put_structure            a(1)     f / 2 
	push_local_value         y(1) 
	push_structure           2 
	write_did                g / 1 
	push_local_value         y(1) 
	chain                    c / 1 

------ Test 204 -------
p(A) :-
	a(A).

p / 1:
label(L0):
	jmp                      a / 1 

------ Test 205 -------
p(A) :-
	a(a, A).

p / 1:
label(L0):
	move                     a(1)     a(2) 
	put_atom                 a(1)     a 
	jmp                      a / 2 

------ Test 206 -------
p(a).

p / 1:
label(L0):
	get_atom                 a(1)     a 
	ret                  

------ Test 207 -------
p(A) :-
	a(A, A).

p / 1:
label(L0):
	move                     a(1)     a(2) 
	jmp                      a / 2 

------ Test 208 -------
p(A, B) :-
	a(A, B).

p / 2:
label(L0):
	jmp                      a / 2 

------ Test 209 -------
p(A, B) :-
	a(B, A).

p / 2:
label(L0):
	move                     a(1)     a(3) 
	move                     a(2)     a(1) 
	move                     a(3)     a(2) 
	jmp                      a / 2 

------ Test 210 -------
p :-
	A = B,
	a(B, A).

p / 0:
label(L0):
	put_variable             a(2) 
	move                     a(2)     a(1) 
	jmp                      a / 2 

------ Test 211 -------
p :-
	a(A, f(A)).

p / 0:
label(L0):
	put_structure            a(2)     f / 1 
	push_variable            a(1) 
	jmp                      a / 2 

------ Test 212 -------
p(A) :-
	a(f(A)).

p / 1:
label(L0):
	move                     a(1)     a(2) 
	put_structure            a(1)     f / 1 
	push_local_value         a(2) 
	jmp                      a / 1 

------ Test 213 -------
p(A, B, C) :-
	a(C, A, B).

p / 3:
label(L0):
	move                     a(2)     a(4) 
	move                     a(1)     a(2) 
	move                     a(3)     a(1) 
	move                     a(4)     a(3) 
	jmp                      a / 3 

------ Test 214 -------
p(A, B, C) :-
	a(f(C), f(A), f(B)).

p / 3:
label(L0):
	move                     a(1)     a(4) 
	put_structure            a(1)     f / 1 
	push_local_value         a(3) 
	move                     a(2)     a(5) 
	put_structure            a(2)     f / 1 
	push_local_value         a(4) 
	put_structure            a(3)     f / 1 
	push_local_value         a(5) 
	jmp                      a / 3 

------ Test 215 -------
p(A, B, C, A) :-
	a(C, A, B).

p / 4:
label(L0):
	get_value                a(4)     a(1) 
	move                     a(2)     a(4) 
	move                     a(1)     a(2) 
	move                     a(3)     a(1) 
	move                     a(4)     a(3) 
	jmp                      a / 3 

------ Test 216 -------
p(A, B, C, A) :-
	a(f(C), f(A), f(B)).

p / 4:
label(L0):
	get_value                a(4)     a(1) 
	move                     a(1)     a(4) 
	put_structure            a(1)     f / 1 
	push_local_value         a(3) 
	move                     a(2)     a(5) 
	put_structure            a(2)     f / 1 
	push_local_value         a(4) 
	put_structure            a(3)     f / 1 
	push_local_value         a(5) 
	jmp                      a / 3 

------ Test 217 -------
p(f(A)) :-
	q(A).

p / 1:
label(L0):
	get_structure            a(1)     f / 1     ref(L1) 
	write_variable           a(1) 
	branch                   ref(L2) 
label(L1):
	read_variable            a(1) 
label(L2):
	jmp                      q / 1 

------ Test 218 -------
p(A, B, C) :-
	a(B, C, A).

p / 3:
label(L0):
	move                     a(3)     a(4) 
	move                     a(1)     a(3) 
	move                     a(2)     a(1) 
	move                     a(4)     a(2) 
	jmp                      a / 3 

------ Test 219 -------
p(A, B, C) :-
	D = A,
	a(C, D, B).

p / 3:
label(L0):
	move                     a(3)     a(4) 
	move                     a(2)     a(3) 
	move                     a(1)     a(2) 
	move                     a(4)     a(1) 
	jmp                      a / 3 

------ Test 220 -------
p(A, B, C) :-
	D = A,
	a(B, C, D).

p / 3:
label(L0):
	move                     a(2)     a(4) 
	move                     a(3)     a(2) 
	move                     a(1)     a(3) 
	move                     a(4)     a(1) 
	jmp                      a / 3 

------ Test 221 -------
p :-
	a(A, f(A)).

p / 0:
label(L0):
	put_structure            a(2)     f / 1 
	push_variable            a(1) 
	jmp                      a / 2 

------ Test 222 -------
p :-
	q(a, A, B, A).

p / 0:
label(L0):
	put_variable             a(2) 
	put_variable             a(3) 
	put_atom                 a(1)     a 
	move                     a(2)     a(4) 
	jmp                      q / 4 

------ Test 223 -------
p :-
	q(A, A),
	r(A).

p / 0:
label(L0):
	allocate                 1 
	put_global_variable      a(1)     y(1) 
	move                     a(1)     a(2) 
	callf                    q / 2     Y[1] 
	move                     y(1)     a(1) 
	chain                    r / 1 

------ Test 224 -------
p :-
	q(f(A), A),
	r(A).

p / 0:
label(L0):
	allocate                 1 
	put_structure            a(1)     f / 1 
	push_variable            y(1) 
	move                     y(1)     a(2) 
	callf                    q / 2     Y[1] 
	move                     y(1)     a(1) 
	chain                    r / 1 

------ Test 225 -------
p :-
	q([a]),
	r(A).

p / 0:
label(L0):
	allocate                 0 
	put_list                 a(1) 
	write_atom               a 
	push_nil             
	callf                    q / 1     Y[] 
	put_variable             a(1) 
	chain                    r / 1 

------ Test 226 -------
p :-
	q([a, b]),
	r(A).

p / 0:
label(L0):
	allocate                 0 
	put_list                 a(1) 
	write_atom               a 
	push_list            
	write_atom               b 
	push_nil             
	callf                    q / 1     Y[] 
	put_variable             a(1) 
	chain                    r / 1 

------ Test 227 -------
p :-
	q([a, A, b]),
	r(A).

p / 0:
label(L0):
	allocate                 1 
	put_list                 a(1) 
	write_atom               a 
	push_list            
	push_variable            y(1) 
	push_list            
	write_atom               b 
	push_nil             
	callf                    q / 1     Y[1] 
	move                     y(1)     a(1) 
	chain                    r / 1 

------ Test 228 -------
p :-
	q([a, b|A]),
	r(A).

p / 0:
label(L0):
	allocate                 1 
	put_list                 a(1) 
	write_atom               a 
	push_list            
	write_atom               b 
	push_variable            y(1) 
	callf                    q / 1     Y[1] 
	move                     y(1)     a(1) 
	chain                    r / 1 

------ Test 229 -------
p :-
	q([A], A),
	r(A).

p / 0:
label(L0):
	allocate                 1 
	put_list                 a(1) 
	push_variable            y(1) 
	push_nil             
	move                     y(1)     a(2) 
	callf                    q / 2     Y[1] 
	move                     y(1)     a(1) 
	chain                    r / 1 

------ Test 230 -------
p :-
	q(A, [A]),
	r(A).

p / 0:
label(L0):
	allocate                 1 
	put_list                 a(2) 
	push_variable            y(1) 
	push_nil             
	move                     y(1)     a(1) 
	callf                    q / 2     Y[1] 
	move                     y(1)     a(1) 
	chain                    r / 1 

------ Test 231 -------
p :-
	q([A], A).

p / 0:
label(L0):
	put_list                 a(1) 
	push_variable            a(2) 
	push_nil             
	jmp                      q / 2 

------ Test 232 -------
p :-
	q(A, [A]).

p / 0:
label(L0):
	put_list                 a(2) 
	push_variable            a(1) 
	push_nil             
	jmp                      q / 2 

------ Test 233 -------
p(A) :-
	q([A], A).

p / 1:
label(L0):
	move                     a(1)     a(2) 
	put_list                 a(1) 
	push_local_value         a(2) 
	push_nil             
	jmp                      q / 2 

------ Test 234 -------
p(A) :-
	q(A, [A]).

p / 1:
label(L0):
	put_list                 a(2) 
	push_local_value         a(1) 
	push_nil             
	jmp                      q / 2 

------ Test 235 -------
p(A) :-
	q("hello", 3.4, 5_2).

p / 1:
label(L0):
	put_string               a(1)     "hello" 
	put_constant             a(2)     3.4 
	put_constant             a(3)     5_2 
	jmp                      q / 3 

------ Test 236 -------
p(A) :-
	q(f("hello", 3.4, 5_2)).

p / 1:
label(L0):
	put_structure            a(1)     f / 3 
	push_string              "hello" 
	push_constant            3.4 
	push_constant            5_2 
	jmp                      q / 1 

------ Test jdm(1) -------
p(A, B, a) :-
	q(A, b, f(B)).

p / 3:
label(L0):
	get_atom                 a(3)     a 
	put_structure            a(3)     f / 1 
	push_local_value         a(2) 
	put_atom                 a(2)     b 
	jmp                      q / 3 

------ Test jdm(2) -------
del(t(nil, A, B), A, B).
del(t(A, B, nil), B, A).
del(t(A, B, C), B, r(A, D, E)) :-
	delmin(C, D, E).

INDEXES for disjunction [2]
1. Quality 2.5
    [] - [1, 2]
    [structure] - [1, 2]
    [structure, r / 3] - [1, 2, 3]
    [var] - [1, 2, 3]
2. Quality 3.0
    [] - []
    [structure] - []
    [structure, t / 3] - [1, 2, 3]
    [var] - [1, 2, 3]
del / 3:
label(L0):
	allocate                 0 
label(L1):
	functor_switch           a(3) 
		r / 3: 	ref(L2)
		default: 	ref(L17)

label(L2):
	try_me_else              0     3     ref(L6) 
label(L3):
	get_structure            a(1)     t / 3     ref(L4) 
	write_atom               nil 
	write_local_value        a(2) 
	write_local_value        a(3) 
	branch                   ref(L5) 
label(L4):
	read_atom                nil 
	read_value               a(2) 
	read_value               a(3) 
label(L5):
	branch                   ref(L16) 
label(L6):
	retry_me_inline          0     ref(L10)     Y[] 
label(L7):
	get_structure            a(1)     t / 3     ref(L8) 
	write_local_value        a(3) 
	write_local_value        a(2) 
	write_atom               nil 
	branch                   ref(L9) 
label(L8):
	read_value               a(3) 
	read_value               a(2) 
	read_atom                nil 
label(L9):
	branch                   ref(L16) 
label(L10):
	trust_me_inline          0     Y[] 
label(L11):
	get_structure            a(1)     t / 3     ref(L12) 
	write_variable           a(4) 
	write_local_value        a(2) 
	write_variable           a(1) 
	branch                   ref(L13) 
label(L12):
	read_variable            a(4) 
	read_value               a(2) 
	read_variable            a(1) 
label(L13):
	get_structure            a(3)     r / 3     ref(L14) 
	write_local_value        a(4) 
	write_variable           a(2) 
	write_variable           a(3) 
	branch                   ref(L15) 
label(L14):
	read_value               a(4) 
	read_variable            a(2) 
	read_variable            a(3) 
label(L15):
	callf                    delmin / 3     Y[] 
label(L16):
	exit                 
label(L17):
	try                      0     3     ref(L3) 
	trust_inline             0     ref(L7)     Y[] 

------ Test jdm(3) -------
dob(person(A, B, C, D), C).

dob / 2:
label(L0):
	get_structure            a(1)     person / 4     ref(L1) 
	write_void               2 
	write_local_value        a(2) 
	write_void           
	branch                   ref(L2) 
label(L1):
	read_void                2 
	read_value               a(2) 
label(L2):
	ret                  

------ Test jdm(4) -------
qsort([A|B], C) :-
	split(A, B, D, E),
	qsort(D, F),
	qsort(E, G),
	append(F, G, C).

qsort / 2:
label(L0):
	allocate                 5 
	get_list                 a(1)     ref(L1) 
	write_variable           a(1) 
	move                     a(2)     a(5) 
	write_variable           a(2) 
	branch                   ref(L2) 
label(L1):
	read_variable            a(1) 
	move                     a(2)     a(5) 
	read_variable            a(2) 
label(L2):
	move                     a(5)     y(3) 
	put_global_variable      a(3)     y(5) 
	put_global_variable      a(4)     y(4) 
	callf                    split / 4     Y[3,4,5] 
	put_global_variable      a(2)     y(2) 
	move                     y(5)     a(1) 
	callf                    ref(L0)     Y[2,3,4] 
	put_global_variable      a(2)     y(1) 
	move                     y(4)     a(1) 
	callf                    ref(L0)     Y[1,2,3] 
	move3                    y(2)     a(1)     y(1)     a(2)     y(3)     a(3) 
	chain                    append / 3 

------ Test jdm(r4) -------
qsort(A, [B|C]) :-
	split(B, C, D, E),
	qsort(D, F),
	qsort(E, G),
	append(F, G, A).

qsort / 2:
label(L0):
	allocate                 5 
	get_list                 a(2)     ref(L1) 
	move                     a(1)     a(5) 
	write_variable           a(1) 
	write_variable           a(2) 
	branch                   ref(L2) 
label(L1):
	move                     a(1)     a(5) 
	read_variable            a(1) 
	read_variable            a(2) 
label(L2):
	move                     a(5)     y(3) 
	put_global_variable      a(3)     y(5) 
	put_global_variable      a(4)     y(4) 
	callf                    split / 4     Y[3,4,5] 
	put_global_variable      a(2)     y(2) 
	move                     y(5)     a(1) 
	callf                    ref(L0)     Y[2,3,4] 
	put_global_variable      a(2)     y(1) 
	move                     y(4)     a(1) 
	callf                    ref(L0)     Y[1,2,3] 
	move3                    y(2)     a(1)     y(1)     a(2)     y(3)     a(3) 
	chain                    append / 3 

------ Test jdm(5) -------
rev(A, B) :-
	revacc([], A, B).

rev / 2:
label(L0):
	move                     a(2)     a(3) 
	move                     a(1)     a(2) 
	put_nil                  a(1) 
	jmp                      revacc / 3 

------ Test jdm(6) -------
p(A, B, C, D) :-
	q(a, A, B, C, D).

p / 4:
label(L0):
	move                     a(4)     a(5) 
	move                     a(3)     a(4) 
	move                     a(2)     a(3) 
	move                     a(1)     a(2) 
	put_atom                 a(1)     a 
	jmp                      q / 5 

------ Test mjt(1) -------
p(f(A), g(A)) :-
	q(a, A).

p / 2:
label(L0):
	get_structure            a(1)     f / 1     ref(L1) 
	move                     a(2)     a(3) 
	write_variable           a(2) 
	branch                   ref(L2) 
label(L1):
	move                     a(2)     a(3) 
	read_variable            a(2) 
label(L2):
	get_structure            a(3)     g / 1     ref(L3) 
	write_local_value        a(2) 
	branch                   ref(L4) 
label(L3):
	read_value               a(2) 
label(L4):
	put_atom                 a(1)     a 
	jmp                      q / 2 

------ Test mjt(2) -------
p(b(A, B), B, C, a(A)) :-
	q(c, C, A, B).

p / 4:
label(L0):
	get_structure            a(1)     b / 2     ref(L1) 
	move                     a(4)     a(5) 
	move                     a(2)     a(4) 
	move                     a(3)     a(2) 
	write_variable           a(3) 
	write_local_value        a(4) 
	branch                   ref(L2) 
label(L1):
	move                     a(4)     a(5) 
	move                     a(2)     a(4) 
	move                     a(3)     a(2) 
	read_variable            a(3) 
	read_value               a(4) 
label(L2):
	get_structure            a(5)     a / 1     ref(L3) 
	write_local_value        a(3) 
	branch                   ref(L4) 
label(L3):
	read_value               a(3) 
label(L4):
	put_atom                 a(1)     c 
	jmp                      q / 4 

------ Test mjt(3) -------
p(g(A), s(B, h(A)), f(B)) :-
	var(B),
	var(A),
	q(a, A, B).

p / 3:
label(L0):
	get_structure            a(1)     g / 1     ref(L1) 
	move                     a(2)     a(4) 
	write_variable           a(2) 
	branch                   ref(L2) 
label(L1):
	move                     a(2)     a(4) 
	read_variable            a(2) 
label(L2):
	get_structure            a(4)     s / 2     ref(L4) 
	move                     a(3)     a(4) 
	write_variable           a(3) 
	write_structure          h / 1 
label(L3):
	write_local_value        a(2) 
	branch                   ref(L5) 
label(L4):
	move                     a(3)     a(4) 
	read_variable            a(3) 
	read_last_structure      h / 1     ref(L3) 
	read_value               a(2) 
label(L5):
	get_structure            a(4)     f / 1     ref(L6) 
	write_local_value        a(3) 
	branch                   ref(L7) 
label(L6):
	read_value               a(3) 
label(L7):
	bi_var                   a(3) 
	bi_var                   a(2) 
	put_atom                 a(1)     a 
	jmp                      q / 3 

------ Test 300 -------
p(A, B) :-
	p(A),
	+(A, B, C),
	-(A, D, C),
	q(C).

p / 2:
label(L0):
	allocate                 2 
	move                     2     a(1)     y(1) 
	callf                    p / 1     Y[1,2] 
	put_variable             a(1) 
	move                     2     y(1)     a(2) 
	bi_add                   a(2)     a(3)     a(1) 
	put_variable             a(3) 
	bi_sub                   a(2)     a(3)     a(1) 
	chain                    q / 1 

------ Test 301 -------
p(A, B) :-
	p(A),
	r(A, B, C),
	q(C).

p / 2:
label(L0):
	allocate                 3 
	move                     2     a(1)     y(2) 
	callf                    p / 1     Y[2,3] 
	put_global_variable      a(3)     y(1) 
	move                     2     y(2)     a(1) 
	callf                    r / 3     Y[1] 
	move                     y(1)     a(1) 
	chain                    q / 1 

------ Test 302 -------
p(A, B) :-
	p(B),
	r(A, B, C),
	q(C).

p / 2:
label(L0):
	allocate                 3 
	move                     2     a(1)     y(2) 
	move                     a(2)     a(1) 
	callf                    p / 1     Y[2,3] 
	put_global_variable      a(3)     y(1) 
	move                     2     y(2)     a(1) 
	callf                    r / 3     Y[1] 
	move                     y(1)     a(1) 
	chain                    q / 1 

------ Test 303 -------
p :-
	q,
	A = 1,
	B = 3,
	p(C),
	r(A, C, B).

p / 0:
label(L0):
	allocate                 3 
	callf                    q / 0     Y[] 
	put_integer              a(2)     1 
	move                     a(2)     y(1) 
	put_integer              a(3)     3 
	move                     a(3)     y(2) 
	put_global_variable      a(1)     y(3) 
	callf                    p / 1     Y[1,2,3] 
	move3                    y(1)     a(1)     y(3)     a(2)     y(2)     a(3) 
	chain                    r / 3 

------ Test 304 -------
p :-
	q,
	A = f(B),
	a(A, B).

p / 0:
label(L0):
	allocate                 0 
	callf                    q / 0     Y[] 
	put_structure            a(1)     f / 1 
	push_variable            a(2) 
	chain                    a / 2 

------ Test 305 -------
p(A, B) :-
	C = 1,
	A = B,
	q(B, C).

p / 2:
label(L0):
	move                     a(1)     a(3) 
	move                     a(2)     a(1) 
	put_integer              a(2)     1 
	get_value                a(3)     a(1) 
	jmp                      q / 2 

------ Test 306 -------
p1(A) :-
	A = 1.

p1 / 1:
label(L0):
	get_integer              a(1)     1 
	ret                  

------ Test 307 -------
p2(A) :-
	1 = A.

p2 / 1:
label(L0):
	get_integer              a(1)     1 
	ret                  

------ Test 308 -------
p3(A) :-
	A = 1,
	p1(A),
	p1(A).

p3 / 1:
label(L0):
	allocate                 1 
	get_integer              a(1)     1 
	move                     a(1)     y(1) 
	callf                    p1 / 1     Y[1] 
	move                     y(1)     a(1) 
	chain                    p1 / 1 

------ Test 309 -------
p4(A) :-
	1 = A,
	p1(A),
	p1(A).

p4 / 1:
label(L0):
	allocate                 1 
	get_integer              a(1)     1 
	move                     a(1)     y(1) 
	callf                    p1 / 1     Y[1] 
	move                     y(1)     a(1) 
	chain                    p1 / 1 

------ Test 310 -------
p5(f(A)) :-
	A = 1,
	p1(A),
	p1(A).

p5 / 1:
label(L0):
	allocate                 1 
	get_structure            a(1)     f / 1     ref(L1) 
	write_variable           y(1) 
	branch                   ref(L2) 
label(L1):
	read_variable            y(1) 
label(L2):
	move                     y(1)     a(1) 
	get_integer              a(1)     1 
	callf                    p1 / 1     Y[1] 
	move                     y(1)     a(1) 
	chain                    p1 / 1 

------ Test 311 -------
p5a(f(A)) :-
	p1(A),
	A = 1,
	p1(A).

p5a / 1:
label(L0):
	allocate                 1 
	get_structure            a(1)     f / 1     ref(L1) 
	write_variable           y(1) 
	branch                   ref(L2) 
label(L1):
	read_variable            y(1) 
label(L2):
	move                     y(1)     a(1) 
	callf                    p1 / 1     Y[1] 
	move                     y(1)     a(1) 
	get_integer              a(1)     1 
	chain                    p1 / 1 

------ Test 312 -------
p6(f(A)) :-
	1 = A,
	p1(A),
	p1(A).

p6 / 1:
label(L0):
	allocate                 1 
	get_structure            a(1)     f / 1     ref(L1) 
	write_variable           y(1) 
	branch                   ref(L2) 
label(L1):
	read_variable            y(1) 
label(L2):
	move                     y(1)     a(1) 
	get_integer              a(1)     1 
	callf                    p1 / 1     Y[1] 
	move                     y(1)     a(1) 
	chain                    p1 / 1 

------ Test 313 -------
p6a(f(A)) :-
	p1(A),
	1 = A,
	p1(A).

p6a / 1:
label(L0):
	allocate                 1 
	get_structure            a(1)     f / 1     ref(L1) 
	write_variable           y(1) 
	branch                   ref(L2) 
label(L1):
	read_variable            y(1) 
label(L2):
	move                     y(1)     a(1) 
	callf                    p1 / 1     Y[1] 
	move                     y(1)     a(1) 
	get_integer              a(1)     1 
	chain                    p1 / 1 

------ Test 314 -------
p7(f(A)) :-
	A = 1,
	p1(A).

p7 / 1:
label(L0):
	get_structure            a(1)     f / 1     ref(L1) 
	write_variable           a(1) 
	branch                   ref(L2) 
label(L1):
	read_variable            a(1) 
label(L2):
	get_integer              a(1)     1 
	jmp                      p1 / 1 

------ Test 315 -------
p8(f(A)) :-
	1 = A,
	p1(A).

p8 / 1:
label(L0):
	get_structure            a(1)     f / 1     ref(L1) 
	write_variable           a(1) 
	branch                   ref(L2) 
label(L1):
	read_variable            a(1) 
label(L2):
	get_integer              a(1)     1 
	jmp                      p1 / 1 

------ Test 316 -------
p9(A) :-
	B = 1,
	p1(B),
	p1(B),
	B = A.

p9 / 1:
label(L0):
	allocate                 2 
	move                     a(1)     a(2) 
	put_integer              a(1)     1 
	move                     2     a(1)     y(1) 
	callf                    p1 / 1     Y[1,2] 
	move                     y(1)     a(1) 
	callf                    p1 / 1     Y[1,2] 
	get_value                y(1)     y(2) 
	exit                 

------ Test 317 -------
p9a(A) :-
	p1(B),
	C = 1,
	p1(C),
	p1(C),
	C = A.

p9a / 1:
label(L0):
	allocate                 2 
	move                     a(1)     y(2) 
	put_variable             a(1) 
	callf                    p1 / 1     Y[2] 
	put_integer              a(1)     1 
	move                     a(1)     y(1) 
	callf                    p1 / 1     Y[1,2] 
	move                     y(1)     a(1) 
	callf                    p1 / 1     Y[1,2] 
	get_value                y(1)     y(2) 
	exit                 

------ Test 318 -------
p10(A) :-
	1 = B,
	p1(B),
	p1(B),
	B = A.

p10 / 1:
label(L0):
	allocate                 2 
	move                     a(1)     a(2) 
	put_integer              a(1)     1 
	move                     2     a(1)     y(1) 
	callf                    p1 / 1     Y[1,2] 
	move                     y(1)     a(1) 
	callf                    p1 / 1     Y[1,2] 
	get_value                y(1)     y(2) 
	exit                 

------ Test 319 -------
p10a(A) :-
	p1(B),
	1 = C,
	p1(C),
	C = A.

p10a / 1:
label(L0):
	allocate                 2 
	move                     a(1)     y(2) 
	put_variable             a(1) 
	callf                    p1 / 1     Y[2] 
	put_integer              a(1)     1 
	move                     a(1)     y(1) 
	callf                    p1 / 1     Y[1,2] 
	get_value                y(1)     y(2) 
	exit                 

------ Test 320 -------
p11(A) :-
	B = 1,
	call(true),
	B = A.

p11 / 1:
label(L0):
	allocate                 2 
	put_integer              a(2)     1 
	move2                    a(2)     y(1)     a(1)     y(2) 
	callf                    true / 0     Y[1,2] 
	get_value                y(1)     y(2) 
	exit                 

------ Test 321 -------
p12(A, B, C) :-
	D = 1,
	E = 2,
	F = 3,
	call(true),
	A = D,
	B = E,
	C = F.

p12 / 3:
label(L0):
	allocate                 6 
	put_integer              a(4)     1 
	move                     a(4)     y(1) 
	put_integer              a(5)     2 
	move                     a(5)     y(2) 
	put_integer              a(6)     3 
	move                     a(6)     y(3) 
	move                     3     a(1)     y(4) 
	callf                    true / 0     Y[1,2,3,4,5,6] 
	get_value                y(1)     y(4) 
	get_value                y(2)     y(5) 
	get_value                y(3)     y(6) 
	exit                 

------ Test 322 -------
p13(A, B) :-
	C = 1,
	D = 2,
	E = 3,
	current_op(F, G, H),
	A = C,
	B = D.

p13 / 2:
label(L0):
	allocate                 4 
	put_integer              a(5)     1 
	move                     a(5)     y(1) 
	put_integer              a(6)     2 
	move                     a(6)     y(2) 
	move                     2     a(1)     y(3) 
	put_variable             a(1) 
	put_variable             a(2) 
	put_variable             a(3) 
	put_atom                 a(4)     eclipse 
	callf                    sepia_kernel : current_op_body / 4     Y[1,2,3,4] 
	get_value                y(1)     y(3) 
	get_value                y(2)     y(4) 
	exit                 

------ Test 323 -------
b1 :-
	A = s(B),
	eq(B, C),
	A = s(1),
	C = 1.

b1 / 0:
label(L0):
	allocate                 2 
	put_structure            a(3)     s / 1 
	push_variable            a(1) 
	move                     a(3)     y(1) 
	put_global_variable      a(2)     y(2) 
	callf                    eq / 2     Y[1,2] 
	move                     y(1)     a(1) 
	get_structure            a(1)     s / 1     ref(L1) 
	write_integer            1 
	branch                   ref(L2) 
label(L1):
	read_integer             1 
label(L2):
	move                     y(2)     a(1) 
	get_integer              a(1)     1 
	exit                 

------ Test u(1) -------
p(foo(A, B, C)) :-
	q(B),
	r(C).

p / 1:
label(L0):
	allocate                 1 
	get_structure            a(1)     foo / 3     ref(L1) 
	write_void           
	write_variable           a(1) 
	write_variable           y(1) 
	branch                   ref(L2) 
label(L1):
	read_void            
	read_variable            a(1) 
	read_variable            y(1) 
label(L2):
	callf                    q / 1     Y[1] 
	move                     y(1)     a(1) 
	chain                    r / 1 

------ Test ana(1) -------
p :-
	q,
	A = 1,
	B = 3,
	p(A).

p / 0:
label(L0):
	allocate                 0 
	callf                    q / 0     Y[] 
	put_integer              a(1)     1 
	chain                    p / 1 

------ Test ana(2) -------
p :-
	A = 1,
	A = B.

p / 0:
label(L0):
	put_integer              a(1)     1 
	ret                  

------ Test ana(3) -------
p :-
	A = B.

p / 0:
label(L0):
	ret                  

------ Test ana(4) -------
p :-
	A = 3,
	B = A.

p / 0:
label(L0):
	put_integer              a(1)     3 
	ret                  

------ Test ana(5) -------
p :-
	A = 3,
	q,
	A = 4,
	r.

WARNING: unification of value(3) with value(4) will always fail
p / 0:
label(L0):
	allocate                 1 
	put_integer              a(1)     3 
	move                     a(1)     y(1) 
	callf                    q / 0     Y[1] 
	move                     y(1)     a(1) 
	get_integer              a(1)     4 
	chain                    r / 0 

------ Test ana(6) -------
p :-
	A = 3,
	q,
	B = A,
	r,
	B = 4.

WARNING: unification of value(3) with value(4) will always fail
p / 0:
label(L0):
	allocate                 2 
	put_integer              a(1)     3 
	move                     a(1)     y(2) 
	callf                    q / 0     Y[2] 
	move                     y(2)     y(1) 
	callf                    r / 0     Y[1] 
	move                     y(1)     a(1) 
	get_integer              a(1)     4 
	exit                 

------ Test ana(7) -------
p :-
	A = f(B, C),
	q,
	A = f(D, E),
	r.

p / 0:
label(L0):
	allocate                 1 
	put_structure            a(1)     f / 2 
	push_void                2 
	move                     a(1)     y(1) 
	callf                    q / 0     Y[1] 
	move                     y(1)     a(1) 
	get_structure            a(1)     f / 2     ref(L1) 
	write_void               2 
	branch                   ref(L2) 
label(L1):
label(L2):
	chain                    r / 0 

------ Test ana(8) -------
p :-
	integer(A),
	(
	    A = 1
	;
	    A = 2
	),
	q.

INDEXES for disjunction [2]
1. Quality 1.3
    [] - []
    [var] - [1, 2]
    [integer] - []
    [integer, 1] - [1]
    [integer, 2] - [2]
p / 0:
label(L0):
	allocate                 1 
	put_global_variable      a(1)     y(1) 
	bi_integer               a(1) 
label(L1):
	integer_switch           y(1) 
		1: 	ref(L3)
		2: 	ref(L5)
		default: 	ref(fail)

label(L2):
	try_me_else              0     0     ref(L4) 
label(L3):
	move                     y(1)     a(1) 
	get_integer              a(1)     1 
	branch                   ref(L6) 
label(L4):
	trust_me_inline          0     Y[1] 
label(L5):
	move                     y(1)     a(1) 
	get_integer              a(1)     2 
label(L6):
	chain                    q / 0 

------ Test ana(9) -------
p(A, B) :-
	f(a, B) = f(A, b),
	q.

p / 2:
label(L0):
	get_atom                 a(1)     a 
	get_atom                 a(2)     b 
	jmp                      q / 0 

------ Test idx(1) -------
p :-
	p(A),
	(
	    A = 1,
	    p1
	;
	    A = 2,
	    p2
	).

INDEXES for disjunction [3]
1. Quality 1.3
    [] - []
    [var] - [1, 2]
    [integer] - []
    [integer, 1] - [1]
    [integer, 2] - [2]
p / 0:
label(L0):
	allocate                 1 
	put_global_variable      a(1)     y(1) 
	callf                    p / 1     Y[1] 
label(L1):
	integer_switch           y(1) 
		1: 	ref(L3)
		2: 	ref(L5)
		default: 	ref(fail)

label(L2):
	try_me_else              0     0     ref(L4) 
label(L3):
	move                     y(1)     a(1) 
	get_integer              a(1)     1 
	callf                    p1 / 0     Y[] 
	branch                   ref(L6) 
label(L4):
	trust_me_inline          0     Y[1] 
label(L5):
	move                     y(1)     a(1) 
	get_integer              a(1)     2 
	callf                    p2 / 0     Y[] 
label(L6):
	exit                 

------ Test idx(2) -------
p :-
	p(A, B),
	(
	    B = a,
	    A = 1,
	    p1
	;
	    A = 2,
	    B = b,
	    p2
	).

INDEXES for disjunction [3]
1. Quality 1.3
    [] - []
    [var] - [1, 2]
    [integer] - []
    [integer, 1] - [1]
    [integer, 2] - [2]
2. Quality 1.3
    [] - []
    [atom] - []
    [atom, a] - [1]
    [atom, b] - [2]
    [var] - [1, 2]
p / 0:
label(L0):
	allocate                 2 
	put_global_variable      a(1)     y(1) 
	put_global_variable      a(2)     y(2) 
	callf                    p / 2     Y[1,2] 
label(L1):
	integer_switch           y(1) 
		1: 	ref(L5)
		2: 	ref(L7)
		default: 	ref(fail)

label(L2):
label(L3):
	atom_switch              y(2) 
		a: 	ref(L5)
		b: 	ref(L7)
		default: 	ref(fail)

label(L4):
	try_me_else              0     0     ref(L6) 
label(L5):
	move                     y(2)     a(1) 
	get_atom                 a(1)     a 
	move                     y(1)     a(1) 
	get_integer              a(1)     1 
	callf                    p1 / 0     Y[] 
	branch                   ref(L8) 
label(L6):
	trust_me_inline          0     Y[1,2] 
label(L7):
	move                     y(1)     a(1) 
	get_integer              a(1)     2 
	move                     y(2)     a(1) 
	get_atom                 a(1)     b 
	callf                    p2 / 0     Y[] 
label(L8):
	exit                 

------ Test idx(3) -------
p(A, B) :-
	(
	    B = a,
	    A = 1,
	    p1
	;
	    (
		A = 2,
		B = b,
		p2
	    ;
		B = c,
		p3
	    )
	).

INDEXES for disjunction [2]
1. Quality 1.5
    [] - []
    [atom] - []
    [atom, a] - [1]
    [atom, b] - [2]
    [atom, c] - [3]
    [var] - [1, 2, 3]
2. Quality 2.0
    [] - [3]
    [var] - [1, 2, 3]
    [integer] - [3]
    [integer, 1] - [1, 3]
    [integer, 2] - [2, 3]
p / 2:
label(L0):
	allocate                 2 
	move                     2     a(1)     y(1) 
label(L1):
	atom_switch              y(2) 
		a: 	ref(L5)
		b: 	ref(L7)
		c: 	ref(L9)
		default: 	ref(fail)

label(L2):
label(L3):
	integer_switch           y(1) 
		1: 	ref(L11)
		2: 	ref(L12)
		default: 	ref(L9)

label(L4):
	try_me_else              0     0     ref(L6) 
label(L5):
	move                     y(2)     a(1) 
	get_atom                 a(1)     a 
	move                     y(1)     a(1) 
	get_integer              a(1)     1 
	callf                    p1 / 0     Y[] 
	branch                   ref(L10) 
label(L6):
	retry_me_inline          0     ref(L8)     Y[1,2] 
label(L7):
	move                     y(1)     a(1) 
	get_integer              a(1)     2 
	move                     y(2)     a(1) 
	get_atom                 a(1)     b 
	callf                    p2 / 0     Y[] 
	branch                   ref(L10) 
label(L8):
	trust_me_inline          0     Y[2] 
label(L9):
	move                     y(2)     a(1) 
	get_atom                 a(1)     c 
	callf                    p3 / 0     Y[] 
label(L10):
	exit                 
label(L11):
	try                      0     0     ref(L5) 
	trust_inline             0     ref(L9)     Y[2] 
label(L12):
	try                      0     0     ref(L7) 
	trust_inline             0     ref(L9)     Y[2] 

------ Test idx(4) -------
p(A, B) :-
	(
	    B = a,
	    A = 1,
	    p1
	;
	    (
		integer(A),
		B = b,
		p2
	    ;
		number(A),
		p3
	    )
	).

INDEXES for disjunction [2]
1. Quality 1.8
    [] - []
    [var] - [1]
    [rational] - [3]
    [breal] - [3]
    [bignum] - [2, 3]
    [integer] - [2, 3]
    [integer, 1] - [1, 2, 3]
    [double] - [3]
2. Quality 2.0
    [] - [3]
    [atom] - [3]
    [atom, a] - [1, 3]
    [atom, b] - [2, 3]
    [var] - [1, 2, 3]
p / 2:
label(L0):
	allocate                 2 
	move                     2     a(1)     y(1) 
	switch_on_type           y(1) 
		meta: 	ref(L4)
		[]: 	ref(fail)
		atom: 	ref(fail)
		bignum: 	ref(L10)
		breal: 	ref(L8)
		double: 	ref(L8)
		goal: 	ref(fail)
		handle: 	ref(fail)
		integer: 	ref(L11)
		list: 	ref(fail)
		rational: 	ref(L8)
		string: 	ref(fail)
		structure: 	ref(fail)

	branch                   ref(L4) 
label(L1):
label(L2):
	atom_switch              y(2) 
		a: 	ref(L12)
		b: 	ref(L10)
		default: 	ref(L8)

label(L3):
	try_me_else              0     0     ref(L5) 
label(L4):
	move                     y(2)     a(1) 
	get_atom                 a(1)     a 
	move                     y(1)     a(1) 
	get_integer              a(1)     1 
	callf                    p1 / 0     Y[] 
	branch                   ref(L9) 
label(L5):
	retry_me_inline          0     ref(L7)     Y[1,2] 
label(L6):
	move                     y(1)     a(1) 
	bi_integer               a(1) 
	move                     y(2)     a(1) 
	get_atom                 a(1)     b 
	callf                    p2 / 0     Y[] 
	branch                   ref(L9) 
label(L7):
	trust_me_inline          0     Y[1] 
label(L8):
	move                     y(1)     a(1) 
	bi_number                a(1) 
	callf                    p3 / 0     Y[] 
label(L9):
	exit                 
label(L10):
	try                      0     0     ref(L6) 
	trust_inline             0     ref(L8)     Y[1] 
label(L11):
	integer_switch           y(1) 
		1: 	ref(L1)
		default: 	ref(L10)

label(L12):
	try                      0     0     ref(L4) 
	trust_inline             0     ref(L8)     Y[1] 

------ Test idx(5) -------
p(A) :-
	(
	    A = 1,
	    p1
	;
	    (
		A = 2,
		p2
	    ;
		(
		    integer(A),
		    p3
		;
		    number(A),
		    p4
		)
	    )
	).

INDEXES for disjunction [2]
1. Quality 2.2
    [] - []
    [var] - [1, 2]
    [rational] - [4]
    [breal] - [4]
    [bignum] - [3, 4]
    [integer] - [3, 4]
    [integer, 1] - [1, 3, 4]
    [integer, 2] - [2, 3, 4]
    [double] - [4]
p / 1:
label(L0):
	allocate                 1 
	move                     a(1)     y(1) 
	switch_on_type           y(1) 
		meta: 	ref(L13)
		[]: 	ref(fail)
		atom: 	ref(fail)
		bignum: 	ref(L10)
		breal: 	ref(L8)
		double: 	ref(L8)
		goal: 	ref(fail)
		handle: 	ref(fail)
		integer: 	ref(L14)
		list: 	ref(fail)
		rational: 	ref(L8)
		string: 	ref(fail)
		structure: 	ref(fail)

	branch                   ref(L13) 
label(L1):
	try_me_else              0     0     ref(L3) 
label(L2):
	move                     y(1)     a(1) 
	get_integer              a(1)     1 
	callf                    p1 / 0     Y[] 
	branch                   ref(L9) 
label(L3):
	retry_me_inline          0     ref(L5)     Y[1] 
label(L4):
	move                     y(1)     a(1) 
	get_integer              a(1)     2 
	callf                    p2 / 0     Y[] 
	branch                   ref(L9) 
label(L5):
	retry_me_inline          0     ref(L7)     Y[1] 
label(L6):
	move                     y(1)     a(1) 
	bi_integer               a(1) 
	callf                    p3 / 0     Y[] 
	branch                   ref(L9) 
label(L7):
	trust_me_inline          0     Y[1] 
label(L8):
	move                     y(1)     a(1) 
	bi_number                a(1) 
	callf                    p4 / 0     Y[] 
label(L9):
	exit                 
label(L10):
	try                      0     0     ref(L6) 
	trust_inline             0     ref(L8)     Y[1] 
label(L11):
	try                      0     0     ref(L2) 
	retry_inline             0     ref(L6)     Y[1] 
	trust_inline             0     ref(L8)     Y[1] 
label(L12):
	try                      0     0     ref(L4) 
	retry_inline             0     ref(L6)     Y[1] 
	trust_inline             0     ref(L8)     Y[1] 
label(L13):
	try                      0     0     ref(L2) 
	trust_inline             0     ref(L4)     Y[1] 
label(L14):
	integer_switch           y(1) 
		1: 	ref(L11)
		2: 	ref(L12)
		default: 	ref(L10)


------ Test idx(6) -------
p :-
	p(A, B),
	(
	    B == a,
	    A = 1,
	    p1
	;
	    A = 2,
	    B == b,
	    p2
	).

INDEXES for disjunction [3]
1. Quality 0.7
    [] - []
    [atom] - []
    [atom, a] - [1]
    [atom, b] - [2]
2. Quality 1.3
    [] - []
    [var] - [1, 2]
    [integer] - []
    [integer, 1] - [1]
    [integer, 2] - [2]
p / 0:
label(L0):
	allocate                 2 
	put_global_variable      a(1)     y(1) 
	put_global_variable      a(2)     y(2) 
	callf                    p / 2     Y[1,2] 
label(L1):
	atom_switch              y(2) 
		a: 	ref(L5)
		b: 	ref(L7)
		default: 	ref(fail)

	branch                   ref(fail) 
label(L2):
label(L3):
	integer_switch           y(1) 
		1: 	ref(L5)
		2: 	ref(L7)
		default: 	ref(fail)

label(L4):
	try_me_else              0     0     ref(L6) 
label(L5):
	move                     y(2)     a(1) 
	in_get_atom              a(1)     a 
	move                     y(1)     a(1) 
	get_integer              a(1)     1 
	callf                    p1 / 0     Y[] 
	branch                   ref(L8) 
label(L6):
	trust_me_inline          0     Y[1,2] 
label(L7):
	move                     y(1)     a(1) 
	get_integer              a(1)     2 
	move                     y(2)     a(1) 
	in_get_atom              a(1)     b 
	callf                    p2 / 0     Y[] 
label(L8):
	exit                 

------ Test idx(7) -------
p(A) :-
	(
	    A = [],
	    p1
	;
	    A = [B|C],
	    p2
	).

INDEXES for disjunction [2]
1. Quality 1.3
    [] - []
    [list] - [2]
    [[]] - [1]
    [var] - [1, 2]
p / 1:
label(L0):
	allocate                 1 
	move                     a(1)     y(1) 
	list_switch              y(1)     ref(L4)     ref(L2)     ref(fail) 
label(L1):
	try_me_else              0     0     ref(L3) 
label(L2):
	move                     y(1)     a(1) 
	get_nil                  a(1) 
	callf                    p1 / 0     Y[] 
	branch                   ref(L7) 
label(L3):
	trust_me_inline          0     Y[1] 
label(L4):
	move                     y(1)     a(1) 
	get_list                 a(1)     ref(L5) 
	write_void               2 
	branch                   ref(L6) 
label(L5):
label(L6):
	callf                    p2 / 0     Y[] 
label(L7):
	exit                 

------ Test idx(8) -------
p(A) :-
	(
	    var(A),
	    !,
	    p
	;
	    q
	).

INDEXES for disjunction [2]
1. Quality 1.0
    [] - [2]
    [var] - [1]
p / 1:
label(L0):
	allocate                 2 
	savecut                  y(2) 
	move                     a(1)     y(1) 
	switch_on_type           y(1) 
		meta: 	ref(L2)
		[]: 	ref(L4)
		atom: 	ref(L4)
		bignum: 	ref(L4)
		breal: 	ref(L4)
		double: 	ref(L4)
		goal: 	ref(L4)
		handle: 	ref(L4)
		integer: 	ref(L4)
		list: 	ref(L4)
		rational: 	ref(L4)
		string: 	ref(L4)
		structure: 	ref(L4)

	branch                   ref(L2) 
label(L1):
	try_me_else              0     0     ref(L3) 
label(L2):
	move                     y(1)     a(1) 
	bi_var                   a(1) 
	cut                      y(2)     2 
	callf                    p / 0     Y[] 
	branch                   ref(L5) 
label(L3):
	trust_me_inline          0     Y[] 
label(L4):
	callf                    q / 0     Y[] 
label(L5):
	exit                 

------ Test idx(9) -------
p(A) :-
	(
	    A = 3.1,
	    p
	;
	    A = 9.9,
	    q
	).

INDEXES for disjunction [2]
1. Quality 2.0
    [] - []
    [var] - [1, 2]
    [double] - [1, 2]
p / 1:
label(L0):
	allocate                 1 
	move                     a(1)     y(1) 
	try_me_else              0     0     ref(L2) 
label(L1):
	move                     y(1)     a(1) 
	get_constant             a(1)     3.1 
	callf                    p / 0     Y[] 
	branch                   ref(L4) 
label(L2):
	trust_me_inline          0     Y[1] 
label(L3):
	move                     y(1)     a(1) 
	get_constant             a(1)     9.9 
	callf                    q / 0     Y[] 
label(L4):
	exit                 

------ Test idx(10) -------
p(A) :-
	(
	    A = "foo",
	    p
	;
	    (
		A = "bar",
		q
	    ;
		r
	    )
	).

INDEXES for disjunction [2]
1. Quality 2.0
    [] - [3]
    [var] - [1, 2, 3]
    [string] - [1, 2, 3]
p / 1:
label(L0):
	allocate                 1 
	move                     a(1)     y(1) 
	switch_on_type           y(1) 
		meta: 	ref(L1)
		[]: 	ref(L6)
		atom: 	ref(L6)
		bignum: 	ref(L6)
		breal: 	ref(L6)
		double: 	ref(L6)
		goal: 	ref(L6)
		handle: 	ref(L6)
		integer: 	ref(L6)
		list: 	ref(L6)
		rational: 	ref(L6)
		string: 	ref(L1)
		structure: 	ref(L6)

label(L1):
	try_me_else              0     0     ref(L3) 
label(L2):
	move                     y(1)     a(1) 
	get_string               a(1)     "foo" 
	callf                    p / 0     Y[] 
	branch                   ref(L7) 
label(L3):
	retry_me_inline          0     ref(L5)     Y[1] 
label(L4):
	move                     y(1)     a(1) 
	get_string               a(1)     "bar" 
	callf                    q / 0     Y[] 
	branch                   ref(L7) 
label(L5):
	trust_me_inline          0     Y[] 
label(L6):
	callf                    r / 0     Y[] 
label(L7):
	exit                 

------ Test idx(11) -------
p(A) :-
	(
	    A = f(1),
	    p
	;
	    (
		A = g(1, 2),
		q
	    ;
		r
	    )
	).

INDEXES for disjunction [2]
1. Quality 2.0
    [] - [3]
    [structure] - [3]
    [structure, g / 2] - [2, 3]
    [structure, f / 1] - [1, 3]
    [var] - [1, 2, 3]
p / 1:
label(L0):
	allocate                 1 
	move                     a(1)     y(1) 
label(L1):
	functor_switch           y(1) 
		g / 2: 	ref(L13)
		f / 1: 	ref(L14)
		default: 	ref(L11)

label(L2):
	try_me_else              0     0     ref(L6) 
label(L3):
	move                     y(1)     a(1) 
	get_structure            a(1)     f / 1     ref(L4) 
	write_integer            1 
	branch                   ref(L5) 
label(L4):
	read_integer             1 
label(L5):
	callf                    p / 0     Y[] 
	branch                   ref(L12) 
label(L6):
	retry_me_inline          0     ref(L10)     Y[1] 
label(L7):
	move                     y(1)     a(1) 
	get_structure            a(1)     g / 2     ref(L8) 
	write_integer            1 
	write_integer            2 
	branch                   ref(L9) 
label(L8):
	read_integer             1 
	read_integer             2 
label(L9):
	callf                    q / 0     Y[] 
	branch                   ref(L12) 
label(L10):
	trust_me_inline          0     Y[] 
label(L11):
	callf                    r / 0     Y[] 
label(L12):
	exit                 
label(L13):
	try                      0     0     ref(L7) 
	trust_inline             0     ref(L11)     Y[] 
label(L14):
	try                      0     0     ref(L3) 
	trust_inline             0     ref(L11)     Y[] 

------ Test idx(12) -------
p(A) :-
	(
	    A = [],
	    p
	;
	    r
	).

INDEXES for disjunction [2]
1. Quality 1.5
    [] - [2]
    [[]] - [1, 2]
    [var] - [1, 2]
p / 1:
label(L0):
	allocate                 1 
	move                     a(1)     y(1) 
	list_switch              y(1)     ref(L4)     ref(L1)     ref(L4) 
label(L1):
	try_me_else              0     0     ref(L3) 
label(L2):
	move                     y(1)     a(1) 
	get_nil                  a(1) 
	callf                    p / 0     Y[] 
	branch                   ref(L5) 
label(L3):
	trust_me_inline          0     Y[] 
label(L4):
	callf                    r / 0     Y[] 
label(L5):
	exit                 

------ Test idx(13) -------
p(A) :-
	(
	    A = []
	->
	    p
	;
	    r
	).

INDEXES for disjunction [2]
1. Quality 1.0
    [] - [2]
    [[]] - [1]
    [var] - [1]
p / 1:
label(L0):
	allocate                 2 
	savecut                  y(2) 
	move                     a(1)     y(1) 
	list_switch              y(1)     ref(L4)     ref(L2)     ref(L4) 
	branch                   ref(L2) 
label(L1):
	try_me_else              0     0     ref(L3) 
label(L2):
	move                     y(1)     a(1) 
	get_nil                  a(1) 
	cut                      y(2)     2 
	callf                    p / 0     Y[] 
	branch                   ref(L5) 
label(L3):
	trust_me_inline          0     Y[] 
label(L4):
	callf                    r / 0     Y[] 
label(L5):
	exit                 

------ Test idx(14) -------
p :-
	p(A, B),
	(
	    a == B,
	    1 = A,
	    p1
	;
	    2 = A,
	    b == B,
	    p2
	).

INDEXES for disjunction [3]
1. Quality 0.7
    [] - []
    [atom] - []
    [atom, a] - [1]
    [atom, b] - [2]
2. Quality 1.3
    [] - []
    [var] - [1, 2]
    [integer] - []
    [integer, 1] - [1]
    [integer, 2] - [2]
p / 0:
label(L0):
	allocate                 2 
	put_global_variable      a(1)     y(1) 
	put_global_variable      a(2)     y(2) 
	callf                    p / 2     Y[1,2] 
label(L1):
	atom_switch              y(2) 
		a: 	ref(L5)
		b: 	ref(L7)
		default: 	ref(fail)

	branch                   ref(fail) 
label(L2):
label(L3):
	integer_switch           y(1) 
		1: 	ref(L5)
		2: 	ref(L7)
		default: 	ref(fail)

label(L4):
	try_me_else              0     0     ref(L6) 
label(L5):
	move                     y(2)     a(1) 
	in_get_atom              a(1)     a 
	move                     y(1)     a(1) 
	get_integer              a(1)     1 
	callf                    p1 / 0     Y[] 
	branch                   ref(L8) 
label(L6):
	trust_me_inline          0     Y[1,2] 
label(L7):
	move                     y(1)     a(1) 
	get_integer              a(1)     2 
	move                     y(2)     a(1) 
	in_get_atom              a(1)     b 
	callf                    p2 / 0     Y[] 
label(L8):
	exit                 

------ Test idx(15) -------
p :-
	p(A, B),
	(
	    a == B,
	    1 = A,
	    p1
	;
	    (
		2 = A,
		b == B,
		p2
	    ;
		A == B,
		p3
	    )
	).

INDEXES for disjunction [3]
1. Quality 1.2
    [] - [3]
    [atom] - [3]
    [atom, a] - [1, 3]
    [atom, b] - [2, 3]
2. Quality 2.0
    [] - [3]
    [var] - [1, 2, 3]
    [integer] - [3]
    [integer, 1] - [1, 3]
    [integer, 2] - [2, 3]
p / 0:
label(L0):
	allocate                 2 
	put_global_variable      a(1)     y(1) 
	put_global_variable      a(2)     y(2) 
	callf                    p / 2     Y[1,2] 
label(L1):
	atom_switch              y(2) 
		a: 	ref(L11)
		b: 	ref(L12)
		default: 	ref(L9)

	branch                   ref(L9) 
label(L2):
label(L3):
	integer_switch           y(1) 
		1: 	ref(L11)
		2: 	ref(L12)
		default: 	ref(L9)

label(L4):
	try_me_else              0     0     ref(L6) 
label(L5):
	move                     y(2)     a(1) 
	in_get_atom              a(1)     a 
	move                     y(1)     a(1) 
	get_integer              a(1)     1 
	callf                    p1 / 0     Y[] 
	branch                   ref(L10) 
label(L6):
	retry_me_inline          0     ref(L8)     Y[1,2] 
label(L7):
	move                     y(1)     a(1) 
	get_integer              a(1)     2 
	move                     y(2)     a(1) 
	in_get_atom              a(1)     b 
	callf                    p2 / 0     Y[] 
	branch                   ref(L10) 
label(L8):
	trust_me_inline          0     Y[1,2] 
label(L9):
	move                     2     y(1)     a(1) 
	get_matched_value        a(1)     a(2) 
	callf                    p3 / 0     Y[] 
label(L10):
	exit                 
label(L11):
	try                      0     0     ref(L5) 
	trust_inline             0     ref(L9)     Y[1,2] 
label(L12):
	try                      0     0     ref(L7) 
	trust_inline             0     ref(L9)     Y[1,2] 

------ Test idx(16) -------
p(A) :-
	(
	    var(B),
	    !,
	    p
	;
	    q
	).

p / 1:
label(L0):
	allocate                 1 
	savecut                  y(1) 
	try_me_else              0     0     ref(L2) 
label(L1):
	put_variable             a(1) 
	bi_var                   a(1) 
	cut                      y(1)     1 
	callf                    p / 0     Y[] 
	branch                   ref(L4) 
label(L2):
	trust_me_inline          0     Y[] 
label(L3):
	callf                    q / 0     Y[] 
label(L4):
	exit                 

------ Test idx(20) -------
p(A) :-
	(
	    A == [],
	    p
	;
	    A == [a],
	    q
	).

INDEXES for disjunction [2]
1. Quality 0.7
    [] - []
    [list] - [2]
    [[]] - [1]
p / 1:
label(L0):
	allocate                 1 
	move                     a(1)     y(1) 
	list_switch              y(1)     ref(L4)     ref(L2)     ref(fail) 
	branch                   ref(fail) 
label(L1):
	try_me_else              0     0     ref(L3) 
label(L2):
	move                     y(1)     a(1) 
	in_get_nil               a(1) 
	callf                    p / 0     Y[] 
	branch                   ref(L5) 
label(L3):
	trust_me_inline          0     Y[1] 
label(L4):
	put_list                 a(1) 
	write_atom               a 
	push_nil             
	move                     y(1)     a(2) 
	get_matched_value        a(2)     a(1) 
	callf                    q / 0     Y[] 
label(L5):
	exit                 

------ Test idx(21) -------
p(A) :-
	(
	    A == f(a),
	    r
	;
	    A == "hello",
	    s
	).

INDEXES for disjunction [2]
1. Quality 0.7
    [] - []
    [structure] - []
    [structure, f / 1] - [1]
    [string] - [2]
p / 1:
label(L0):
	allocate                 1 
	move                     a(1)     y(1) 
	switch_on_type           y(1) 
		meta: 	ref(fail)
		[]: 	ref(fail)
		atom: 	ref(fail)
		bignum: 	ref(fail)
		breal: 	ref(fail)
		double: 	ref(fail)
		goal: 	ref(fail)
		handle: 	ref(fail)
		integer: 	ref(fail)
		list: 	ref(fail)
		rational: 	ref(fail)
		string: 	ref(L4)
		structure: 	ref(L2)

	branch                   ref(fail) 
label(L1):
	try_me_else              0     0     ref(L3) 
label(L2):
	put_structure            a(1)     f / 1 
	write_atom               a 
	move                     y(1)     a(2) 
	get_matched_value        a(2)     a(1) 
	callf                    r / 0     Y[] 
	branch                   ref(L5) 
label(L3):
	trust_me_inline          0     Y[1] 
label(L4):
	move                     y(1)     a(1) 
	in_get_string            a(1)     "hello" 
	callf                    s / 0     Y[] 
label(L5):
	exit                 

------ Test idx(22) -------
p(A) :-
	(
	    A == [],
	    p
	;
	    (
		A == [a],
		q
	    ;
		A == f(a),
		r
	    )
	).

INDEXES for disjunction [2]
1. Quality 0.8
    [] - []
    [list] - [2]
    [[]] - [1]
    [structure] - []
    [structure, f / 1] - [3]
p / 1:
label(L0):
	allocate                 1 
	move                     a(1)     y(1) 
	switch_on_type           y(1) 
		meta: 	ref(fail)
		[]: 	ref(L2)
		atom: 	ref(fail)
		bignum: 	ref(fail)
		breal: 	ref(fail)
		double: 	ref(fail)
		goal: 	ref(fail)
		handle: 	ref(fail)
		integer: 	ref(fail)
		list: 	ref(L4)
		rational: 	ref(fail)
		string: 	ref(fail)
		structure: 	ref(L6)

	branch                   ref(fail) 
label(L1):
	try_me_else              0     0     ref(L3) 
label(L2):
	move                     y(1)     a(1) 
	in_get_nil               a(1) 
	callf                    p / 0     Y[] 
	branch                   ref(L7) 
label(L3):
	retry_me_inline          0     ref(L5)     Y[1] 
label(L4):
	put_list                 a(1) 
	write_atom               a 
	push_nil             
	move                     y(1)     a(2) 
	get_matched_value        a(2)     a(1) 
	callf                    q / 0     Y[] 
	branch                   ref(L7) 
label(L5):
	trust_me_inline          0     Y[1] 
label(L6):
	put_structure            a(1)     f / 1 
	write_atom               a 
	move                     y(1)     a(2) 
	get_matched_value        a(2)     a(1) 
	callf                    r / 0     Y[] 
label(L7):
	exit                 

------ Test idx(23) -------
p :-
	(
	    A == [],
	    p
	;
	    q
	).

p / 0:
label(L0):
	allocate                 0 
	try_me_else              0     0     ref(L2) 
label(L1):
	put_variable             a(1) 
	in_get_nil               a(1) 
	callf                    ref(L0)     Y[] 
	branch                   ref(L4) 
label(L2):
	trust_me_inline          0     Y[] 
label(L3):
	callf                    q / 0     Y[] 
label(L4):
	exit                 

------ Test idx(24) -------
p(A) :-
	(
	    A = f(B),
	    !,
	    p1
	;
	    (
		A = [C|D],
		!,
		p2
	    ;
		compound(A),
		p2
	    )
	).

INDEXES for disjunction [2]
1. Quality 1.0
    [] - []
    [list] - [2]
    [structure] - [3]
    [structure, f / 1] - [1]
    [var] - [1]
p / 1:
label(L0):
	allocate                 2 
	savecut                  y(2) 
	move                     a(1)     y(1) 
	switch_on_type           y(1) 
		meta: 	ref(L2)
		[]: 	ref(fail)
		atom: 	ref(fail)
		bignum: 	ref(fail)
		breal: 	ref(fail)
		double: 	ref(fail)
		goal: 	ref(fail)
		handle: 	ref(fail)
		integer: 	ref(fail)
		list: 	ref(L6)
		rational: 	ref(fail)
		string: 	ref(fail)
		structure: 	ref(L12)

	branch                   ref(L2) 
label(L1):
	try_me_else              0     0     ref(L5) 
label(L2):
	move                     y(1)     a(1) 
	get_structure            a(1)     f / 1     ref(L3) 
	write_void           
	branch                   ref(L4) 
label(L3):
label(L4):
	cut                      y(2)     2 
	callf                    p1 / 0     Y[] 
	branch                   ref(L11) 
label(L5):
	retry_me_inline          0     ref(L9)     Y[1,2] 
label(L6):
	move                     y(1)     a(1) 
	get_list                 a(1)     ref(L7) 
	write_void               2 
	branch                   ref(L8) 
label(L7):
label(L8):
	cut                      y(2)     2 
	callf                    p2 / 0     Y[] 
	branch                   ref(L11) 
label(L9):
	trust_me_inline          0     Y[1] 
label(L10):
	move                     y(1)     a(1) 
	bi_compound              a(1) 
	callf                    p2 / 0     Y[] 
label(L11):
	exit                 
label(L12):
	functor_switch           y(1) 
		f / 1: 	ref(L2)
		default: 	ref(L10)


------ Test idx(25) -------
p(A) :-
	(
	    A = 1,
	    p_integer
	;
	    (
		A = 10000000000000000000,
		p_big
	    ;
		(
		    A = 1.1,
		    p_float
		;
		    (
			A = 5_2,
			p_rational
		    ;
			(
			    A = 0.9__1.1,
			    p_breal
			;
			    (
				A = "hello",
				p_string
			    ;
				(
				    A = hello,
				    p_atom
				;
				    (
					A = [],
					p_nil
				    ;
					(
					    A = [B|C],
					    p_list
					;
					    A = foo(bar),
					    p_struct
					)
				    )
				)
			    )
			)
		    )
		)
	    )
	).

INDEXES for disjunction [2]
1. Quality 1.8
    [] - []
    [list] - [9]
    [[]] - [8]
    [structure] - []
    [structure, foo / 1] - [10]
    [atom] - []
    [atom, hello] - [7]
    [var] - [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    [breal] - [5]
    [rational] - [4]
    [bignum] - [2]
    [integer] - []
    [integer, 1] - [1]
    [string] - [6]
    [double] - [3]
p / 1:
label(L0):
	allocate                 1 
	move                     a(1)     y(1) 
	switch_on_type           y(1) 
		meta: 	ref(L1)
		[]: 	ref(L16)
		atom: 	ref(L14)
		bignum: 	ref(L4)
		breal: 	ref(L10)
		double: 	ref(L6)
		goal: 	ref(fail)
		handle: 	ref(fail)
		integer: 	ref(L2)
		list: 	ref(L18)
		rational: 	ref(L8)
		string: 	ref(L12)
		structure: 	ref(L22)

label(L1):
	try_me_else              0     0     ref(L3) 
label(L2):
	move                     y(1)     a(1) 
	get_integer              a(1)     1 
	callf                    p_integer / 0     Y[] 
	branch                   ref(L25) 
label(L3):
	retry_me_inline          0     ref(L5)     Y[1] 
label(L4):
	move                     y(1)     a(1) 
	get_constant             a(1)     10000000000000000000 
	callf                    p_big / 0     Y[] 
	branch                   ref(L25) 
label(L5):
	retry_me_inline          0     ref(L7)     Y[1] 
label(L6):
	move                     y(1)     a(1) 
	get_constant             a(1)     1.1 
	callf                    p_float / 0     Y[] 
	branch                   ref(L25) 
label(L7):
	retry_me_inline          0     ref(L9)     Y[1] 
label(L8):
	move                     y(1)     a(1) 
	get_constant             a(1)     5_2 
	callf                    p_rational / 0     Y[] 
	branch                   ref(L25) 
label(L9):
	retry_me_inline          0     ref(L11)     Y[1] 
label(L10):
	move                     y(1)     a(1) 
	get_constant             a(1)     0.9__1.1 
	callf                    p_breal / 0     Y[] 
	branch                   ref(L25) 
label(L11):
	retry_me_inline          0     ref(L13)     Y[1] 
label(L12):
	move                     y(1)     a(1) 
	get_string               a(1)     "hello" 
	callf                    p_string / 0     Y[] 
	branch                   ref(L25) 
label(L13):
	retry_me_inline          0     ref(L15)     Y[1] 
label(L14):
	move                     y(1)     a(1) 
	get_atom                 a(1)     hello 
	callf                    p_atom / 0     Y[] 
	branch                   ref(L25) 
label(L15):
	retry_me_inline          0     ref(L17)     Y[1] 
label(L16):
	move                     y(1)     a(1) 
	get_nil                  a(1) 
	callf                    p_nil / 0     Y[] 
	branch                   ref(L25) 
label(L17):
	retry_me_inline          0     ref(L21)     Y[1] 
label(L18):
	move                     y(1)     a(1) 
	get_list                 a(1)     ref(L19) 
	write_void               2 
	branch                   ref(L20) 
label(L19):
label(L20):
	callf                    p_list / 0     Y[] 
	branch                   ref(L25) 
label(L21):
	trust_me_inline          0     Y[1] 
label(L22):
	move                     y(1)     a(1) 
	get_structure            a(1)     foo / 1     ref(L23) 
	write_atom               bar 
	branch                   ref(L24) 
label(L23):
	read_atom                bar 
label(L24):
	callf                    p_struct / 0     Y[] 
label(L25):
	exit                 

------ Test idx(26) -------
p(A) :-
	(
	    var(A),
	    p_var
	;
	    (
		integer(A),
		p_integer
	    ;
		(
		    float(A),
		    p_float
		;
		    (
			rational(A),
			p_rational
		    ;
			(
			    breal(A),
			    p_breal
			;
			    (
				string(A),
				p_string
			    ;
				(
				    nonvar(A),
				    A = [],
				    !,
				    p_nil
				;
				    (
					atom(A),
					p_atom
				    ;
					(
					    nonvar(A),
					    A = [B|C],
					    !,
					    p_list
					;
					    (
						compound(A),
						p_struct
					    ;
						is_handle(A),
						p_handle
					    )
					)
				    )
				)
			    )
			)
		    )
		)
	    )
	).

INDEXES for disjunction [2]
1. Quality 1.0
    [] - []
    [handle] - [11]
    [list] - [9]
    [[]] - [7]
    [structure] - [10]
    [atom] - [8]
    [var] - [1]
    [breal] - [5]
    [rational] - [4]
    [integer] - [2]
    [bignum] - [2]
    [string] - [6]
    [double] - [3]
p / 1:
label(L0):
	allocate                 2 
	savecut                  y(2) 
	move                     a(1)     y(1) 
	switch_on_type           y(1) 
		meta: 	ref(L2)
		[]: 	ref(L14)
		atom: 	ref(L16)
		bignum: 	ref(L4)
		breal: 	ref(L10)
		double: 	ref(L6)
		goal: 	ref(fail)
		handle: 	ref(L24)
		integer: 	ref(L4)
		list: 	ref(L18)
		rational: 	ref(L8)
		string: 	ref(L12)
		structure: 	ref(L22)

	branch                   ref(L2) 
label(L1):
	try_me_else              0     0     ref(L3) 
label(L2):
	move                     y(1)     a(1) 
	bi_var                   a(1) 
	callf                    p_var / 0     Y[] 
	branch                   ref(L25) 
label(L3):
	retry_me_inline          0     ref(L5)     Y[1] 
label(L4):
	move                     y(1)     a(1) 
	bi_integer               a(1) 
	callf                    p_integer / 0     Y[] 
	branch                   ref(L25) 
label(L5):
	retry_me_inline          0     ref(L7)     Y[1] 
label(L6):
	move                     y(1)     a(1) 
	bi_float                 a(1) 
	callf                    p_float / 0     Y[] 
	branch                   ref(L25) 
label(L7):
	retry_me_inline          0     ref(L9)     Y[1] 
label(L8):
	move                     y(1)     a(1) 
	bi_rational              a(1) 
	callf                    p_rational / 0     Y[] 
	branch                   ref(L25) 
label(L9):
	retry_me_inline          0     ref(L11)     Y[1] 
label(L10):
	move                     y(1)     a(1) 
	bi_breal                 a(1) 
	callf                    p_breal / 0     Y[] 
	branch                   ref(L25) 
label(L11):
	retry_me_inline          0     ref(L13)     Y[1] 
label(L12):
	move                     y(1)     a(1) 
	bi_string                a(1) 
	callf                    p_string / 0     Y[] 
	branch                   ref(L25) 
label(L13):
	retry_me_inline          0     ref(L15)     Y[1,2] 
label(L14):
	move                     y(1)     a(1) 
	bi_nonvar                a(1) 
	get_nil                  a(1) 
	cut                      y(2)     2 
	callf                    p_nil / 0     Y[] 
	branch                   ref(L25) 
label(L15):
	retry_me_inline          0     ref(L17)     Y[1] 
label(L16):
	move                     y(1)     a(1) 
	bi_atom                  a(1) 
	callf                    p_atom / 0     Y[] 
	branch                   ref(L25) 
label(L17):
	retry_me_inline          0     ref(L21)     Y[1,2] 
label(L18):
	move                     y(1)     a(1) 
	bi_nonvar                a(1) 
	get_list                 a(1)     ref(L19) 
	write_void               2 
	branch                   ref(L20) 
label(L19):
label(L20):
	cut                      y(2)     2 
	callf                    p_list / 0     Y[] 
	branch                   ref(L25) 
label(L21):
	retry_me_inline          0     ref(L23)     Y[1] 
label(L22):
	move                     y(1)     a(1) 
	bi_compound              a(1) 
	callf                    p_struct / 0     Y[] 
	branch                   ref(L25) 
label(L23):
	trust_me_inline          0     Y[1] 
label(L24):
	move                     y(1)     a(1) 
	bi_is_handle             a(1) 
	callf                    p_handle / 0     Y[] 
label(L25):
	exit                 

------ Test idx(27) -------
p(A) :-
	(
	    atom(A),
	    p_string
	;
	    A = hello,
	    p_hello
	).

INDEXES for disjunction [2]
1. Quality 1.3
    [] - []
    [[]] - [1]
    [var] - [2]
    [atom] - [1]
    [atom, hello] - [1, 2]
p / 1:
label(L0):
	allocate                 1 
	move                     a(1)     y(1) 
	switch_on_type           y(1) 
		meta: 	ref(L4)
		[]: 	ref(L2)
		atom: 	ref(L6)
		bignum: 	ref(fail)
		breal: 	ref(fail)
		double: 	ref(fail)
		goal: 	ref(fail)
		handle: 	ref(fail)
		integer: 	ref(fail)
		list: 	ref(fail)
		rational: 	ref(fail)
		string: 	ref(fail)
		structure: 	ref(fail)

	branch                   ref(L4) 
label(L1):
	try_me_else              0     0     ref(L3) 
label(L2):
	move                     y(1)     a(1) 
	bi_atom                  a(1) 
	callf                    p_string / 0     Y[] 
	branch                   ref(L5) 
label(L3):
	trust_me_inline          0     Y[1] 
label(L4):
	move                     y(1)     a(1) 
	get_atom                 a(1)     hello 
	callf                    p_hello / 0     Y[] 
label(L5):
	exit                 
label(L6):
	atom_switch              y(1) 
		hello: 	ref(L1)
		default: 	ref(L2)


------ Test idx(28) -------
p(A) :-
	(
	    A = "abc",
	    p1
	;
	    (
		A = "def",
		p2
	    ;
		A = ghi,
		p3
	    )
	).

INDEXES for disjunction [2]
1. Quality 2.0
    [] - []
    [atom] - []
    [atom, ghi] - [3]
    [var] - [1, 2, 3]
    [string] - [1, 2]
p / 1:
label(L0):
	allocate                 1 
	move                     a(1)     y(1) 
	switch_on_type           y(1) 
		meta: 	ref(L1)
		[]: 	ref(fail)
		atom: 	ref(L6)
		bignum: 	ref(fail)
		breal: 	ref(fail)
		double: 	ref(fail)
		goal: 	ref(fail)
		handle: 	ref(fail)
		integer: 	ref(fail)
		list: 	ref(fail)
		rational: 	ref(fail)
		string: 	ref(L8)
		structure: 	ref(fail)

label(L1):
	try_me_else              0     0     ref(L3) 
label(L2):
	move                     y(1)     a(1) 
	get_string               a(1)     "abc" 
	callf                    p1 / 0     Y[] 
	branch                   ref(L7) 
label(L3):
	retry_me_inline          0     ref(L5)     Y[1] 
label(L4):
	move                     y(1)     a(1) 
	get_string               a(1)     "def" 
	callf                    p2 / 0     Y[] 
	branch                   ref(L7) 
label(L5):
	trust_me_inline          0     Y[1] 
label(L6):
	move                     y(1)     a(1) 
	get_atom                 a(1)     ghi 
	callf                    p3 / 0     Y[] 
label(L7):
	exit                 
label(L8):
	try                      0     0     ref(L2) 
	trust_inline             0     ref(L4)     Y[1] 

------ Test idx(29) -------
p(A) :-
	A = 1,
	p,
	q(A).
p(A) :-
	A = 2,
	q,
	r(A).

INDEXES for disjunction [2]
1. Quality 1.3
    [] - []
    [var] - [1, 2]
    [integer] - []
    [integer, 1] - [1]
    [integer, 2] - [2]
p / 1:
label(L0):
	allocate                 1 
label(L1):
	integer_switch           a(1) 
		1: 	ref(L3)
		2: 	ref(L5)
		default: 	ref(fail)

label(L2):
	try_me_else              0     1     ref(L4) 
label(L3):
	get_integer              a(1)     1 
	move                     a(1)     y(1) 
	callf                    p / 0     Y[1] 
	move                     y(1)     a(1) 
	callf                    q / 1     Y[] 
	branch                   ref(L6) 
label(L4):
	trust_me_inline          0     Y[] 
label(L5):
	get_integer              a(1)     2 
	move                     a(1)     y(1) 
	callf                    q / 0     Y[1] 
	move                     y(1)     a(1) 
	callf                    r / 1     Y[] 
label(L6):
	exit                 

------ Test idx(30) -------
p(A) :-
	(
	    A = 1,
	    !,
	    p1
	;
	    (
		A = 2,
		!,
		p2
	    ;
		p4
	    )
	).

INDEXES for disjunction [2]
1. Quality 1.0
    [] - [3]
    [var] - [1]
    [integer] - [3]
    [integer, 1] - [1]
    [integer, 2] - [2]
p / 1:
label(L0):
	allocate                 2 
	savecut                  y(2) 
	move                     a(1)     y(1) 
label(L1):
	integer_switch           y(1) 
		1: 	ref(L3)
		2: 	ref(L5)
		default: 	ref(L7)

	branch                   ref(L3) 
label(L2):
	try_me_else              0     0     ref(L4) 
label(L3):
	move                     y(1)     a(1) 
	get_integer              a(1)     1 
	cut                      y(2)     2 
	callf                    p1 / 0     Y[] 
	branch                   ref(L8) 
label(L4):
	retry_me_inline          0     ref(L6)     Y[1,2] 
label(L5):
	move                     y(1)     a(1) 
	get_integer              a(1)     2 
	cut                      y(2)     2 
	callf                    p2 / 0     Y[] 
	branch                   ref(L8) 
label(L6):
	trust_me_inline          0     Y[] 
label(L7):
	callf                    p4 / 0     Y[] 
label(L8):
	exit                 

------ Test idx(31) -------
p(A) :-
	(
	    A = 1,
	    !,
	    p1
	;
	    (
		A = 2,
		!,
		p2
	    ;
		integer(A),
		p4
	    )
	).

INDEXES for disjunction [2]
1. Quality 1.0
    [] - []
    [var] - [1]
    [bignum] - [3]
    [integer] - [3]
    [integer, 1] - [1]
    [integer, 2] - [2]
p / 1:
label(L0):
	allocate                 2 
	savecut                  y(2) 
	move                     a(1)     y(1) 
	switch_on_type           y(1) 
		meta: 	ref(L2)
		[]: 	ref(fail)
		atom: 	ref(fail)
		bignum: 	ref(L6)
		breal: 	ref(fail)
		double: 	ref(fail)
		goal: 	ref(fail)
		handle: 	ref(fail)
		integer: 	ref(L8)
		list: 	ref(fail)
		rational: 	ref(fail)
		string: 	ref(fail)
		structure: 	ref(fail)

	branch                   ref(L2) 
label(L1):
	try_me_else              0     0     ref(L3) 
label(L2):
	move                     y(1)     a(1) 
	get_integer              a(1)     1 
	cut                      y(2)     2 
	callf                    p1 / 0     Y[] 
	branch                   ref(L7) 
label(L3):
	retry_me_inline          0     ref(L5)     Y[1,2] 
label(L4):
	move                     y(1)     a(1) 
	get_integer              a(1)     2 
	cut                      y(2)     2 
	callf                    p2 / 0     Y[] 
	branch                   ref(L7) 
label(L5):
	trust_me_inline          0     Y[1] 
label(L6):
	move                     y(1)     a(1) 
	bi_integer               a(1) 
	callf                    p4 / 0     Y[] 
label(L7):
	exit                 
label(L8):
	integer_switch           y(1) 
		1: 	ref(L2)
		2: 	ref(L4)
		default: 	ref(L6)


------ Test idx(32) -------
p(A) :-
	(
	    A = f(B),
	    !,
	    p1
	;
	    (
		A = g(C),
		!,
		p2
	    ;
		(
		    A = [D|E],
		    !,
		    p3
		;
		    compound(A),
		    p4
		)
	    )
	).

INDEXES for disjunction [2]
1. Quality 1.0
    [] - []
    [list] - [3]
    [structure] - [4]
    [structure, f / 1] - [1]
    [structure, g / 1] - [2]
    [var] - [1]
p / 1:
label(L0):
	allocate                 2 
	savecut                  y(2) 
	move                     a(1)     y(1) 
	switch_on_type           y(1) 
		meta: 	ref(L2)
		[]: 	ref(fail)
		atom: 	ref(fail)
		bignum: 	ref(fail)
		breal: 	ref(fail)
		double: 	ref(fail)
		goal: 	ref(fail)
		handle: 	ref(fail)
		integer: 	ref(fail)
		list: 	ref(L10)
		rational: 	ref(fail)
		string: 	ref(fail)
		structure: 	ref(L16)

	branch                   ref(L2) 
label(L1):
	try_me_else              0     0     ref(L5) 
label(L2):
	move                     y(1)     a(1) 
	get_structure            a(1)     f / 1     ref(L3) 
	write_void           
	branch                   ref(L4) 
label(L3):
label(L4):
	cut                      y(2)     2 
	callf                    p1 / 0     Y[] 
	branch                   ref(L15) 
label(L5):
	retry_me_inline          0     ref(L9)     Y[1,2] 
label(L6):
	move                     y(1)     a(1) 
	get_structure            a(1)     g / 1     ref(L7) 
	write_void           
	branch                   ref(L8) 
label(L7):
label(L8):
	cut                      y(2)     2 
	callf                    p2 / 0     Y[] 
	branch                   ref(L15) 
label(L9):
	retry_me_inline          0     ref(L13)     Y[1,2] 
label(L10):
	move                     y(1)     a(1) 
	get_list                 a(1)     ref(L11) 
	write_void               2 
	branch                   ref(L12) 
label(L11):
label(L12):
	cut                      y(2)     2 
	callf                    p3 / 0     Y[] 
	branch                   ref(L15) 
label(L13):
	trust_me_inline          0     Y[1] 
label(L14):
	move                     y(1)     a(1) 
	bi_compound              a(1) 
	callf                    p4 / 0     Y[] 
label(L15):
	exit                 
label(L16):
	functor_switch           y(1) 
		f / 1: 	ref(L2)
		g / 1: 	ref(L6)
		default: 	ref(L14)


------ Test idx(33) -------
p(f(A, B, C)) :-
	!,
	p1(A, B, C).
p([A|B]) :-
	!,
	p2(A, B).
p(A) :-
	compound(A),
	p3.

INDEXES for disjunction [2]
1. Quality 1.0
    [] - []
    [list] - [2]
    [structure] - [3]
    [structure, f / 3] - [1]
    [var] - [1]
p / 1:
label(L0):
	allocate                 1 
	savecut                  y(1) 
	switch_on_type           a(1) 
		meta: 	ref(L2)
		[]: 	ref(fail)
		atom: 	ref(fail)
		bignum: 	ref(fail)
		breal: 	ref(fail)
		double: 	ref(fail)
		goal: 	ref(fail)
		handle: 	ref(fail)
		integer: 	ref(fail)
		list: 	ref(L6)
		rational: 	ref(fail)
		string: 	ref(fail)
		structure: 	ref(L12)

	branch                   ref(L2) 
label(L1):
	try_me_else              0     1     ref(L5) 
label(L2):
	get_structure            a(1)     f / 3     ref(L3) 
	write_variable           a(1) 
	write_variable           a(2) 
	write_variable           a(3) 
	branch                   ref(L4) 
label(L3):
	read_variable            a(1) 
	read_variable            a(2) 
	read_variable            a(3) 
label(L4):
	cut                      y(1)     1 
	callf                    p1 / 3     Y[] 
	branch                   ref(L11) 
label(L5):
	retry_me_inline          0     ref(L9)     Y[1] 
label(L6):
	get_list                 a(1)     ref(L7) 
	write_variable           a(1) 
	write_variable           a(2) 
	branch                   ref(L8) 
label(L7):
	read_variable            a(1) 
	read_variable            a(2) 
label(L8):
	cut                      y(1)     1 
	callf                    p2 / 2     Y[] 
	branch                   ref(L11) 
label(L9):
	trust_me_inline          0     Y[] 
label(L10):
	bi_compound              a(1) 
	callf                    p3 / 0     Y[] 
label(L11):
	exit                 
label(L12):
	functor_switch           a(1) 
		f / 3: 	ref(L2)
		default: 	ref(L10)


------ Test idx(34) -------
p(f(A, B, A), C) :-
	!,
	p1(A, B, C).
p([A|B], B) :-
	!,
	p2(A, B).
p(A, B) :-
	compound(A),
	p3.

INDEXES for disjunction [2]
1. Quality 1.5
    [] - []
    [list] - [2, 3]
    [structure] - [3]
    [structure, f / 3] - [1, 3]
    [var] - [1]
p / 2:
label(L0):
	allocate                 1 
	savecut                  y(1) 
	switch_on_type           a(1) 
		meta: 	ref(L2)
		[]: 	ref(fail)
		atom: 	ref(fail)
		bignum: 	ref(fail)
		breal: 	ref(fail)
		double: 	ref(fail)
		goal: 	ref(fail)
		handle: 	ref(fail)
		integer: 	ref(fail)
		list: 	ref(L12)
		rational: 	ref(fail)
		string: 	ref(fail)
		structure: 	ref(L14)

	branch                   ref(L2) 
label(L1):
	try_me_else              0     2     ref(L5) 
label(L2):
	get_structure            a(1)     f / 3     ref(L3) 
	write_variable           a(1) 
	move                     a(2)     a(3) 
	write_variable           a(2) 
	write_local_value        a(1) 
	branch                   ref(L4) 
label(L3):
	read_variable            a(1) 
	move                     a(2)     a(3) 
	read_variable            a(2) 
	read_value               a(1) 
label(L4):
	cut                      y(1)     1 
	callf                    p1 / 3     Y[] 
	branch                   ref(L11) 
label(L5):
	retry_me_inline          0     ref(L9)     Y[1] 
label(L6):
	get_list                 a(1)     ref(L7) 
	write_variable           a(1) 
	write_local_value        a(2) 
	branch                   ref(L8) 
label(L7):
	read_variable            a(1) 
	read_value               a(2) 
label(L8):
	cut                      y(1)     1 
	callf                    p2 / 2     Y[] 
	branch                   ref(L11) 
label(L9):
	trust_me_inline          0     Y[] 
label(L10):
	bi_compound              a(1) 
	callf                    p3 / 0     Y[] 
label(L11):
	exit                 
label(L12):
	try                      0     2     ref(L6) 
	trust_inline             0     ref(L10)     Y[] 
label(L13):
	try                      0     2     ref(L2) 
	trust_inline             0     ref(L10)     Y[] 
label(L14):
	functor_switch           a(1) 
		f / 3: 	ref(L13)
		default: 	ref(L10)


------ Test idx(35) -------
p(f(A, B, C)) :-
	-?->
	!,
	p1(A, B, C).
p([A|B]) :-
	-?->
	!,
	p2(A, B).
p(A) :-
	compound(A),
	p3.

INDEXES for disjunction [2]
1. Quality 0.8
    [] - []
    [list] - [2]
    [structure] - [3]
    [structure, f / 3] - [1]
p / 1:
label(L0):
	allocate                 1 
	savecut                  y(1) 
	switch_on_type           a(1) 
		meta: 	ref(fail)
		[]: 	ref(fail)
		atom: 	ref(fail)
		bignum: 	ref(fail)
		breal: 	ref(fail)
		double: 	ref(fail)
		goal: 	ref(fail)
		handle: 	ref(fail)
		integer: 	ref(fail)
		list: 	ref(L5)
		rational: 	ref(fail)
		string: 	ref(fail)
		structure: 	ref(L10)

	branch                   ref(fail) 
label(L1):
	try_me_else              0     1     ref(L4) 
label(L2):
	in_get_structure         a(1)     f / 3     ref(L3) 
label(L3):
	read_variable            a(1) 
	read_variable            a(2) 
	read_variable            a(3) 
	cut                      y(1)     1 
	callf                    p1 / 3     Y[] 
	branch                   ref(L9) 
label(L4):
	retry_me_inline          0     ref(L7)     Y[1] 
label(L5):
	in_get_list              a(1)     ref(L6) 
label(L6):
	read_variable            a(1) 
	read_variable            a(2) 
	cut                      y(1)     1 
	callf                    p2 / 2     Y[] 
	branch                   ref(L9) 
label(L7):
	trust_me_inline          0     Y[] 
label(L8):
	bi_compound              a(1) 
	callf                    p3 / 0     Y[] 
label(L9):
	exit                 
label(L10):
	functor_switch           a(1) 
		f / 3: 	ref(L2)
		default: 	ref(L8)


------ Test idx(36) -------
p(f(A, B, C), C) :-
	-?->
	!,
	p1(A, B, C).
p([A|B], B) :-
	-?->
	!,
	p2(A, B).
p(A, B) :-
	compound(A),
	p3.

INDEXES for disjunction [2]
1. Quality 1.2
    [] - []
    [list] - [2, 3]
    [structure] - [3]
    [structure, f / 3] - [1, 3]
p / 2:
label(L0):
	allocate                 1 
	savecut                  y(1) 
	switch_on_type           a(1) 
		meta: 	ref(fail)
		[]: 	ref(fail)
		atom: 	ref(fail)
		bignum: 	ref(fail)
		breal: 	ref(fail)
		double: 	ref(fail)
		goal: 	ref(fail)
		handle: 	ref(fail)
		integer: 	ref(fail)
		list: 	ref(L10)
		rational: 	ref(fail)
		string: 	ref(fail)
		structure: 	ref(L12)

	branch                   ref(fail) 
label(L1):
	try_me_else              0     2     ref(L4) 
label(L2):
	in_get_structure         a(1)     f / 3     ref(L3) 
label(L3):
	read_variable            a(1) 
	move                     a(2)     a(3) 
	read_variable            a(2) 
	read_matched_value       a(3) 
	cut                      y(1)     1 
	callf                    p1 / 3     Y[] 
	branch                   ref(L9) 
label(L4):
	retry_me_inline          0     ref(L7)     Y[1] 
label(L5):
	in_get_list              a(1)     ref(L6) 
label(L6):
	read_variable            a(1) 
	read_matched_value       a(2) 
	cut                      y(1)     1 
	callf                    p2 / 2     Y[] 
	branch                   ref(L9) 
label(L7):
	trust_me_inline          0     Y[] 
label(L8):
	bi_compound              a(1) 
	callf                    p3 / 0     Y[] 
label(L9):
	exit                 
label(L10):
	try                      0     2     ref(L5) 
	trust_inline             0     ref(L8)     Y[] 
label(L11):
	try                      0     2     ref(L2) 
	trust_inline             0     ref(L8)     Y[] 
label(L12):
	functor_switch           a(1) 
		f / 3: 	ref(L11)
		default: 	ref(L8)


------ Test idx(40) -------
p(A) :-
	(
	    free(A),
	    p1
	;
	    (
		meta(A),
		p2
	    ;
		p3
	    )
	).

INDEXES for disjunction [2]
1. Quality 1.7
    [] - [3]
    [var] - [3]
    [var, free] - [1, 3]
    [var, meta] - [2, 3]
p / 1:
label(L0):
	allocate                 1 
	move                     a(1)     y(1) 
	switch_on_type           y(1) 
		meta: 	ref(L9)
		[]: 	ref(L6)
		atom: 	ref(L6)
		bignum: 	ref(L6)
		breal: 	ref(L6)
		double: 	ref(L6)
		goal: 	ref(L6)
		handle: 	ref(L6)
		integer: 	ref(L6)
		list: 	ref(L6)
		rational: 	ref(L6)
		string: 	ref(L6)
		structure: 	ref(L6)

	branch                   ref(L8) 
label(L1):
	try_me_else              0     0     ref(L3) 
label(L2):
	move                     y(1)     a(1) 
	bi_free                  a(1) 
	callf                    p1 / 0     Y[] 
	branch                   ref(L7) 
label(L3):
	retry_me_inline          0     ref(L5)     Y[1] 
label(L4):
	move                     y(1)     a(1) 
	bi_meta                  a(1) 
	callf                    p2 / 0     Y[] 
	branch                   ref(L7) 
label(L5):
	trust_me_inline          0     Y[] 
label(L6):
	callf                    p3 / 0     Y[] 
label(L7):
	exit                 
label(L8):
	try                      0     0     ref(L2) 
	trust_inline             0     ref(L6)     Y[] 
label(L9):
	try                      0     0     ref(L4) 
	trust_inline             0     ref(L6)     Y[] 

------ Test idx(41) -------
p(A) :-
	(
	    free(A),
	    !,
	    p1
	;
	    (
		meta(A),
		!,
		p2
	    ;
		p3
	    )
	).

INDEXES for disjunction [2]
1. Quality 1.0
    [] - [3]
    [var] - [3]
    [var, free] - [1]
    [var, meta] - [2]
p / 1:
label(L0):
	allocate                 2 
	savecut                  y(2) 
	move                     a(1)     y(1) 
	switch_on_type           y(1) 
		meta: 	ref(L4)
		[]: 	ref(L6)
		atom: 	ref(L6)
		bignum: 	ref(L6)
		breal: 	ref(L6)
		double: 	ref(L6)
		goal: 	ref(L6)
		handle: 	ref(L6)
		integer: 	ref(L6)
		list: 	ref(L6)
		rational: 	ref(L6)
		string: 	ref(L6)
		structure: 	ref(L6)

	branch                   ref(L2) 
label(L1):
	try_me_else              0     0     ref(L3) 
label(L2):
	move                     y(1)     a(1) 
	bi_free                  a(1) 
	cut                      y(2)     2 
	callf                    p1 / 0     Y[] 
	branch                   ref(L7) 
label(L3):
	retry_me_inline          0     ref(L5)     Y[1,2] 
label(L4):
	move                     y(1)     a(1) 
	bi_meta                  a(1) 
	cut                      y(2)     2 
	callf                    p2 / 0     Y[] 
	branch                   ref(L7) 
label(L5):
	trust_me_inline          0     Y[] 
label(L6):
	callf                    p3 / 0     Y[] 
label(L7):
	exit                 

------ Test idx(42) -------
p(A) :-
	(
	    free(A),
	    p1
	;
	    (
		meta(A),
		p2
	    ;
		atom(A),
		p3
	    )
	).

INDEXES for disjunction [2]
1. Quality 1.0
    [] - []
    [[]] - [3]
    [atom] - [3]
    [var] - []
    [var, free] - [1]
    [var, meta] - [2]
p / 1:
label(L0):
	allocate                 1 
	move                     a(1)     y(1) 
	switch_on_type           y(1) 
		meta: 	ref(L4)
		[]: 	ref(L6)
		atom: 	ref(L6)
		bignum: 	ref(fail)
		breal: 	ref(fail)
		double: 	ref(fail)
		goal: 	ref(fail)
		handle: 	ref(fail)
		integer: 	ref(fail)
		list: 	ref(fail)
		rational: 	ref(fail)
		string: 	ref(fail)
		structure: 	ref(fail)

	branch                   ref(L2) 
label(L1):
	try_me_else              0     0     ref(L3) 
label(L2):
	move                     y(1)     a(1) 
	bi_free                  a(1) 
	callf                    p1 / 0     Y[] 
	branch                   ref(L7) 
label(L3):
	retry_me_inline          0     ref(L5)     Y[1] 
label(L4):
	move                     y(1)     a(1) 
	bi_meta                  a(1) 
	callf                    p2 / 0     Y[] 
	branch                   ref(L7) 
label(L5):
	trust_me_inline          0     Y[1] 
label(L6):
	move                     y(1)     a(1) 
	bi_atom                  a(1) 
	callf                    p3 / 0     Y[] 
label(L7):
	exit                 

------ Test idx(43) -------
p(A) :-
	(
	    free(A),
	    p1
	;
	    p2
	).

INDEXES for disjunction [2]
1. Quality 1.5
    [] - [2]
    [var] - [2]
    [var, free] - [1, 2]
p / 1:
label(L0):
	allocate                 1 
	move                     a(1)     y(1) 
	switch_on_type           y(1) 
		meta: 	ref(L4)
		[]: 	ref(L4)
		atom: 	ref(L4)
		bignum: 	ref(L4)
		breal: 	ref(L4)
		double: 	ref(L4)
		goal: 	ref(L4)
		handle: 	ref(L4)
		integer: 	ref(L4)
		list: 	ref(L4)
		rational: 	ref(L4)
		string: 	ref(L4)
		structure: 	ref(L4)

label(L1):
	try_me_else              0     0     ref(L3) 
label(L2):
	move                     y(1)     a(1) 
	bi_free                  a(1) 
	callf                    p1 / 0     Y[] 
	branch                   ref(L5) 
label(L3):
	trust_me_inline          0     Y[] 
label(L4):
	callf                    p2 / 0     Y[] 
label(L5):
	exit                 

------ Test idx(44) -------
p(A) :-
	(
	    free(A),
	    !,
	    p1
	;
	    p2
	).

INDEXES for disjunction [2]
1. Quality 1.0
    [] - [2]
    [var] - [2]
    [var, free] - [1]
p / 1:
label(L0):
	allocate                 2 
	savecut                  y(2) 
	move                     a(1)     y(1) 
	switch_on_type           y(1) 
		meta: 	ref(L4)
		[]: 	ref(L4)
		atom: 	ref(L4)
		bignum: 	ref(L4)
		breal: 	ref(L4)
		double: 	ref(L4)
		goal: 	ref(L4)
		handle: 	ref(L4)
		integer: 	ref(L4)
		list: 	ref(L4)
		rational: 	ref(L4)
		string: 	ref(L4)
		structure: 	ref(L4)

	branch                   ref(L2) 
label(L1):
	try_me_else              0     0     ref(L3) 
label(L2):
	move                     y(1)     a(1) 
	bi_free                  a(1) 
	cut                      y(2)     2 
	callf                    p1 / 0     Y[] 
	branch                   ref(L5) 
label(L3):
	trust_me_inline          0     Y[] 
label(L4):
	callf                    p2 / 0     Y[] 
label(L5):
	exit                 

------ Test idx(45) -------
p(A) :-
	(
	    free(A),
	    p1
	;
	    p2
	).

INDEXES for disjunction [2]
1. Quality 1.5
    [] - [2]
    [var] - [2]
    [var, free] - [1, 2]
p / 1:
label(L0):
	allocate                 1 
	move                     a(1)     y(1) 
	switch_on_type           y(1) 
		meta: 	ref(L4)
		[]: 	ref(L4)
		atom: 	ref(L4)
		bignum: 	ref(L4)
		breal: 	ref(L4)
		double: 	ref(L4)
		goal: 	ref(L4)
		handle: 	ref(L4)
		integer: 	ref(L4)
		list: 	ref(L4)
		rational: 	ref(L4)
		string: 	ref(L4)
		structure: 	ref(L4)

label(L1):
	try_me_else              0     0     ref(L3) 
label(L2):
	move                     y(1)     a(1) 
	bi_free                  a(1) 
	callf                    p1 / 0     Y[] 
	branch                   ref(L5) 
label(L3):
	trust_me_inline          0     Y[] 
label(L4):
	callf                    p2 / 0     Y[] 
label(L5):
	exit                 

------ Test idx(46) -------
p(A) :-
	(
	    meta(A),
	    p1
	;
	    p2
	).

INDEXES for disjunction [2]
1. Quality 1.5
    [] - [2]
    [var] - [2]
    [var, meta] - [1, 2]
p / 1:
label(L0):
	allocate                 1 
	move                     a(1)     y(1) 
	switch_on_type           y(1) 
		meta: 	ref(L1)
		[]: 	ref(L4)
		atom: 	ref(L4)
		bignum: 	ref(L4)
		breal: 	ref(L4)
		double: 	ref(L4)
		goal: 	ref(L4)
		handle: 	ref(L4)
		integer: 	ref(L4)
		list: 	ref(L4)
		rational: 	ref(L4)
		string: 	ref(L4)
		structure: 	ref(L4)

	branch                   ref(L4) 
label(L1):
	try_me_else              0     0     ref(L3) 
label(L2):
	move                     y(1)     a(1) 
	bi_meta                  a(1) 
	callf                    p1 / 0     Y[] 
	branch                   ref(L5) 
label(L3):
	trust_me_inline          0     Y[] 
label(L4):
	callf                    p2 / 0     Y[] 
label(L5):
	exit                 

------ Test idx(47) -------
p(A) :-
	(
	    meta(A),
	    !,
	    p1
	;
	    p2
	).

INDEXES for disjunction [2]
1. Quality 1.0
    [] - [2]
    [var] - [2]
    [var, meta] - [1]
p / 1:
label(L0):
	allocate                 2 
	savecut                  y(2) 
	move                     a(1)     y(1) 
	switch_on_type           y(1) 
		meta: 	ref(L2)
		[]: 	ref(L4)
		atom: 	ref(L4)
		bignum: 	ref(L4)
		breal: 	ref(L4)
		double: 	ref(L4)
		goal: 	ref(L4)
		handle: 	ref(L4)
		integer: 	ref(L4)
		list: 	ref(L4)
		rational: 	ref(L4)
		string: 	ref(L4)
		structure: 	ref(L4)

	branch                   ref(L4) 
label(L1):
	try_me_else              0     0     ref(L3) 
label(L2):
	move                     y(1)     a(1) 
	bi_meta                  a(1) 
	cut                      y(2)     2 
	callf                    p1 / 0     Y[] 
	branch                   ref(L5) 
label(L3):
	trust_me_inline          0     Y[] 
label(L4):
	callf                    p2 / 0     Y[] 
label(L5):
	exit                 

------ Test idx(48) -------
p(A) :-
	(
	    meta(A),
	    p1
	;
	    p2
	).

INDEXES for disjunction [2]
1. Quality 1.5
    [] - [2]
    [var] - [2]
    [var, meta] - [1, 2]
p / 1:
label(L0):
	allocate                 1 
	move                     a(1)     y(1) 
	switch_on_type           y(1) 
		meta: 	ref(L1)
		[]: 	ref(L4)
		atom: 	ref(L4)
		bignum: 	ref(L4)
		breal: 	ref(L4)
		double: 	ref(L4)
		goal: 	ref(L4)
		handle: 	ref(L4)
		integer: 	ref(L4)
		list: 	ref(L4)
		rational: 	ref(L4)
		string: 	ref(L4)
		structure: 	ref(L4)

	branch                   ref(L4) 
label(L1):
	try_me_else              0     0     ref(L3) 
label(L2):
	move                     y(1)     a(1) 
	bi_meta                  a(1) 
	callf                    p1 / 0     Y[] 
	branch                   ref(L5) 
label(L3):
	trust_me_inline          0     Y[] 
label(L4):
	callf                    p2 / 0     Y[] 
label(L5):
	exit                 

------ Test idx(49) -------
p(A) :-
	(
	    free(A),
	    p1
	;
	    (
		var(A),
		p2
	    ;
		p3
	    )
	).

INDEXES for disjunction [2]
1. Quality 2.0
    [] - [3]
    [var] - [2, 3]
    [var, free] - [1, 2, 3]
p / 1:
label(L0):
	allocate                 1 
	move                     a(1)     y(1) 
	switch_on_type           y(1) 
		meta: 	ref(L8)
		[]: 	ref(L6)
		atom: 	ref(L6)
		bignum: 	ref(L6)
		breal: 	ref(L6)
		double: 	ref(L6)
		goal: 	ref(L6)
		handle: 	ref(L6)
		integer: 	ref(L6)
		list: 	ref(L6)
		rational: 	ref(L6)
		string: 	ref(L6)
		structure: 	ref(L6)

label(L1):
	try_me_else              0     0     ref(L3) 
label(L2):
	move                     y(1)     a(1) 
	bi_free                  a(1) 
	callf                    p1 / 0     Y[] 
	branch                   ref(L7) 
label(L3):
	retry_me_inline          0     ref(L5)     Y[1] 
label(L4):
	move                     y(1)     a(1) 
	bi_var                   a(1) 
	callf                    p2 / 0     Y[] 
	branch                   ref(L7) 
label(L5):
	trust_me_inline          0     Y[] 
label(L6):
	callf                    p3 / 0     Y[] 
label(L7):
	exit                 
label(L8):
	try                      0     0     ref(L4) 
	trust_inline             0     ref(L6)     Y[] 

------ Test idx(50) -------
p(A) :-
	(
	    free(A),
	    !,
	    p1
	;
	    (
		var(A),
		!,
		p2
	    ;
		p3
	    )
	).

INDEXES for disjunction [2]
1. Quality 1.0
    [] - [3]
    [var] - [2]
    [var, free] - [1]
p / 1:
label(L0):
	allocate                 2 
	savecut                  y(2) 
	move                     a(1)     y(1) 
	switch_on_type           y(1) 
		meta: 	ref(L4)
		[]: 	ref(L6)
		atom: 	ref(L6)
		bignum: 	ref(L6)
		breal: 	ref(L6)
		double: 	ref(L6)
		goal: 	ref(L6)
		handle: 	ref(L6)
		integer: 	ref(L6)
		list: 	ref(L6)
		rational: 	ref(L6)
		string: 	ref(L6)
		structure: 	ref(L6)

	branch                   ref(L2) 
label(L1):
	try_me_else              0     0     ref(L3) 
label(L2):
	move                     y(1)     a(1) 
	bi_free                  a(1) 
	cut                      y(2)     2 
	callf                    p1 / 0     Y[] 
	branch                   ref(L7) 
label(L3):
	retry_me_inline          0     ref(L5)     Y[1,2] 
label(L4):
	move                     y(1)     a(1) 
	bi_var                   a(1) 
	cut                      y(2)     2 
	callf                    p2 / 0     Y[] 
	branch                   ref(L7) 
label(L5):
	trust_me_inline          0     Y[] 
label(L6):
	callf                    p3 / 0     Y[] 
label(L7):
	exit                 

------ Test idx(51) -------
p(A) :-
	(
	    free(A),
	    p1
	;
	    (
		var(A),
		p2
	    ;
		atom(A),
		p3
	    )
	).

INDEXES for disjunction [2]
1. Quality 1.3
    [] - []
    [[]] - [3]
    [atom] - [3]
    [var] - [2]
    [var, free] - [1, 2]
p / 1:
label(L0):
	allocate                 1 
	move                     a(1)     y(1) 
	switch_on_type           y(1) 
		meta: 	ref(L4)
		[]: 	ref(L6)
		atom: 	ref(L6)
		bignum: 	ref(fail)
		breal: 	ref(fail)
		double: 	ref(fail)
		goal: 	ref(fail)
		handle: 	ref(fail)
		integer: 	ref(fail)
		list: 	ref(fail)
		rational: 	ref(fail)
		string: 	ref(fail)
		structure: 	ref(fail)

	branch                   ref(L8) 
label(L1):
	try_me_else              0     0     ref(L3) 
label(L2):
	move                     y(1)     a(1) 
	bi_free                  a(1) 
	callf                    p1 / 0     Y[] 
	branch                   ref(L7) 
label(L3):
	retry_me_inline          0     ref(L5)     Y[1] 
label(L4):
	move                     y(1)     a(1) 
	bi_var                   a(1) 
	callf                    p2 / 0     Y[] 
	branch                   ref(L7) 
label(L5):
	trust_me_inline          0     Y[1] 
label(L6):
	move                     y(1)     a(1) 
	bi_atom                  a(1) 
	callf                    p3 / 0     Y[] 
label(L7):
	exit                 
label(L8):
	try                      0     0     ref(L2) 
	trust_inline             0     ref(L4)     Y[1] 

------ Test idx(52) -------
p(A) :-
	(
	    var(A),
	    !,
	    p1
	;
	    p2
	).

INDEXES for disjunction [2]
1. Quality 1.0
    [] - [2]
    [var] - [1]
p / 1:
label(L0):
	allocate                 2 
	savecut                  y(2) 
	move                     a(1)     y(1) 
	switch_on_type           y(1) 
		meta: 	ref(L2)
		[]: 	ref(L4)
		atom: 	ref(L4)
		bignum: 	ref(L4)
		breal: 	ref(L4)
		double: 	ref(L4)
		goal: 	ref(L4)
		handle: 	ref(L4)
		integer: 	ref(L4)
		list: 	ref(L4)
		rational: 	ref(L4)
		string: 	ref(L4)
		structure: 	ref(L4)

	branch                   ref(L2) 
label(L1):
	try_me_else              0     0     ref(L3) 
label(L2):
	move                     y(1)     a(1) 
	bi_var                   a(1) 
	cut                      y(2)     2 
	callf                    p1 / 0     Y[] 
	branch                   ref(L5) 
label(L3):
	trust_me_inline          0     Y[] 
label(L4):
	callf                    p2 / 0     Y[] 
label(L5):
	exit                 

------ Test idx(53) -------
p(A) :-
	(
	    var(A),
	    !,
	    p1
	;
	    (
		A = 1,
		p2
	    ;
		A = 2,
		p3
	    )
	).

INDEXES for disjunction [2]
1. Quality 1.0
    [] - []
    [var] - [1]
    [integer] - []
    [integer, 1] - [2]
    [integer, 2] - [3]
p / 1:
label(L0):
	allocate                 2 
	savecut                  y(2) 
	move                     a(1)     y(1) 
label(L1):
	integer_switch           y(1) 
		1: 	ref(L5)
		2: 	ref(L7)
		default: 	ref(fail)

	branch                   ref(L3) 
label(L2):
	try_me_else              0     0     ref(L4) 
label(L3):
	move                     y(1)     a(1) 
	bi_var                   a(1) 
	cut                      y(2)     2 
	callf                    p1 / 0     Y[] 
	branch                   ref(L8) 
label(L4):
	retry_me_inline          0     ref(L6)     Y[1] 
label(L5):
	move                     y(1)     a(1) 
	get_integer              a(1)     1 
	callf                    p2 / 0     Y[] 
	branch                   ref(L8) 
label(L6):
	trust_me_inline          0     Y[1] 
label(L7):
	move                     y(1)     a(1) 
	get_integer              a(1)     2 
	callf                    p3 / 0     Y[] 
label(L8):
	exit                 

------ Test idx(54) -------
p(A) :-
	(
	    var(A),
	    !,
	    p1
	;
	    (
		integer(A),
		A = 1,
		p2
	    ;
		integer(A),
		A = 2,
		p3
	    )
	).

INDEXES for disjunction [2]
1. Quality 1.0
    [] - []
    [var] - [1]
    [integer] - []
    [integer, 1] - [2]
    [integer, 2] - [3]
p / 1:
label(L0):
	allocate                 2 
	savecut                  y(2) 
	move                     a(1)     y(1) 
label(L1):
	integer_switch           y(1) 
		1: 	ref(L5)
		2: 	ref(L7)
		default: 	ref(fail)

	branch                   ref(L3) 
label(L2):
	try_me_else              0     0     ref(L4) 
label(L3):
	move                     y(1)     a(1) 
	bi_var                   a(1) 
	cut                      y(2)     2 
	callf                    p1 / 0     Y[] 
	branch                   ref(L8) 
label(L4):
	retry_me_inline          0     ref(L6)     Y[1] 
label(L5):
	move                     y(1)     a(1) 
	bi_integer               a(1) 
	get_integer              a(1)     1 
	callf                    p2 / 0     Y[] 
	branch                   ref(L8) 
label(L6):
	trust_me_inline          0     Y[1] 
label(L7):
	move                     y(1)     a(1) 
	bi_integer               a(1) 
	get_integer              a(1)     2 
	callf                    p3 / 0     Y[] 
label(L8):
	exit                 

------ Test idx(55) -------
p(A) :-
	(
	    var(A),
	    !,
	    p1
	;
	    (
		A = 1,
		!,
		p2
	    ;
		integer(A),
		p3
	    )
	).

INDEXES for disjunction [2]
1. Quality 1.0
    [] - []
    [var] - [1]
    [bignum] - [3]
    [integer] - [3]
    [integer, 1] - [2]
p / 1:
label(L0):
	allocate                 2 
	savecut                  y(2) 
	move                     a(1)     y(1) 
	switch_on_type           y(1) 
		meta: 	ref(L2)
		[]: 	ref(fail)
		atom: 	ref(fail)
		bignum: 	ref(L6)
		breal: 	ref(fail)
		double: 	ref(fail)
		goal: 	ref(fail)
		handle: 	ref(fail)
		integer: 	ref(L8)
		list: 	ref(fail)
		rational: 	ref(fail)
		string: 	ref(fail)
		structure: 	ref(fail)

	branch                   ref(L2) 
label(L1):
	try_me_else              0     0     ref(L3) 
label(L2):
	move                     y(1)     a(1) 
	bi_var                   a(1) 
	cut                      y(2)     2 
	callf                    p1 / 0     Y[] 
	branch                   ref(L7) 
label(L3):
	retry_me_inline          0     ref(L5)     Y[1,2] 
label(L4):
	move                     y(1)     a(1) 
	get_integer              a(1)     1 
	cut                      y(2)     2 
	callf                    p2 / 0     Y[] 
	branch                   ref(L7) 
label(L5):
	trust_me_inline          0     Y[1] 
label(L6):
	move                     y(1)     a(1) 
	bi_integer               a(1) 
	callf                    p3 / 0     Y[] 
label(L7):
	exit                 
label(L8):
	integer_switch           y(1) 
		1: 	ref(L4)
		default: 	ref(L6)


------ Test idx(56) -------
p(A, B) :-
	(
	    integer(A),
	    B = a,
	    p1
	;
	    (
		integer(A),
		B = b,
		p2
	    ;
		(
		    integer(A),
		    B = c,
		    p3
		;
		    atom(A),
		    p4
		)
	    )
	).

INDEXES for disjunction [2]
1. Quality 1.3
    [] - []
    [[]] - [4]
    [atom] - [4]
    [integer] - [1, 2, 3]
    [bignum] - [1, 2, 3]
2. Quality 2.2
    [] - [4]
    [atom] - [4]
    [atom, a] - [1, 4]
    [atom, b] - [2, 4]
    [atom, c] - [3, 4]
    [var] - [1, 2, 3, 4]
p / 2:
label(L0):
	allocate                 2 
	move                     2     a(1)     y(1) 
	switch_on_type           y(1) 
		meta: 	ref(fail)
		[]: 	ref(L10)
		atom: 	ref(L10)
		bignum: 	ref(L12)
		breal: 	ref(fail)
		double: 	ref(fail)
		goal: 	ref(fail)
		handle: 	ref(fail)
		integer: 	ref(L12)
		list: 	ref(fail)
		rational: 	ref(fail)
		string: 	ref(fail)
		structure: 	ref(fail)

	branch                   ref(fail) 
label(L1):
label(L2):
	atom_switch              y(2) 
		a: 	ref(L13)
		b: 	ref(L14)
		c: 	ref(L15)
		default: 	ref(L10)

label(L3):
	try_me_else              0     0     ref(L5) 
label(L4):
	move                     y(1)     a(1) 
	bi_integer               a(1) 
	move                     y(2)     a(1) 
	get_atom                 a(1)     a 
	callf                    p1 / 0     Y[] 
	branch                   ref(L11) 
label(L5):
	retry_me_inline          0     ref(L7)     Y[1,2] 
label(L6):
	move                     y(1)     a(1) 
	bi_integer               a(1) 
	move                     y(2)     a(1) 
	get_atom                 a(1)     b 
	callf                    p2 / 0     Y[] 
	branch                   ref(L11) 
label(L7):
	retry_me_inline          0     ref(L9)     Y[1,2] 
label(L8):
	move                     y(1)     a(1) 
	bi_integer               a(1) 
	move                     y(2)     a(1) 
	get_atom                 a(1)     c 
	callf                    p3 / 0     Y[] 
	branch                   ref(L11) 
label(L9):
	trust_me_inline          0     Y[1] 
label(L10):
	move                     y(1)     a(1) 
	bi_atom                  a(1) 
	callf                    p4 / 0     Y[] 
label(L11):
	exit                 
label(L12):
	try                      0     0     ref(L4) 
	retry_inline             0     ref(L6)     Y[1,2] 
	trust_inline             0     ref(L8)     Y[1,2] 
label(L13):
	try                      0     0     ref(L4) 
	trust_inline             0     ref(L10)     Y[1] 
label(L14):
	try                      0     0     ref(L6) 
	trust_inline             0     ref(L10)     Y[1] 
label(L15):
	try                      0     0     ref(L8) 
	trust_inline             0     ref(L10)     Y[1] 

------ Test idx(100) -------
p(1) :-
	-?->
	p_1.
p(2) :-
	-?->
	p_2.

INDEXES for disjunction [2]
1. Quality 0.7
    [] - []
    [integer] - []
    [integer, 1] - [1]
    [integer, 2] - [2]
p / 1:
label(L0):
	allocate                 0 
label(L1):
	integer_switch           a(1) 
		1: 	ref(L3)
		2: 	ref(L5)
		default: 	ref(fail)

	branch                   ref(fail) 
label(L2):
	try_me_else              0     1     ref(L4) 
label(L3):
	in_get_integer           a(1)     1 
	callf                    p_1 / 0     Y[] 
	branch                   ref(L6) 
label(L4):
	trust_me_inline          0     Y[] 
label(L5):
	in_get_integer           a(1)     2 
	callf                    p_2 / 0     Y[] 
label(L6):
	exit                 

------ Test idx(101) -------
p(1) :-
	-?->
	p_integer.
p(10000000000000000000) :-
	-?->
	p_big.
p(1.1) :-
	-?->
	p_float.
p(5_2) :-
	-?->
	p_rational.
p(0.9__1.1) :-
	-?->
	p_breal.
p("hello") :-
	-?->
	p_string.
p(hello) :-
	-?->
	p_atom.
p([]) :-
	-?->
	p_nil.
p([A|B]) :-
	-?->
	p_list.
p(foo(bar)) :-
	-?->
	p_struct.

INDEXES for disjunction [2]
1. Quality 0.9
    [] - []
    [list] - [9]
    [[]] - [8]
    [structure] - []
    [structure, foo / 1] - [10]
    [atom] - []
    [atom, hello] - [7]
    [breal] - [5]
    [rational] - [4]
    [bignum] - [2]
    [integer] - []
    [integer, 1] - [1]
    [string] - [6]
    [double] - [3]
p / 1:
label(L0):
	allocate                 0 
	switch_on_type           a(1) 
		meta: 	ref(fail)
		[]: 	ref(L16)
		atom: 	ref(L14)
		bignum: 	ref(L4)
		breal: 	ref(L10)
		double: 	ref(L6)
		goal: 	ref(fail)
		handle: 	ref(fail)
		integer: 	ref(L2)
		list: 	ref(L18)
		rational: 	ref(L8)
		string: 	ref(L12)
		structure: 	ref(L21)

	branch                   ref(fail) 
label(L1):
	try_me_else              0     1     ref(L3) 
label(L2):
	in_get_integer           a(1)     1 
	callf                    p_integer / 0     Y[] 
	branch                   ref(L23) 
label(L3):
	retry_me_inline          0     ref(L5)     Y[] 
label(L4):
	in_get_constant          a(1)     10000000000000000000 
	callf                    p_big / 0     Y[] 
	branch                   ref(L23) 
label(L5):
	retry_me_inline          0     ref(L7)     Y[] 
label(L6):
	in_get_constant          a(1)     1.1 
	callf                    p_float / 0     Y[] 
	branch                   ref(L23) 
label(L7):
	retry_me_inline          0     ref(L9)     Y[] 
label(L8):
	in_get_constant          a(1)     5_2 
	callf                    p_rational / 0     Y[] 
	branch                   ref(L23) 
label(L9):
	retry_me_inline          0     ref(L11)     Y[] 
label(L10):
	in_get_constant          a(1)     0.9__1.1 
	callf                    p_breal / 0     Y[] 
	branch                   ref(L23) 
label(L11):
	retry_me_inline          0     ref(L13)     Y[] 
label(L12):
	in_get_string            a(1)     "hello" 
	callf                    p_string / 0     Y[] 
	branch                   ref(L23) 
label(L13):
	retry_me_inline          0     ref(L15)     Y[] 
label(L14):
	in_get_atom              a(1)     hello 
	callf                    p_atom / 0     Y[] 
	branch                   ref(L23) 
label(L15):
	retry_me_inline          0     ref(L17)     Y[] 
label(L16):
	in_get_nil               a(1) 
	callf                    p_nil / 0     Y[] 
	branch                   ref(L23) 
label(L17):
	retry_me_inline          0     ref(L20)     Y[] 
label(L18):
	in_get_list              a(1)     ref(L19) 
label(L19):
	callf                    p_list / 0     Y[] 
	branch                   ref(L23) 
label(L20):
	trust_me_inline          0     Y[] 
label(L21):
	in_get_structure         a(1)     foo / 1     ref(L22) 
label(L22):
	read_test_var        
	read_atom                bar 
	callf                    p_struct / 0     Y[] 
label(L23):
	exit                 

------ Test idx(200) -------
p(A, B, C) :-
	var(A),
	!,
	B = C.
p(a, A, B) :-
	!,
	a(A, B).
p(A, B, C) :-
	q(A, B, C).

INDEXES for disjunction [2]
1. Quality 1.0
    [] - [3]
    [atom] - [3]
    [atom, a] - [2]
    [var] - [1]
p / 3:
label(L0):
	allocate                 1 
	savecut                  y(1) 
label(L1):
	atom_switch              a(1) 
		a: 	ref(L5)
		default: 	ref(L7)

	branch                   ref(L3) 
label(L2):
	try_me_else              0     3     ref(L4) 
label(L3):
	bi_var                   a(1) 
	cut                      y(1)     1 
	get_value                a(2)     a(3) 
	branch                   ref(L8) 
label(L4):
	retry_me_inline          0     ref(L6)     Y[1] 
label(L5):
	get_atom                 a(1)     a 
	cut                      y(1)     1 
	move                     a(2)     a(1) 
	move                     a(3)     a(2) 
	callf                    a / 2     Y[] 
	branch                   ref(L8) 
label(L6):
	trust_me_inline          0     Y[] 
label(L7):
	callf                    q / 3     Y[] 
label(L8):
	exit                 

------ Test head(100) -------
p(a) :-
	q.

p / 1:
label(L0):
	get_atom                 a(1)     a 
	jmp                      q / 0 

------ Test head(101) -------
p(a, A, 3) :-
	q.

p / 3:
label(L0):
	get_atom                 a(1)     a 
	get_integer              a(3)     3 
	jmp                      q / 0 

------ Test head(102) -------
p(A, A) :-
	q.

p / 2:
label(L0):
	get_value                a(2)     a(1) 
	jmp                      q / 0 

------ Test head(103) -------
p(a, A, B, 3.5, 5_2, "hello", A) :-
	q.

p / 7:
label(L0):
	get_atom                 a(1)     a 
	get_constant             a(4)     3.5 
	get_constant             a(5)     5_2 
	get_string               a(6)     "hello" 
	get_value                a(7)     a(2) 
	jmp                      q / 0 

------ Test head(1) -------
p(f(1)) :-
	q.

p / 1:
label(L0):
	get_structure            a(1)     f / 1     ref(L1) 
	write_integer            1 
	branch                   ref(L2) 
label(L1):
	read_integer             1 
label(L2):
	jmp                      q / 0 

------ Test head(2) -------
p(f(1, 2)) :-
	q.

p / 1:
label(L0):
	get_structure            a(1)     f / 2     ref(L1) 
	write_integer            1 
	write_integer            2 
	branch                   ref(L2) 
label(L1):
	read_integer             1 
	read_integer             2 
label(L2):
	jmp                      q / 0 

------ Test head(3) -------
p(f(g(1))) :-
	q.

p / 1:
label(L0):
	get_structure            a(1)     f / 1     ref(L2) 
	write_structure          g / 1 
label(L1):
	write_integer            1 
	branch                   ref(L3) 
label(L2):
	read_last_structure      g / 1     ref(L1) 
	read_integer             1 
label(L3):
	jmp                      q / 0 

------ Test head(4) -------
p(f(g(1), h(2))) :-
	q.

p / 1:
label(L0):
	get_structure            a(1)     f / 2     ref(L3) 
	first                
	write_structure          g / 1 
label(L1):
	write_integer            1 
	mode                     t(0)     ref(L4) 
	write_structure          h / 1 
label(L2):
	write_integer            2 
	branch                   ref(L5) 
label(L3):
	read_structure           g / 1     ref(L1) 
	read_integer             1 
	mode                     t(0) 
label(L4):
	read_last_structure      h / 1     ref(L2) 
	read_integer             2 
label(L5):
	space                    -1 
	jmp                      q / 0 

------ Test head(5) -------
p(f(g(1), h(2), i(3))) :-
	q.

p / 1:
label(L0):
	get_structure            a(1)     f / 3     ref(L4) 
	first                
	write_structure          g / 1 
label(L1):
	write_integer            1 
	next                     t(0)     ref(L5) 
	write_structure          h / 1 
label(L2):
	write_integer            2 
	mode                     t(0)     ref(L6) 
	write_structure          i / 1 
label(L3):
	write_integer            3 
	branch                   ref(L7) 
label(L4):
	read_structure           g / 1     ref(L1) 
	read_integer             1 
label(L5):
	read_next_structure      h / 1     t(0)     ref(L2) 
	read_integer             2 
	mode                     t(0) 
label(L6):
	read_last_structure      i / 1     ref(L3) 
	read_integer             3 
label(L7):
	space                    -1 
	jmp                      q / 0 

------ Test head(6) -------
p(f(4, g(1), h(2), i(3))) :-
	q.

p / 1:
label(L0):
	get_structure            a(1)     f / 4     ref(L4) 
	write_integer            4 
	first                
	write_structure          g / 1 
label(L1):
	write_integer            1 
	next                     t(0)     ref(L5) 
	write_structure          h / 1 
label(L2):
	write_integer            2 
	mode                     t(0)     ref(L6) 
	write_structure          i / 1 
label(L3):
	write_integer            3 
	branch                   ref(L7) 
label(L4):
	read_integer             4 
	read_structure           g / 1     ref(L1) 
	read_integer             1 
label(L5):
	read_next_structure      h / 1     t(0)     ref(L2) 
	read_integer             2 
	mode                     t(0) 
label(L6):
	read_last_structure      i / 1     ref(L3) 
	read_integer             3 
label(L7):
	space                    -1 
	jmp                      q / 0 

------ Test head(7) -------
p(f(4, g(1), 5, h(2), i(3))) :-
	q.

p / 1:
label(L0):
	get_structure            a(1)     f / 5     ref(L4) 
	write_integer            4 
	first                
	write_structure          g / 1 
label(L1):
	write_integer            1 
	mode                     t(0)     ref(L5) 
	write_integer            5 
	next                     t(0) 
	write_structure          h / 1 
label(L2):
	write_integer            2 
	mode                     t(0)     ref(L6) 
	write_structure          i / 1 
label(L3):
	write_integer            3 
	branch                   ref(L7) 
label(L4):
	read_integer             4 
	read_structure           g / 1     ref(L1) 
	read_integer             1 
	mode                     t(0) 
label(L5):
	read_integer             5 
	read_structure           h / 1     t(0)     ref(L2) 
	read_integer             2 
	mode                     t(0) 
label(L6):
	read_last_structure      i / 1     ref(L3) 
	read_integer             3 
label(L7):
	space                    -1 
	jmp                      q / 0 

------ Test head(8) -------
p(f(4, g(1), 5, h(2), 6, i(3))) :-
	q.

p / 1:
label(L0):
	get_structure            a(1)     f / 6     ref(L4) 
	write_integer            4 
	first                
	write_structure          g / 1 
label(L1):
	write_integer            1 
	mode                     t(0)     ref(L5) 
	write_integer            5 
	next                     t(0) 
	write_structure          h / 1 
label(L2):
	write_integer            2 
	mode                     t(0)     ref(L6) 
	write_integer            6 
	write_structure          i / 1 
label(L3):
	write_integer            3 
	branch                   ref(L7) 
label(L4):
	read_integer             4 
	read_structure           g / 1     ref(L1) 
	read_integer             1 
	mode                     t(0) 
label(L5):
	read_integer             5 
	read_structure           h / 1     t(0)     ref(L2) 
	read_integer             2 
	mode                     t(0) 
label(L6):
	read_integer             6 
	read_last_structure      i / 1     ref(L3) 
	read_integer             3 
label(L7):
	space                    -1 
	jmp                      q / 0 

------ Test head(9) -------
p(f(4, g(1), 5, h(2), 6, i(3), 7)) :-
	q.

p / 1:
label(L0):
	get_structure            a(1)     f / 7     ref(L4) 
	write_integer            4 
	first                
	write_structure          g / 1 
label(L1):
	write_integer            1 
	mode                     t(0)     ref(L5) 
	write_integer            5 
	next                     t(0) 
	write_structure          h / 1 
label(L2):
	write_integer            2 
	mode                     t(0)     ref(L6) 
	write_integer            6 
	next                     t(0) 
	write_structure          i / 1 
label(L3):
	write_integer            3 
	mode                     t(0)     ref(L7) 
	write_integer            7 
	branch                   ref(L8) 
label(L4):
	read_integer             4 
	read_structure           g / 1     ref(L1) 
	read_integer             1 
	mode                     t(0) 
label(L5):
	read_integer             5 
	read_structure           h / 1     t(0)     ref(L2) 
	read_integer             2 
	mode                     t(0) 
label(L6):
	read_integer             6 
	read_structure           i / 1     t(0)     ref(L3) 
	read_integer             3 
	mode                     t(0) 
label(L7):
	read_integer             7 
label(L8):
	space                    -1 
	jmp                      q / 0 

------ Test head(10) -------
p(f(4, g(1), 5, h(2), 6, i(3), 7)) :-
	q.

p / 1:
label(L0):
	get_structure            a(1)     f / 7     ref(L4) 
	write_integer            4 
	first                
	write_structure          g / 1 
label(L1):
	write_integer            1 
	mode                     t(0)     ref(L5) 
	write_integer            5 
	next                     t(0) 
	write_structure          h / 1 
label(L2):
	write_integer            2 
	mode                     t(0)     ref(L6) 
	write_integer            6 
	next                     t(0) 
	write_structure          i / 1 
label(L3):
	write_integer            3 
	mode                     t(0)     ref(L7) 
	write_integer            7 
	branch                   ref(L8) 
label(L4):
	read_integer             4 
	read_structure           g / 1     ref(L1) 
	read_integer             1 
	mode                     t(0) 
label(L5):
	read_integer             5 
	read_structure           h / 1     t(0)     ref(L2) 
	read_integer             2 
	mode                     t(0) 
label(L6):
	read_integer             6 
	read_structure           i / 1     t(0)     ref(L3) 
	read_integer             3 
	mode                     t(0) 
label(L7):
	read_integer             7 
label(L8):
	space                    -1 
	jmp                      q / 0 

------ Test head(11) -------
p(f(4, g(1), 5, h(2), 6, i(3), 7, 8)) :-
	q.

p / 1:
label(L0):
	get_structure            a(1)     f / 8     ref(L4) 
	write_integer            4 
	first                
	write_structure          g / 1 
label(L1):
	write_integer            1 
	mode                     t(0)     ref(L5) 
	write_integer            5 
	next                     t(0) 
	write_structure          h / 1 
label(L2):
	write_integer            2 
	mode                     t(0)     ref(L6) 
	write_integer            6 
	next                     t(0) 
	write_structure          i / 1 
label(L3):
	write_integer            3 
	mode                     t(0)     ref(L7) 
	write_integer            7 
	write_integer            8 
	branch                   ref(L8) 
label(L4):
	read_integer             4 
	read_structure           g / 1     ref(L1) 
	read_integer             1 
	mode                     t(0) 
label(L5):
	read_integer             5 
	read_structure           h / 1     t(0)     ref(L2) 
	read_integer             2 
	mode                     t(0) 
label(L6):
	read_integer             6 
	read_structure           i / 1     t(0)     ref(L3) 
	read_integer             3 
	mode                     t(0) 
label(L7):
	read_integer             7 
	read_integer             8 
label(L8):
	space                    -1 
	jmp                      q / 0 

------ Test head(12) -------
p(f(g(1), 5, h(2), 6, i(3), 7, 8)) :-
	q.

p / 1:
label(L0):
	get_structure            a(1)     f / 7     ref(L4) 
	first                
	write_structure          g / 1 
label(L1):
	write_integer            1 
	mode                     t(0)     ref(L5) 
	write_integer            5 
	next                     t(0) 
	write_structure          h / 1 
label(L2):
	write_integer            2 
	mode                     t(0)     ref(L6) 
	write_integer            6 
	next                     t(0) 
	write_structure          i / 1 
label(L3):
	write_integer            3 
	mode                     t(0)     ref(L7) 
	write_integer            7 
	write_integer            8 
	branch                   ref(L8) 
label(L4):
	read_structure           g / 1     ref(L1) 
	read_integer             1 
	mode                     t(0) 
label(L5):
	read_integer             5 
	read_structure           h / 1     t(0)     ref(L2) 
	read_integer             2 
	mode                     t(0) 
label(L6):
	read_integer             6 
	read_structure           i / 1     t(0)     ref(L3) 
	read_integer             3 
	mode                     t(0) 
label(L7):
	read_integer             7 
	read_integer             8 
label(L8):
	space                    -1 
	jmp                      q / 0 

------ Test head(13) -------
p(f(g(1), h(2), 6, i(3), 7, 8)) :-
	q.

p / 1:
label(L0):
	get_structure            a(1)     f / 6     ref(L4) 
	first                
	write_structure          g / 1 
label(L1):
	write_integer            1 
	next                     t(0)     ref(L5) 
	write_structure          h / 1 
label(L2):
	write_integer            2 
	mode                     t(0)     ref(L6) 
	write_integer            6 
	next                     t(0) 
	write_structure          i / 1 
label(L3):
	write_integer            3 
	mode                     t(0)     ref(L7) 
	write_integer            7 
	write_integer            8 
	branch                   ref(L8) 
label(L4):
	read_structure           g / 1     ref(L1) 
	read_integer             1 
label(L5):
	read_next_structure      h / 1     t(0)     ref(L2) 
	read_integer             2 
	mode                     t(0) 
label(L6):
	read_integer             6 
	read_structure           i / 1     t(0)     ref(L3) 
	read_integer             3 
	mode                     t(0) 
label(L7):
	read_integer             7 
	read_integer             8 
label(L8):
	space                    -1 
	jmp                      q / 0 

------ Test head(14) -------
p(f(g(1), h(2), i(3), 7, 8)) :-
	q.

p / 1:
label(L0):
	get_structure            a(1)     f / 5     ref(L4) 
	first                
	write_structure          g / 1 
label(L1):
	write_integer            1 
	next                     t(0)     ref(L5) 
	write_structure          h / 1 
label(L2):
	write_integer            2 
	next                     t(0)     ref(L6) 
	write_structure          i / 1 
label(L3):
	write_integer            3 
	mode                     t(0)     ref(L7) 
	write_integer            7 
	write_integer            8 
	branch                   ref(L8) 
label(L4):
	read_structure           g / 1     ref(L1) 
	read_integer             1 
label(L5):
	read_next_structure      h / 1     t(0)     ref(L2) 
	read_integer             2 
label(L6):
	read_next_structure      i / 1     t(0)     ref(L3) 
	read_integer             3 
	mode                     t(0) 
label(L7):
	read_integer             7 
	read_integer             8 
label(L8):
	space                    -1 
	jmp                      q / 0 

------ Test head(15) -------
p(f(g(1), h(2), i(3), 8)) :-
	q.

p / 1:
label(L0):
	get_structure            a(1)     f / 4     ref(L4) 
	first                
	write_structure          g / 1 
label(L1):
	write_integer            1 
	next                     t(0)     ref(L5) 
	write_structure          h / 1 
label(L2):
	write_integer            2 
	next                     t(0)     ref(L6) 
	write_structure          i / 1 
label(L3):
	write_integer            3 
	mode                     t(0)     ref(L7) 
	write_integer            8 
	branch                   ref(L8) 
label(L4):
	read_structure           g / 1     ref(L1) 
	read_integer             1 
label(L5):
	read_next_structure      h / 1     t(0)     ref(L2) 
	read_integer             2 
label(L6):
	read_next_structure      i / 1     t(0)     ref(L3) 
	read_integer             3 
	mode                     t(0) 
label(L7):
	read_integer             8 
label(L8):
	space                    -1 
	jmp                      q / 0 

------ Test head(16) -------
p(A, B) :-
	A = f(B, C),
	q(A, C).

p / 2:
label(L0):
	get_structure            a(1)     f / 2     ref(L1) 
	write_local_value        a(2) 
	write_variable           a(2) 
	branch                   ref(L2) 
label(L1):
	read_value               a(2) 
	read_variable            a(2) 
label(L2):
	jmp                      q / 2 

------ Test head(17) -------
p(A, B) :-
	A = f(C, B),
	q(A, C).

p / 2:
label(L0):
	get_structure            a(1)     f / 2     ref(L1) 
	move                     a(2)     a(3) 
	write_variable           a(2) 
	write_local_value        a(3) 
	branch                   ref(L2) 
label(L1):
	move                     a(2)     a(3) 
	read_variable            a(2) 
	read_value               a(3) 
label(L2):
	jmp                      q / 2 

------ Test head(18) -------
p(A, B) :-
	A = f(g(B), C),
	q(A, C).

p / 2:
label(L0):
	get_structure            a(1)     f / 2     ref(L2) 
	first                
	write_structure          g / 1 
label(L1):
	write_local_value        a(2) 
	mode                     t(0)     ref(L3) 
	write_variable           a(2) 
	branch                   ref(L4) 
label(L2):
	read_structure           g / 1     ref(L1) 
	read_value               a(2) 
	mode                     t(0) 
label(L3):
	read_variable            a(2) 
label(L4):
	space                    -1 
	jmp                      q / 2 

------ Test head(19) -------
p(f(A)) :-
	q,
	r(A).

p / 1:
label(L0):
	allocate                 1 
	get_structure            a(1)     f / 1     ref(L1) 
	write_variable           y(1) 
	branch                   ref(L2) 
label(L1):
	read_variable            y(1) 
label(L2):
	callf                    q / 0     Y[1] 
	move                     y(1)     a(1) 
	chain                    r / 1 

------ Test head(20) -------
p(f(A, A)) :-
	q,
	r(A).

p / 1:
label(L0):
	allocate                 1 
	get_structure            a(1)     f / 2     ref(L1) 
	write_variable           y(1) 
	write_local_value        y(1) 
	branch                   ref(L2) 
label(L1):
	read_variable            y(1) 
	read_value               y(1) 
label(L2):
	callf                    q / 0     Y[1] 
	move                     y(1)     a(1) 
	chain                    r / 1 

------ Test head(20) -------
p([g(1), h(2)]) :-
	q.

p / 1:
label(L0):
	get_list                 a(1)     ref(L4) 
	first                
	write_structure          g / 1 
label(L1):
	write_integer            1 
	mode                     t(0)     ref(L5) 
	write_list           
label(L2):
	first                
	write_structure          h / 1 
label(L3):
	write_integer            2 
	mode                     t(0)     ref(L6) 
	write_nil            
	branch                   ref(L7) 
label(L4):
	read_structure           g / 1     ref(L1) 
	read_integer             1 
	mode                     t(0) 
label(L5):
	read_last_list           ref(L2) 
	read_structure           h / 1     ref(L3) 
	read_integer             2 
	mode                     t(0) 
label(L6):
	read_nil             
label(L7):
	space                    -2 
	jmp                      q / 0 

------ Test head(21) -------
p([[1, 2], [3|A], [4, 5], c]) :-
	q(A).

p / 1:
label(L0):
	get_list                 a(1)     ref(L9) 
	first                
	write_list           
label(L1):
	write_integer            1 
	write_list           
label(L2):
	write_integer            2 
	write_nil            
	mode                     t(0)     ref(L10) 
	write_list           
label(L3):
	first                
	write_list           
label(L4):
	write_integer            3 
	write_variable           a(1) 
	mode                     t(0)     ref(L11) 
	write_list           
label(L5):
	first                
	write_list           
label(L6):
	write_integer            4 
	write_list           
label(L7):
	write_integer            5 
	write_nil            
	mode                     t(0)     ref(L12) 
	write_list           
label(L8):
	write_atom               c 
	write_nil            
	branch                   ref(L13) 
label(L9):
	read_list                ref(L1) 
	read_integer             1 
	read_last_list           ref(L2) 
	read_integer             2 
	read_nil             
	mode                     t(0) 
label(L10):
	read_last_list           ref(L3) 
	read_list                ref(L4) 
	read_integer             3 
	read_variable            a(1) 
	mode                     t(0) 
label(L11):
	read_last_list           ref(L5) 
	read_list                ref(L6) 
	read_integer             4 
	read_last_list           ref(L7) 
	read_integer             5 
	read_nil             
	mode                     t(0) 
label(L12):
	read_last_list           ref(L8) 
	read_atom                c 
	read_nil             
label(L13):
	space                    -3 
	jmp                      q / 1 

------ Test head(22) -------
p([a, [1, 2], [3, 4], b, [5|A], c]) :-
	q(A).

p / 1:
label(L0):
	get_list                 a(1)     ref(L11) 
	write_atom               a 
	write_list           
label(L1):
	first                
	write_list           
label(L2):
	write_integer            1 
	write_list           
label(L3):
	write_integer            2 
	write_nil            
	mode                     t(0)     ref(L12) 
	write_list           
label(L4):
	first                
	write_list           
label(L5):
	write_integer            3 
	write_list           
label(L6):
	write_integer            4 
	write_nil            
	mode                     t(0)     ref(L13) 
	write_list           
label(L7):
	write_atom               b 
	write_list           
label(L8):
	first                
	write_list           
label(L9):
	write_integer            5 
	write_variable           a(1) 
	mode                     t(0)     ref(L14) 
	write_list           
label(L10):
	write_atom               c 
	write_nil            
	branch                   ref(L15) 
label(L11):
	read_atom                a 
	read_last_list           ref(L1) 
	read_list                ref(L2) 
	read_integer             1 
	read_last_list           ref(L3) 
	read_integer             2 
	read_nil             
	mode                     t(0) 
label(L12):
	read_last_list           ref(L4) 
	read_list                ref(L5) 
	read_integer             3 
	read_last_list           ref(L6) 
	read_integer             4 
	read_nil             
	mode                     t(0) 
label(L13):
	read_last_list           ref(L7) 
	read_atom                b 
	read_last_list           ref(L8) 
	read_list                ref(L9) 
	read_integer             5 
	read_variable            a(1) 
	mode                     t(0) 
label(L14):
	read_last_list           ref(L10) 
	read_atom                c 
	read_nil             
label(L15):
	space                    -3 
	jmp                      q / 1 

------ Test head(23) -------
p([a, [1, 2], [3, 4], b, [5|A]|c]) :-
	q(A).

p / 1:
label(L0):
	get_list                 a(1)     ref(L10) 
	write_atom               a 
	write_list           
label(L1):
	first                
	write_list           
label(L2):
	write_integer            1 
	write_list           
label(L3):
	write_integer            2 
	write_nil            
	mode                     t(0)     ref(L11) 
	write_list           
label(L4):
	first                
	write_list           
label(L5):
	write_integer            3 
	write_list           
label(L6):
	write_integer            4 
	write_nil            
	mode                     t(0)     ref(L12) 
	write_list           
label(L7):
	write_atom               b 
	write_list           
label(L8):
	first                
	write_list           
label(L9):
	write_integer            5 
	write_variable           a(1) 
	mode                     t(0)     ref(L13) 
	write_atom               c 
	branch                   ref(L14) 
label(L10):
	read_atom                a 
	read_last_list           ref(L1) 
	read_list                ref(L2) 
	read_integer             1 
	read_last_list           ref(L3) 
	read_integer             2 
	read_nil             
	mode                     t(0) 
label(L11):
	read_last_list           ref(L4) 
	read_list                ref(L5) 
	read_integer             3 
	read_last_list           ref(L6) 
	read_integer             4 
	read_nil             
	mode                     t(0) 
label(L12):
	read_last_list           ref(L7) 
	read_atom                b 
	read_last_list           ref(L8) 
	read_list                ref(L9) 
	read_integer             5 
	read_variable            a(1) 
	mode                     t(0) 
label(L13):
	read_atom                c 
label(L14):
	space                    -3 
	jmp                      q / 1 

------ Test head(24) -------
p([a, [1, 2], [3, 4], b, [5|A]]) :-
	q(A).

p / 1:
label(L0):
	get_list                 a(1)     ref(L10) 
	write_atom               a 
	write_list           
label(L1):
	first                
	write_list           
label(L2):
	write_integer            1 
	write_list           
label(L3):
	write_integer            2 
	write_nil            
	mode                     t(0)     ref(L11) 
	write_list           
label(L4):
	first                
	write_list           
label(L5):
	write_integer            3 
	write_list           
label(L6):
	write_integer            4 
	write_nil            
	mode                     t(0)     ref(L12) 
	write_list           
label(L7):
	write_atom               b 
	write_list           
label(L8):
	first                
	write_list           
label(L9):
	write_integer            5 
	write_variable           a(1) 
	mode                     t(0)     ref(L13) 
	write_nil            
	branch                   ref(L14) 
label(L10):
	read_atom                a 
	read_last_list           ref(L1) 
	read_list                ref(L2) 
	read_integer             1 
	read_last_list           ref(L3) 
	read_integer             2 
	read_nil             
	mode                     t(0) 
label(L11):
	read_last_list           ref(L4) 
	read_list                ref(L5) 
	read_integer             3 
	read_last_list           ref(L6) 
	read_integer             4 
	read_nil             
	mode                     t(0) 
label(L12):
	read_last_list           ref(L7) 
	read_atom                b 
	read_last_list           ref(L8) 
	read_list                ref(L9) 
	read_integer             5 
	read_variable            a(1) 
	mode                     t(0) 
label(L13):
	read_nil             
label(L14):
	space                    -3 
	jmp                      q / 1 

------ Test head(30) -------
p(f([1, 2], [3|A], c)) :-
	q(A).

p / 1:
label(L0):
	get_structure            a(1)     f / 3     ref(L4) 
	first                
	write_list           
label(L1):
	write_integer            1 
	write_list           
label(L2):
	write_integer            2 
	write_nil            
	next                     t(0)     ref(L5) 
	write_list           
label(L3):
	write_integer            3 
	write_variable           a(1) 
	mode                     t(0)     ref(L6) 
	write_atom               c 
	branch                   ref(L7) 
label(L4):
	read_list                ref(L1) 
	read_integer             1 
	read_last_list           ref(L2) 
	read_integer             2 
	read_nil             
label(L5):
	read_next_list           t(0)     ref(L3) 
	read_integer             3 
	read_variable            a(1) 
	mode                     t(0) 
label(L6):
	read_atom                c 
label(L7):
	space                    -1 
	jmp                      q / 1 

------ Test head(31) -------
p(f(a, [1, 2], b, [3|A], c)) :-
	q(A).

p / 1:
label(L0):
	get_structure            a(1)     f / 5     ref(L4) 
	write_atom               a 
	first                
	write_list           
label(L1):
	write_integer            1 
	write_list           
label(L2):
	write_integer            2 
	write_nil            
	mode                     t(0)     ref(L5) 
	write_atom               b 
	next                     t(0) 
	write_list           
label(L3):
	write_integer            3 
	write_variable           a(1) 
	mode                     t(0)     ref(L6) 
	write_atom               c 
	branch                   ref(L7) 
label(L4):
	read_atom                a 
	read_list                ref(L1) 
	read_integer             1 
	read_last_list           ref(L2) 
	read_integer             2 
	read_nil             
	mode                     t(0) 
label(L5):
	read_atom                b 
	read_list                t(0)     ref(L3) 
	read_integer             3 
	read_variable            a(1) 
	mode                     t(0) 
label(L6):
	read_atom                c 
label(L7):
	space                    -1 
	jmp                      q / 1 

------ Test head(32) -------
p(f(a, [1, 2], [3|A], c)) :-
	q(A).

p / 1:
label(L0):
	get_structure            a(1)     f / 4     ref(L4) 
	write_atom               a 
	first                
	write_list           
label(L1):
	write_integer            1 
	write_list           
label(L2):
	write_integer            2 
	write_nil            
	next                     t(0)     ref(L5) 
	write_list           
label(L3):
	write_integer            3 
	write_variable           a(1) 
	mode                     t(0)     ref(L6) 
	write_atom               c 
	branch                   ref(L7) 
label(L4):
	read_atom                a 
	read_list                ref(L1) 
	read_integer             1 
	read_last_list           ref(L2) 
	read_integer             2 
	read_nil             
label(L5):
	read_next_list           t(0)     ref(L3) 
	read_integer             3 
	read_variable            a(1) 
	mode                     t(0) 
label(L6):
	read_atom                c 
label(L7):
	space                    -1 
	jmp                      q / 1 

------ Test head(33) -------
p(f(a, [1, 2], b, [3|A])) :-
	q(A).

p / 1:
label(L0):
	get_structure            a(1)     f / 4     ref(L4) 
	write_atom               a 
	first                
	write_list           
label(L1):
	write_integer            1 
	write_list           
label(L2):
	write_integer            2 
	write_nil            
	mode                     t(0)     ref(L5) 
	write_atom               b 
	write_list           
label(L3):
	write_integer            3 
	write_variable           a(1) 
	branch                   ref(L6) 
label(L4):
	read_atom                a 
	read_list                ref(L1) 
	read_integer             1 
	read_last_list           ref(L2) 
	read_integer             2 
	read_nil             
	mode                     t(0) 
label(L5):
	read_atom                b 
	read_last_list           ref(L3) 
	read_integer             3 
	read_variable            a(1) 
label(L6):
	space                    -1 
	jmp                      q / 1 

------ Test head(34) -------
p(f("hello", 3.5, 5_3)) :-
	q.

p / 1:
label(L0):
	get_structure            a(1)     f / 3     ref(L1) 
	write_string             "hello" 
	write_constant           3.5 
	write_constant           5_3 
	branch                   ref(L2) 
label(L1):
	read_string              "hello" 
	read_constant            3.5 
	read_constant            5_3 
label(L2):
	jmp                      q / 0 

------ Test match(1) -------
p(1, 2.3, 3_4, a, "s", []) ?-
	true.

p / 6:
label(L0):
	in_get_integer           a(1)     1 
	in_get_constant          a(2)     2.3 
	in_get_constant          a(3)     3_4 
	in_get_atom              a(4)     a 
	in_get_string            a(5)     "s" 
	in_get_nil               a(6) 
	ret                  

------ Test match(2) -------
p(A, B, C, D, D) ?-
	q(A),
	r(B).

p / 5:
label(L0):
	allocate                 1 
	get_matched_value        a(5)     a(4) 
	move                     a(2)     y(1) 
	callf                    q / 1     Y[1] 
	move                     y(1)     a(1) 
	chain                    r / 1 

------ Test match(3) -------
p(A, A, B, B) ?-
	q(A),
	r(B).

p / 4:
label(L0):
	allocate                 1 
	get_matched_value        a(2)     a(1) 
	get_matched_value        a(4)     a(3) 
	move                     a(3)     y(1) 
	callf                    q / 1     Y[1] 
	move                     y(1)     a(1) 
	chain                    r / 1 

------ Test match(4) -------
p(foo(bar(1), A, baz(2))) ?-
	true.

p / 1:
label(L0):
	in_get_structure         a(1)     foo / 3     ref(L1) 
label(L1):
	read_test_var        
	read_structure           bar / 1     ref(fail) 
	read_test_var        
	read_integer             1 
	mode                     t(0) 
label(L2):
	read_void            
	read_test_var        
	read_last_structure      baz / 1     ref(fail) 
	read_test_var        
	read_integer             2 
	space                    -1 
	ret                  

------ Test match(5) -------
p([1, 2, [3, 4]]) ?-
	true.

p / 1:
label(L0):
	in_get_list              a(1)     ref(L1) 
label(L1):
	read_test_var        
	read_integer             1 
	read_test_var        
	read_last_list           ref(fail) 
	read_test_var        
	read_integer             2 
	read_test_var        
	read_last_list           ref(fail) 
	read_test_var        
	read_list                ref(fail) 
	read_test_var        
	read_integer             3 
	read_test_var        
	read_last_list           ref(fail) 
	read_test_var        
	read_integer             4 
	read_test_var        
	read_nil             
	mode                     t(0) 
label(L2):
	read_test_var        
	read_nil             
	space                    -1 
	ret                  

------ Test match(6) -------
p(foo(A, A)) ?-
	true.

p / 1:
label(L0):
	in_get_structure         a(1)     foo / 2     ref(L1) 
label(L1):
	read_variable            a(1) 
	read_matched_value       a(1) 
	ret                  

------ Test match(7) -------
p(foo(A, A, B, B)) ?-
	q(A),
	r(B).

p / 1:
label(L0):
	allocate                 1 
	in_get_structure         a(1)     foo / 4     ref(L1) 
label(L1):
	read_variable            a(1) 
	read_matched_value       a(1) 
	read_variable            y(1) 
	read_matched_value       y(1) 
	callf                    q / 1     Y[1] 
	move                     y(1)     a(1) 
	chain                    r / 1 

------ Test match(8) -------
p(A, foo(A, B), B) ?-
	true.

p / 3:
label(L0):
	in_get_structure         a(2)     foo / 2     ref(L1) 
label(L1):
	read_matched_value       a(1) 
	read_matched_value       a(3) 
	ret                  

------ Test match(9) -------
p(A, foo(A, B), B) ?-
	p(A),
	r(B).

p / 3:
label(L0):
	allocate                 1 
	in_get_structure         a(2)     foo / 2     ref(L1) 
label(L1):
	read_matched_value       a(1) 
	read_matched_value       a(3) 
	move                     a(3)     y(1) 
	callf                    p / 1     Y[1] 
	move                     y(1)     a(1) 
	chain                    r / 1 

------ Test match(10) -------
p(A) ?-
	p(A, B).

p / 1:
label(L0):
	in_get_meta              a(1)     ref(fail) 
	read_void            
	read_attribute           suspend 
	read_variable            a(2) 
	jmp                      p / 2 

------ Test match(11) -------
p(A) ?-
	p(a, A, B).

p / 1:
label(L0):
	in_get_meta              a(1)     ref(fail) 
	read_void            
	read_attribute           suspend 
	read_variable            a(3) 
	move                     a(1)     a(2) 
	put_atom                 a(1)     a 
	jmp                      p / 3 

------ Test match(12) -------
p(A, A) ?-
	p(a, b, A, B).

p / 2:
label(L0):
	in_get_meta              a(1)     ref(fail) 
	read_void            
	read_attribute           suspend 
	read_variable            a(4) 
	get_matched_value        a(2)     a(1) 
	move                     a(1)     a(3) 
	put_atom                 a(1)     a 
	put_atom                 a(2)     b 
	jmp                      p / 4 

------ Test match(13) -------
p(A) ?-
	q,
	p(A, B).

p / 1:
label(L0):
	allocate                 2 
	in_get_meta              a(1)     ref(fail) 
	read_void            
	read_attribute           suspend 
	read_variable            y(2) 
	move                     a(1)     y(1) 
	callf                    q / 0     Y[1,2] 
	move                     2     y(1)     a(1) 
	chain                    p / 2 

------ Test match(14) -------
p(A, A) ?-
	q,
	p(A, B).

p / 2:
label(L0):
	allocate                 2 
	in_get_meta              a(1)     ref(fail) 
	read_void            
	read_attribute           suspend 
	read_variable            y(2) 
	get_matched_value        a(2)     a(1) 
	move                     a(1)     y(1) 
	callf                    q / 0     Y[1,2] 
	move                     2     y(1)     a(1) 
	chain                    ref(L0) 

------ Test match(20) -------
p(f(A)) ?-
	p(A, B).

p / 1:
label(L0):
	in_get_structure         a(1)     f / 1     ref(L1) 
label(L1):
	match_last_meta      
	read_variable            a(1) 
	read_attribute           suspend 
	read_variable            a(2) 
	jmp                      p / 2 

------ Test match(21) -------
p(f(a, A)) ?-
	p(A, B).

p / 1:
label(L0):
	in_get_structure         a(1)     f / 2     ref(L1) 
label(L1):
	read_test_var        
	read_atom                a 
	match_last_meta      
	read_variable            a(1) 
	read_attribute           suspend 
	read_variable            a(2) 
	jmp                      p / 2 

------ Test match(22) -------
p(f(a, A, c)) ?-
	p(A, B).

p / 1:
label(L0):
	in_get_structure         a(1)     f / 3     ref(L1) 
label(L1):
	read_test_var        
	read_atom                a 
	match_meta           
	read_variable            a(1) 
	read_attribute           suspend 
	read_variable            a(2) 
	mode                     t(0) 
label(L2):
	read_test_var        
	read_atom                c 
	space                    -1 
	jmp                      p / 2 

------ Test match(23) -------
p(f(bar(baz), A, c)) ?-
	p(A, B).

p / 1:
label(L0):
	in_get_structure         a(1)     f / 3     ref(L1) 
label(L1):
	read_test_var        
	read_structure           bar / 1     ref(fail) 
	read_test_var        
	read_atom                baz 
	match_next_meta          t(0) 
	read_variable            a(1) 
	read_attribute           suspend 
	read_variable            a(2) 
	mode                     t(0) 
label(L2):
	read_test_var        
	read_atom                c 
	space                    -1 
	jmp                      p / 2 

------ Test match(24) -------
p(f(A, A)) ?-
	p(A, B).

p / 1:
label(L0):
	in_get_structure         a(1)     f / 2     ref(L1) 
label(L1):
	match_meta           
	read_variable            a(1) 
	read_attribute           suspend 
	read_variable            a(2) 
	mode                     t(0) 
label(L2):
	match_last_meta      
	read_matched_value       a(1) 
	read_attribute           suspend 
	read_matched_value       a(2) 
	space                    -1 
	jmp                      p / 2 

------ Test match(25) -------
p(f(bar(baz), a, A, c)) ?-
	p(A, B).

p / 1:
label(L0):
	in_get_structure         a(1)     f / 4     ref(L1) 
label(L1):
	read_test_var        
	read_structure           bar / 1     ref(fail) 
	read_test_var        
	read_atom                baz 
	mode                     t(0) 
label(L2):
	read_test_var        
	read_atom                a 
	match_meta               t(0) 
	read_variable            a(1) 
	read_attribute           suspend 
	read_variable            a(2) 
	mode                     t(0) 
label(L3):
	read_test_var        
	read_atom                c 
	space                    -1 
	jmp                      p / 2 

------ Test match(30) -------
p(A) ?-
	p(A, B).
p(A) :-
	integer(A),
	q(A).

INDEXES for disjunction [2]
1. Quality 1.0
    [] - []
    [var] - []
    [var, meta] - [1]
    [integer] - [2]
    [bignum] - [2]
p / 1:
label(L0):
	allocate                 0 
	switch_on_type           a(1) 
		meta: 	ref(L2)
		[]: 	ref(fail)
		atom: 	ref(fail)
		bignum: 	ref(L4)
		breal: 	ref(fail)
		double: 	ref(fail)
		goal: 	ref(fail)
		handle: 	ref(fail)
		integer: 	ref(L4)
		list: 	ref(fail)
		rational: 	ref(fail)
		string: 	ref(fail)
		structure: 	ref(fail)

	branch                   ref(fail) 
label(L1):
	try_me_else              0     1     ref(L3) 
label(L2):
	in_get_meta              a(1)     ref(fail) 
	read_void            
	read_attribute           suspend 
	read_variable            a(2) 
	callf                    p / 2     Y[] 
	branch                   ref(L5) 
label(L3):
	trust_me_inline          0     Y[] 
label(L4):
	bi_integer               a(1) 
	callf                    q / 1     Y[] 
label(L5):
	exit                 

------ Test match(31) -------
p(A) ?-
	!,
	p(A, B).
p(A) :-
	q(A).

INDEXES for disjunction [2]
1. Quality 1.5
    [] - [2]
    [var] - [2]
    [var, meta] - [1, 2]
p / 1:
label(L0):
	allocate                 1 
	savecut                  y(1) 
	switch_on_type           a(1) 
		meta: 	ref(L1)
		[]: 	ref(L4)
		atom: 	ref(L4)
		bignum: 	ref(L4)
		breal: 	ref(L4)
		double: 	ref(L4)
		goal: 	ref(L4)
		handle: 	ref(L4)
		integer: 	ref(L4)
		list: 	ref(L4)
		rational: 	ref(L4)
		string: 	ref(L4)
		structure: 	ref(L4)

	branch                   ref(L4) 
label(L1):
	try_me_else              0     1     ref(L3) 
label(L2):
	in_get_meta              a(1)     ref(fail) 
	read_void            
	read_attribute           suspend 
	read_variable            a(2) 
	cut                      y(1)     1 
	callf                    p / 2     Y[] 
	branch                   ref(L5) 
label(L3):
	trust_me_inline          0     Y[] 
label(L4):
	callf                    q / 1     Y[] 
label(L5):
	exit                 

------ Test match(32) -------
p(A) ?-
	p(A, B).
p(A) :-
	free(A),
	q(A).

INDEXES for disjunction [2]
1. Quality 1.0
    [] - []
    [var] - []
    [var, free] - [2]
    [var, meta] - [1]
p / 1:
label(L0):
	allocate                 0 
	switch_on_type           a(1) 
		meta: 	ref(L2)
		[]: 	ref(fail)
		atom: 	ref(fail)
		bignum: 	ref(fail)
		breal: 	ref(fail)
		double: 	ref(fail)
		goal: 	ref(fail)
		handle: 	ref(fail)
		integer: 	ref(fail)
		list: 	ref(fail)
		rational: 	ref(fail)
		string: 	ref(fail)
		structure: 	ref(fail)

	branch                   ref(L4) 
label(L1):
	try_me_else              0     1     ref(L3) 
label(L2):
	in_get_meta              a(1)     ref(fail) 
	read_void            
	read_attribute           suspend 
	read_variable            a(2) 
	callf                    p / 2     Y[] 
	branch                   ref(L5) 
label(L3):
	trust_me_inline          0     Y[] 
label(L4):
	bi_free                  a(1) 
	callf                    q / 1     Y[] 
label(L5):
	exit                 

------ Test match(33) -------
p(A) ?-
	p(A, B).
p(A) :-
	meta(A),
	q(A).

INDEXES for disjunction [2]
1. Quality 2.0
    [] - []
    [var] - []
    [var, meta] - [1, 2]
p / 1:
label(L0):
	allocate                 0 
	try_me_else              0     1     ref(L2) 
label(L1):
	in_get_meta              a(1)     ref(fail) 
	read_void            
	read_attribute           suspend 
	read_variable            a(2) 
	callf                    p / 2     Y[] 
	branch                   ref(L4) 
label(L2):
	trust_me_inline          0     Y[] 
label(L3):
	bi_meta                  a(1) 
	callf                    q / 1     Y[] 
label(L4):
	exit                 

------ Test match(34) -------
p(A) :-
	free(A),
	q(A).
p(A) ?-
	p(A, B).

INDEXES for disjunction [2]
1. Quality 1.0
    [] - []
    [var] - []
    [var, free] - [1]
    [var, meta] - [2]
p / 1:
label(L0):
	allocate                 0 
	switch_on_type           a(1) 
		meta: 	ref(L4)
		[]: 	ref(fail)
		atom: 	ref(fail)
		bignum: 	ref(fail)
		breal: 	ref(fail)
		double: 	ref(fail)
		goal: 	ref(fail)
		handle: 	ref(fail)
		integer: 	ref(fail)
		list: 	ref(fail)
		rational: 	ref(fail)
		string: 	ref(fail)
		structure: 	ref(fail)

	branch                   ref(L2) 
label(L1):
	try_me_else              0     1     ref(L3) 
label(L2):
	bi_free                  a(1) 
	callf                    q / 1     Y[] 
	branch                   ref(L5) 
label(L3):
	trust_me_inline          0     Y[] 
label(L4):
	in_get_meta              a(1)     ref(fail) 
	read_void            
	read_attribute           suspend 
	read_variable            a(2) 
	callf                    p / 2     Y[] 
label(L5):
	exit                 

------ Test unify(1) -------
p(A, B, C) :-
	q,
	A = f(1, g(B, D), E, h(C, B)),
	r(C, D),
	s(E).

p / 3:
label(L0):
	allocate                 4 
	move                     3     a(1)     y(2) 
	callf                    q / 0     Y[2,3,4] 
	move                     y(2)     a(3) 
	get_structure            a(3)     f / 4     ref(L3) 
	write_integer            1 
	first                
	write_structure          g / 2 
label(L1):
	write_local_value        y(3) 
	write_variable           a(2) 
	mode                     t(0)     ref(L4) 
	write_variable           y(1) 
	write_structure          h / 2 
label(L2):
	write_local_value        y(4) 
	write_local_value        y(3) 
	branch                   ref(L5) 
label(L3):
	read_integer             1 
	read_structure           g / 2     ref(L1) 
	read_value               y(3) 
	read_variable            a(2) 
	mode                     t(0) 
label(L4):
	read_variable            y(1) 
	read_last_structure      h / 2     ref(L2) 
	read_value               y(4) 
	read_value               y(3) 
label(L5):
	space                    -1 
	move                     y(4)     a(1) 
	callf                    r / 2     Y[1] 
	move                     y(1)     a(1) 
	chain                    s / 1 

------ Test dis(1) -------
p :-
	(
	    a
	;
	    (
		b
	    ;
		(
		    c
		;
		    d
		)
	    )
	).

p / 0:
label(L0):
	allocate                 0 
	try_me_else              0     0     ref(L2) 
label(L1):
	callf                    a / 0     Y[] 
	branch                   ref(L8) 
label(L2):
	retry_me_inline          0     ref(L4)     Y[] 
label(L3):
	callf                    b / 0     Y[] 
	branch                   ref(L8) 
label(L4):
	retry_me_inline          0     ref(L6)     Y[] 
label(L5):
	callf                    c / 0     Y[] 
	branch                   ref(L8) 
label(L6):
	trust_me_inline          0     Y[] 
label(L7):
	callf                    d / 0     Y[] 
label(L8):
	exit                 

------ Test dis(2) -------
p :-
	(
	    (
		(
		    a
		;
		    b
		)
	    ;
		c
	    )
	;
	    d
	).

p / 0:
label(L0):
	allocate                 0 
	try_me_else              0     0     ref(L2) 
label(L1):
	callf                    a / 0     Y[] 
	branch                   ref(L8) 
label(L2):
	retry_me_inline          0     ref(L4)     Y[] 
label(L3):
	callf                    b / 0     Y[] 
	branch                   ref(L8) 
label(L4):
	retry_me_inline          0     ref(L6)     Y[] 
label(L5):
	callf                    c / 0     Y[] 
	branch                   ref(L8) 
label(L6):
	trust_me_inline          0     Y[] 
label(L7):
	callf                    d / 0     Y[] 
label(L8):
	exit                 

------ Test dis(3) -------
p :-
	(
	    a
	;
	    (
		(
		    b
		;
		    c
		)
	    ;
		d
	    )
	).

p / 0:
label(L0):
	allocate                 0 
	try_me_else              0     0     ref(L2) 
label(L1):
	callf                    a / 0     Y[] 
	branch                   ref(L8) 
label(L2):
	retry_me_inline          0     ref(L4)     Y[] 
label(L3):
	callf                    b / 0     Y[] 
	branch                   ref(L8) 
label(L4):
	retry_me_inline          0     ref(L6)     Y[] 
label(L5):
	callf                    c / 0     Y[] 
	branch                   ref(L8) 
label(L6):
	trust_me_inline          0     Y[] 
label(L7):
	callf                    d / 0     Y[] 
label(L8):
	exit                 

------ Test dis(4) -------
p :-
	(
	    a
	->
	    aa
	;
	    b
	).

p / 0:
label(L0):
	allocate                 1 
	savecut                  y(1) 
	try_me_else              0     0     ref(L2) 
label(L1):
	callf                    a / 0     Y[1] 
	cut                      y(1)     1 
	callf                    aa / 0     Y[] 
	branch                   ref(L4) 
label(L2):
	trust_me_inline          0     Y[] 
label(L3):
	callf                    b / 0     Y[] 
label(L4):
	exit                 

------ Test dis(5) -------
p :-
	q,
	(
	    a
	->
	    aa
	;
	    b
	).

p / 0:
label(L0):
	allocate                 1 
	callf                    q / 0     Y[] 
	savecut                  y(1) 
	try_me_else              0     0     ref(L2) 
label(L1):
	callf                    a / 0     Y[1] 
	cut                      y(1)     1 
	callf                    aa / 0     Y[] 
	branch                   ref(L4) 
label(L2):
	trust_me_inline          0     Y[] 
label(L3):
	callf                    b / 0     Y[] 
label(L4):
	exit                 

------ Test dis(6) -------
p :-
	(
	    a
	->
	    aa
	;
	    (
		b
	    ->
		bb
	    ;
		(
		    c
		->
		    cc
		;
		    d
		)
	    )
	).

p / 0:
label(L0):
	allocate                 1 
	savecut                  y(1) 
	try_me_else              0     0     ref(L2) 
label(L1):
	callf                    a / 0     Y[1] 
	cut                      y(1)     1 
	callf                    aa / 0     Y[] 
	branch                   ref(L8) 
label(L2):
	retry_me_inline          0     ref(L4)     Y[1] 
label(L3):
	callf                    b / 0     Y[1] 
	cut                      y(1)     1 
	callf                    bb / 0     Y[] 
	branch                   ref(L8) 
label(L4):
	retry_me_inline          0     ref(L6)     Y[1] 
label(L5):
	callf                    c / 0     Y[1] 
	cut                      y(1)     1 
	callf                    cc / 0     Y[] 
	branch                   ref(L8) 
label(L6):
	trust_me_inline          0     Y[] 
label(L7):
	callf                    d / 0     Y[] 
label(L8):
	exit                 

------ Test dis(7) -------
p :-
	(
	    a
	->
	    aa
	;
	    (
		b
	    ->
		bb
	    ;
		(
		    c
		->
		    cc
		;
		    (
			d
		    ->
			dd
		    )
		)
	    )
	).

p / 0:
label(L0):
	allocate                 2 
	savecut                  y(1) 
	try_me_else              0     0     ref(L2) 
label(L1):
	callf                    a / 0     Y[1] 
	cut                      y(1)     2 
	callf                    aa / 0     Y[] 
	branch                   ref(L8) 
label(L2):
	retry_me_inline          0     ref(L4)     Y[1] 
label(L3):
	callf                    b / 0     Y[1] 
	cut                      y(1)     2 
	callf                    bb / 0     Y[] 
	branch                   ref(L8) 
label(L4):
	retry_me_inline          0     ref(L6)     Y[1] 
label(L5):
	callf                    c / 0     Y[1] 
	cut                      y(1)     2 
	callf                    cc / 0     Y[] 
	branch                   ref(L8) 
label(L6):
	trust_me_inline          0     Y[] 
label(L7):
	savecut                  y(2) 
	callf                    d / 0     Y[2] 
	cut                      y(2)     2 
	callf                    dd / 0     Y[] 
label(L8):
	exit                 

------ Test dis(8) -------
p :-
	(
	    a
	;
	    (
		b
	    ->
		bb
	    ;
		(
		    c
		->
		    cc
		;
		    d
		)
	    )
	).

p / 0:
label(L0):
	allocate                 1 
	savecut                  y(1) 
	try_me_else              0     0     ref(L2) 
label(L1):
	callf                    a / 0     Y[] 
	branch                   ref(L8) 
label(L2):
	retry_me_inline          0     ref(L4)     Y[1] 
label(L3):
	callf                    b / 0     Y[1] 
	cut                      y(1)     1 
	callf                    bb / 0     Y[] 
	branch                   ref(L8) 
label(L4):
	retry_me_inline          0     ref(L6)     Y[1] 
label(L5):
	callf                    c / 0     Y[1] 
	cut                      y(1)     1 
	callf                    cc / 0     Y[] 
	branch                   ref(L8) 
label(L6):
	trust_me_inline          0     Y[] 
label(L7):
	callf                    d / 0     Y[] 
label(L8):
	exit                 

------ Test dis(9) -------
p :-
	(
	    a
	->
	    aa
	;
	    (
		b
	    ;
		(
		    c
		->
		    cc
		;
		    d
		)
	    )
	).

p / 0:
label(L0):
	allocate                 1 
	savecut                  y(1) 
	try_me_else              0     0     ref(L2) 
label(L1):
	callf                    a / 0     Y[1] 
	cut                      y(1)     1 
	callf                    aa / 0     Y[] 
	branch                   ref(L8) 
label(L2):
	retry_me_inline          0     ref(L4)     Y[] 
label(L3):
	callf                    b / 0     Y[] 
	branch                   ref(L8) 
label(L4):
	retry_me_inline          0     ref(L6)     Y[1] 
label(L5):
	callf                    c / 0     Y[1] 
	cut                      y(1)     1 
	callf                    cc / 0     Y[] 
	branch                   ref(L8) 
label(L6):
	trust_me_inline          0     Y[] 
label(L7):
	callf                    d / 0     Y[] 
label(L8):
	exit                 

------ Test dis(10) -------
p :-
	(
	    a
	->
	    aa
	;
	    (
		b
	    ->
		bb
	    ;
		(
		    c
		;
		    d
		)
	    )
	).

p / 0:
label(L0):
	allocate                 1 
	savecut                  y(1) 
	try_me_else              0     0     ref(L2) 
label(L1):
	callf                    a / 0     Y[1] 
	cut                      y(1)     1 
	callf                    aa / 0     Y[] 
	branch                   ref(L8) 
label(L2):
	retry_me_inline          0     ref(L4)     Y[1] 
label(L3):
	callf                    b / 0     Y[1] 
	cut                      y(1)     1 
	callf                    bb / 0     Y[] 
	branch                   ref(L8) 
label(L4):
	retry_me_inline          0     ref(L6)     Y[] 
label(L5):
	callf                    c / 0     Y[] 
	branch                   ref(L8) 
label(L6):
	trust_me_inline          0     Y[] 
label(L7):
	callf                    d / 0     Y[] 
label(L8):
	exit                 

------ Test dis(11) -------
p :-
	(
	    a
	->
	    aa
	;
	    (
		(
		    b
		->
		    bb
		;
		    c
		)
	    ;
		d
	    )
	).

p / 0:
label(L0):
	allocate                 2 
	savecut                  y(1) 
	try_me_else              0     0     ref(L2) 
label(L1):
	callf                    a / 0     Y[1] 
	cut                      y(1)     2 
	callf                    aa / 0     Y[] 
	branch                   ref(L10) 
label(L2):
	retry_me_inline          0     ref(L8)     Y[] 
label(L3):
	savecut                  y(2) 
	try_me_else              0     0     ref(L5) 
label(L4):
	callf                    b / 0     Y[2] 
	cut                      y(2)     2 
	callf                    bb / 0     Y[] 
	branch                   ref(L7) 
label(L5):
	trust_me_inline          0     Y[] 
label(L6):
	callf                    c / 0     Y[] 
label(L7):
	branch                   ref(L10) 
label(L8):
	trust_me_inline          0     Y[] 
label(L9):
	callf                    d / 0     Y[] 
label(L10):
	exit                 

------ Test clause(1) -------
p :-
	a.
p :-
	b.

p / 0:
label(L0):
	allocate                 0 
	try_me_else              0     0     ref(L2) 
label(L1):
	callf                    a / 0     Y[] 
	branch                   ref(L4) 
label(L2):
	trust_me_inline          0     Y[] 
label(L3):
	callf                    b / 0     Y[] 
label(L4):
	exit                 

------ Test clause(2) -------
p :-
	a.
p :-
	b.
p :-
	c,
	d.

p / 0:
label(L0):
	allocate                 0 
	try_me_else              0     0     ref(L2) 
label(L1):
	callf                    a / 0     Y[] 
	branch                   ref(L6) 
label(L2):
	retry_me_inline          0     ref(L4)     Y[] 
label(L3):
	callf                    b / 0     Y[] 
	branch                   ref(L6) 
label(L4):
	trust_me_inline          0     Y[] 
label(L5):
	callf                    c / 0     Y[] 
	callf                    d / 0     Y[] 
label(L6):
	exit                 

------ Test clause(3) -------
p :-
	(
	    a
	->
	    aa
	).
p :-
	b.

p / 0:
label(L0):
	allocate                 1 
	try_me_else              0     0     ref(L2) 
label(L1):
	savecut                  y(1) 
	callf                    a / 0     Y[1] 
	cut                      y(1)     1 
	callf                    aa / 0     Y[] 
	branch                   ref(L4) 
label(L2):
	trust_me_inline          0     Y[] 
label(L3):
	callf                    b / 0     Y[] 
label(L4):
	exit                 

------ Test special(1) -------
p(A) :-
	A.

p / 1:
label(L0):
	put_atom                 a(2)     eclipse 
	jmp                      sepia_kernel : untraced_call / 2 

------ Test special(2) -------
p(A) :-
	call(A).

p / 1:
label(L0):
	put_atom                 a(2)     eclipse 
	jmp                      sepia_kernel : untraced_call / 2 

------ Test special(3) -------
p(A, B) :-
	A @ B.

p / 2:
label(L0):
	jmp                      sepia_kernel : untraced_call / 2 

------ Test special(4) -------
p(A) :-
	A @ lists.

p / 1:
label(L0):
	put_atom                 a(2)     lists 
	jmp                      sepia_kernel : untraced_call / 2 

------ Test special(5) -------
p(A, B) :-
	B : A.

p / 2:
label(L0):
	put_atom                 a(3)     eclipse 
	move                     a(1)     a(4) 
	move                     a(2)     a(1) 
	move                     a(4)     a(2) 
	jmp                      sepia_kernel : '[]:@' / 3 

------ Test special(6) -------
p(A) :-
	lists : A.

p / 1:
label(L0):
	move                     a(1)     a(2) 
	put_atom                 a(1)     lists 
	put_atom                 a(3)     eclipse 
	jmp                      sepia_kernel : '[]:@' / 3 

------ Test special(7) -------
p :-
	3 = 3.

p / 0:
label(L0):
	ret                  

------ Test special(8) -------
p :-
	3 = 4.

p / 0:
label(L0):
	failure              
	ret                  

------ Test special(9) -------
p :-
	call(q).

p / 0:
label(L0):
	jmp                      q / 0 

------ Test special(10) -------
p :-
	q,
	call((a, !, b)),
	r.

p / 0:
label(L0):
	allocate                 1 
	callf                    q / 0     Y[] 
	savecut                  y(1) 
	callf                    a / 0     Y[1] 
	cut                      y(1)     1 
	callf                    b / 0     Y[] 
	chain                    r / 0 

------ Test special(11) -------
p(A) :-
	call(q) @ A.

p / 1:
label(L0):
	move                     a(1)     a(2) 
	put_atom                 a(1)     q 
	jmp                      sepia_kernel : untraced_call / 2 

------ Test special(12) -------
p :-
	call(q) @ lists.

p / 0:
label(L0):
	jmp                      lists : q / 0 

------ Test special(13) -------
p :-
	call(writeln(hello)) @ lists.

p / 0:
label(L0):
	put_atom                 a(1)     hello 
	put_atom                 a(2)     lists 
	jmp                      sepia_kernel : writeln_body / 2 

------ Test special(13) -------
p :-
	writeln(hello) @ lists.

p / 0:
label(L0):
	put_atom                 a(1)     hello 
	put_atom                 a(2)     lists 
	jmp                      sepia_kernel : writeln_body / 2 

------ Test tool(1) -------
p(A) :-
	get_flag(p / 0, definition_module, A).

p / 1:
label(L0):
	move                     a(1)     a(3) 
	put_structure            a(1)     (/) / 2 
	write_atom               p 
	push_integer             0 
	put_atom                 a(2)     definition_module 
	put_atom                 a(4)     eclipse 
	jmp                      sepia_kernel : get_flag_body / 4 

------ Test tool(2) -------
p(A) :-
	get_flag(p / 0, definition_module, A) @ lists.

p / 1:
label(L0):
	move                     a(1)     a(3) 
	put_structure            a(1)     (/) / 2 
	write_atom               p 
	push_integer             0 
	put_atom                 a(2)     definition_module 
	put_atom                 a(4)     lists 
	jmp                      sepia_kernel : get_flag_body / 4 

------ Test tool(3) -------
p(A, B) :-
	get_flag(p / 0, definition_module, B) @ A.

p / 2:
label(L0):
	move                     a(1)     a(4) 
	put_structure            a(1)     (/) / 2 
	write_atom               p 
	push_integer             0 
	move                     a(2)     a(3) 
	put_atom                 a(2)     definition_module 
	jmp                      sepia_kernel : get_flag_body / 4 

------ Test tool(4) -------
p :-
	q @ lists.

p / 0:
label(L0):
	jmp                      q / 0 

------ Test tool(5) -------
p(A) :-
	q @ A.

p / 1:
label(L0):
	jmp                      q / 0 

------ Test cut(1) -------
p :-
	!.

p / 0:
label(L0):
	savecut                  a(1) 
	cut                      a(1) 
	ret                  

------ Test cut(2) -------
p :-
	q,
	!.

p / 0:
label(L0):
	allocate                 1 
	savecut                  y(1) 
	callf                    q / 0     Y[1] 
	cut                      y(1)     1 
	exit                 

------ Test cut(3) -------
p :-
	q,
	!,
	r.

p / 0:
label(L0):
	allocate                 1 
	savecut                  y(1) 
	callf                    q / 0     Y[1] 
	cut                      y(1)     1 
	chain                    r / 0 

------ Test cut(4) -------
p :-
	q,
	!,
	r.
p :-
	s.

p / 0:
label(L0):
	allocate                 1 
	savecut                  y(1) 
	try_me_else              0     0     ref(L2) 
label(L1):
	callf                    q / 0     Y[1] 
	cut                      y(1)     1 
	callf                    r / 0     Y[] 
	branch                   ref(L4) 
label(L2):
	trust_me_inline          0     Y[] 
label(L3):
	callf                    s / 0     Y[] 
label(L4):
	exit                 

------ Test cut(5) -------
p :-
	a.
p :-
	!,
	bb.
p :-
	c,
	d.

p / 0:
label(L0):
	allocate                 1 
	savecut                  y(1) 
	try_me_else              0     0     ref(L2) 
label(L1):
	callf                    a / 0     Y[] 
	branch                   ref(L6) 
label(L2):
	retry_me_inline          0     ref(L4)     Y[1] 
label(L3):
	cut                      y(1)     1 
	callf                    bb / 0     Y[] 
	branch                   ref(L6) 
label(L4):
	trust_me_inline          0     Y[] 
label(L5):
	callf                    c / 0     Y[] 
	callf                    d / 0     Y[] 
label(L6):
	exit                 

------ Test cut(6) -------
p :-
	a.
p :-
	b,
	!,
	bb.
p :-
	c,
	d.

p / 0:
label(L0):
	allocate                 1 
	savecut                  y(1) 
	try_me_else              0     0     ref(L2) 
label(L1):
	callf                    a / 0     Y[] 
	branch                   ref(L6) 
label(L2):
	retry_me_inline          0     ref(L4)     Y[1] 
label(L3):
	callf                    b / 0     Y[1] 
	cut                      y(1)     1 
	callf                    bb / 0     Y[] 
	branch                   ref(L6) 
label(L4):
	trust_me_inline          0     Y[] 
label(L5):
	callf                    c / 0     Y[] 
	callf                    d / 0     Y[] 
label(L6):
	exit                 

------ Test env(1) -------
p :-
	q(A, B, C, D, E, F, G),
	r(H, I, J, K, L, M, N),
	q(A, B, C, D, E, F, G),
	r(H, I, J, K, L, M, N).

p / 0:
label(L0):
	allocate                 14 
	put_global_variable      a(1)     y(8) 
	put_global_variable      a(2)     y(9) 
	put_global_variable      a(3)     y(10) 
	put_global_variable      a(4)     y(11) 
	put_global_variable      a(5)     y(12) 
	put_global_variable      a(6)     y(13) 
	put_global_variable      a(7)     y(14) 
	callf                    q / 7     Y[8,9,10,11,12,13,14] 
	put_global_variable      a(1)     y(1) 
	put_global_variable      a(2)     y(2) 
	put_global_variable      a(3)     y(3) 
	put_global_variable      a(4)     y(4) 
	put_global_variable      a(5)     y(5) 
	put_global_variable      a(6)     y(6) 
	put_global_variable      a(7)     y(7) 
	callf                    r / 7     Y[1,2,3,4,5,6,7,8,9,10,11,12,13,14] 
	move                     7     y(8)     a(1) 
	callf                    q / 7     Y[1,2,3,4,5,6,7] 
	move                     7     y(1)     a(1) 
	chain                    r / 7 

------ Test env(2) -------
p :-
	q(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T),
	r(U, V, W, X, Y, Z, A1, B1, C1, D1, E1, F1, G1, H1, I1, J1, K1, L1, M1, N1),
	s(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T),
	t(U, V, W, X, Y, Z, A1, B1, C1, D1, E1, F1, G1, H1, I1, J1, K1, L1, M1, N1).

p / 0:
label(L0):
	allocate                 40 
	put_global_variable      a(1)     y(21) 
	put_global_variable      a(2)     y(22) 
	put_global_variable      a(3)     y(23) 
	put_global_variable      a(4)     y(24) 
	put_global_variable      a(5)     y(25) 
	put_global_variable      a(6)     y(26) 
	put_global_variable      a(7)     y(27) 
	put_global_variable      a(8)     y(28) 
	put_global_variable      a(9)     y(29) 
	put_global_variable      a(10)     y(30) 
	put_global_variable      a(11)     y(31) 
	put_global_variable      a(12)     y(32) 
	put_global_variable      a(13)     y(33) 
	put_global_variable      a(14)     y(34) 
	put_global_variable      a(15)     y(35) 
	put_global_variable      a(16)     y(36) 
	put_global_variable      a(17)     y(37) 
	put_global_variable      a(18)     y(38) 
	put_global_variable      a(19)     y(39) 
	put_global_variable      a(20)     y(40) 
	callf                    q / 20     Y[21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40] 
	put_global_variable      a(1)     y(1) 
	put_global_variable      a(2)     y(2) 
	put_global_variable      a(3)     y(3) 
	put_global_variable      a(4)     y(4) 
	put_global_variable      a(5)     y(5) 
	put_global_variable      a(6)     y(6) 
	put_global_variable      a(7)     y(7) 
	put_global_variable      a(8)     y(8) 
	put_global_variable      a(9)     y(9) 
	put_global_variable      a(10)     y(10) 
	put_global_variable      a(11)     y(11) 
	put_global_variable      a(12)     y(12) 
	put_global_variable      a(13)     y(13) 
	put_global_variable      a(14)     y(14) 
	put_global_variable      a(15)     y(15) 
	put_global_variable      a(16)     y(16) 
	put_global_variable      a(17)     y(17) 
	put_global_variable      a(18)     y(18) 
	put_global_variable      a(19)     y(19) 
	put_global_variable      a(20)     y(20) 
	callf                    r / 20     Y[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40] 
	move                     20     y(21)     a(1) 
	callf                    s / 20     Y[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20] 
	move                     20     y(1)     a(1) 
	chain                    t / 20 

------ Test bench(1) -------
conc([], A, A).
conc([A|B], C, [A|D]) :-
	conc(B, C, D).

INDEXES for disjunction [2]
1. Quality 1.3
    [] - []
    [list] - [2]
    [[]] - [1]
    [var] - [1, 2]
2. Quality 1.5
    [] - [1]
    [list] - [1, 2]
    [var] - [1, 2]
conc / 3:
label(L0):
	allocate                 0 
	list_switch              a(1)     ref(L5)     ref(L3)     ref(fail) 
label(L1):
	list_switch              a(3)     ref(L2)     ref(L3)     ref(L3) 
label(L2):
	try_me_else              0     3     ref(L4) 
label(L3):
	get_nil                  a(1) 
	get_value                a(3)     a(2) 
	branch                   ref(L10) 
label(L4):
	trust_me_inline          0     Y[] 
label(L5):
	get_list                 a(1)     ref(L6) 
	write_variable           a(4) 
	write_variable           a(1) 
	branch                   ref(L7) 
label(L6):
	read_variable            a(4) 
	read_variable            a(1) 
label(L7):
	get_list                 a(3)     ref(L8) 
	write_local_value        a(4) 
	write_variable           a(3) 
	branch                   ref(L9) 
label(L8):
	read_value               a(4) 
	read_variable            a(3) 
label(L9):
	callf                    ref(L0)     Y[] 
label(L10):
	exit                 

------ Test bench(2) -------
conc(A, B, C) :-
	(
	    A = [],
	    B = D,
	    C = D
	;
	    A = [E|F],
	    B = D,
	    C = [E|G],
	    conc(F, D, G)
	).

INDEXES for disjunction [2]
1. Quality 1.3
    [] - []
    [list] - [2]
    [[]] - [1]
    [var] - [1, 2]
2. Quality 1.5
    [] - [1]
    [list] - [1, 2]
    [var] - [1, 2]
conc / 3:
label(L0):
	allocate                 3 
	move                     3     a(1)     y(1) 
	list_switch              y(1)     ref(L5)     ref(L3)     ref(fail) 
label(L1):
	list_switch              y(3)     ref(L2)     ref(L3)     ref(L3) 
label(L2):
	try_me_else              0     0     ref(L4) 
label(L3):
	move                     y(1)     a(1) 
	get_nil                  a(1) 
	move                     2     y(2)     a(1) 
	get_value                a(1)     a(2) 
	branch                   ref(L10) 
label(L4):
	trust_me_inline          0     Y[1,2,3] 
label(L5):
	move                     y(1)     a(4) 
	get_list                 a(4)     ref(L6) 
	write_variable           a(4) 
	write_variable           a(1) 
	branch                   ref(L7) 
label(L6):
	read_variable            a(4) 
	read_variable            a(1) 
label(L7):
	move                     y(2)     a(2) 
	move                     y(3)     a(5) 
	get_list                 a(5)     ref(L8) 
	write_local_value        a(4) 
	write_variable           a(3) 
	branch                   ref(L9) 
label(L8):
	read_value               a(4) 
	read_variable            a(3) 
label(L9):
	callf                    ref(L0)     Y[] 
label(L10):
	exit                 

------ Test bench(3) -------
conc(A, B, C) :-
	(
	    A = [D|E],
	    B = F,
	    C = [D|G],
	    conc(E, F, G)
	;
	    A = [],
	    B = F,
	    C = F
	).

INDEXES for disjunction [2]
1. Quality 1.3
    [] - []
    [[]] - [2]
    [list] - [1]
    [var] - [1, 2]
2. Quality 1.5
    [] - [2]
    [list] - [1, 2]
    [var] - [1, 2]
conc / 3:
label(L0):
	allocate                 3 
	move                     3     a(1)     y(1) 
	list_switch              y(1)     ref(L3)     ref(L9)     ref(fail) 
label(L1):
	list_switch              y(3)     ref(L2)     ref(L9)     ref(L9) 
label(L2):
	try_me_else              0     0     ref(L8) 
label(L3):
	move                     y(1)     a(4) 
	get_list                 a(4)     ref(L4) 
	write_variable           a(4) 
	write_variable           a(1) 
	branch                   ref(L5) 
label(L4):
	read_variable            a(4) 
	read_variable            a(1) 
label(L5):
	move2                    y(2)     a(2)     y(3)     a(5) 
	get_list                 a(5)     ref(L6) 
	write_local_value        a(4) 
	write_variable           a(3) 
	branch                   ref(L7) 
label(L6):
	read_value               a(4) 
	read_variable            a(3) 
label(L7):
	callf                    ref(L0)     Y[] 
	branch                   ref(L10) 
label(L8):
	trust_me_inline          0     Y[1,2,3] 
label(L9):
	move                     y(1)     a(1) 
	get_nil                  a(1) 
	move                     y(2)     a(1) 
	get_value                a(1)     y(3) 
label(L10):
	exit                 

------ Test bug(1) -------
simplify_code([], []).
simplify_code([code(A, B, C)|D], E) :-
	(
	    simplify(A, D, F)
	->
	    simplify_code(F, E)
	;
	    E = [A|F],
	    simplify_code(D, F)
	).

INDEXES for disjunction [2]
1. Quality 1.3
    [] - []
    [list] - [2]
    [[]] - [1]
    [var] - [1, 2]
2. Quality 1.5
    [] - [2]
    [[]] - [1, 2]
    [var] - [1, 2]
INDEXES for disjunction [2, 2, 2]
1. Quality 1.5
    [] - [1]
    [list] - [1, 2]
    [var] - [1, 2]
simplify_code / 2:
label(L0):
	allocate                 5 
	list_switch              a(1)     ref(L5)     ref(L3)     ref(fail) 
label(L1):
	list_switch              a(2)     ref(L5)     ref(L2)     ref(L5) 
label(L2):
	try_me_else              0     2     ref(L4) 
label(L3):
	get_nil                  a(1) 
	get_nil                  a(2) 
	branch                   ref(L17) 
label(L4):
	trust_me_inline          0     Y[] 
label(L5):
	get_list                 a(1)     ref(L7) 
	first                
	write_structure          code / 3 
label(L6):
	write_variable           y(1) 
	write_void               2 
	mode                     t(0)     ref(L8) 
	write_variable           y(2) 
	branch                   ref(L9) 
label(L7):
	read_structure           code / 3     ref(L6) 
	read_variable            y(1) 
	mode                     t(0) 
label(L8):
	read_variable            y(2) 
label(L9):
	space                    -1 
	savecut                  y(4) 
	move                     a(2)     y(3) 
	list_switch              y(3)     ref(L10)     ref(L11)     ref(L11) 
label(L10):
	try_me_else              0     0     ref(L12) 
label(L11):
	put_global_variable      a(3)     y(5) 
	move                     2     y(1)     a(1) 
	callf                    simplify / 3     Y[3,4,5] 
	cut                      y(4)     5 
	move2                    y(5)     a(1)     y(3)     a(2) 
	callf                    ref(L0)     Y[] 
	branch                   ref(L16) 
label(L12):
	trust_me_inline          0     Y[1,2,3] 
label(L13):
	move                     y(3)     a(3) 
	get_list                 a(3)     ref(L14) 
	write_local_value        y(1) 
	write_variable           a(2) 
	branch                   ref(L15) 
label(L14):
	read_value               y(1) 
	read_variable            a(2) 
label(L15):
	move                     y(2)     a(1) 
	callf                    ref(L0)     Y[] 
label(L16):
label(L17):
	exit                 

------ Test bug(2) -------
loop(A) :-
	(
	    foreach(B, A)
	do
	    writeln(B)
	).

loop / 1:
label(L0):
	move                     a(1)     a(4) 
	put_structure            a(1)     foreach / 2 
	push_variable            a(5) 
	push_local_value         a(4) 
	put_structure            a(2)     writeln / 1 
	push_local_value         a(5) 
	put_atom                 a(3)     eclipse 
	jmp                      sepia_kernel : (do) / 3 

------ Test bug(3) -------
p(A, B, C) :-
	(
	    A = B
	->
	    C = foo
	;
	    else
	).

p / 3:
label(L0):
	allocate                 4 
	savecut                  y(4) 
	move                     3     a(1)     y(1) 
	try_me_else              0     0     ref(L2) 
label(L1):
	get_value                y(1)     y(2) 
	cut                      y(4)     4 
	move                     y(3)     a(1) 
	get_atom                 a(1)     foo 
	branch                   ref(L4) 
label(L2):
	trust_me_inline          0     Y[] 
label(L3):
	callf                    (else) / 0     Y[] 
label(L4):
	exit                 

------ Test bug(4) -------
p(A, B, C) :-
	(
	    A == B
	->
	    D = temp,
	    C = E
	;
	    C = [F|E]
	).

p / 3:
label(L0):
	allocate                 4 
	savecut                  y(4) 
	move                     3     a(1)     y(1) 
	try_me_else              0     0     ref(L2) 
label(L1):
	move                     2     y(1)     a(1) 
	get_matched_value        a(1)     a(2) 
	cut                      y(4)     4 
	branch                   ref(L6) 
label(L2):
	trust_me_inline          0     Y[3] 
label(L3):
	move                     y(3)     a(1) 
	get_list                 a(1)     ref(L4) 
	write_void               2 
	branch                   ref(L5) 
label(L4):
label(L5):
label(L6):
	exit                 

------ Test bug(5) -------
indexing_transformation([A|B], C) :-
	(
	    A = disjunction(D)
	->
	    then
	;
	    C = [E|F]
	).

INDEXES for disjunction [2]
1. Quality 1.0
    [] - [2]
    [structure] - [2]
    [structure, disjunction / 1] - [1]
    [var] - [1]
indexing_transformation / 2:
label(L0):
	allocate                 3 
	get_list                 a(1)     ref(L1) 
	write_variable           y(1) 
	write_void           
	branch                   ref(L2) 
label(L1):
	read_variable            y(1) 
label(L2):
	savecut                  y(3) 
	move                     a(2)     y(2) 
label(L3):
	functor_switch           y(1) 
		disjunction / 1: 	ref(L5)
		default: 	ref(L9)

	branch                   ref(L5) 
label(L4):
	try_me_else              0     0     ref(L8) 
label(L5):
	move                     y(1)     a(1) 
	get_structure            a(1)     disjunction / 1     ref(L6) 
	write_void           
	branch                   ref(L7) 
label(L6):
label(L7):
	cut                      y(3)     3 
	callf                    (then) / 0     Y[] 
	branch                   ref(L12) 
label(L8):
	trust_me_inline          0     Y[2] 
label(L9):
	move                     y(2)     a(1) 
	get_list                 a(1)     ref(L10) 
	write_void               2 
	branch                   ref(L11) 
label(L10):
label(L11):
label(L12):
	exit                 

------ Test bug(6) -------
insert_after_head(A, B, C) :-
	(
	    B = [D|E],
	    D = goal(head, F)
	->
	    C = [D, A|E]
	;
	    C = [A|B]
	).

INDEXES for disjunction [2]
1. Quality 1.5
    [] - [2]
    [list] - [1, 2]
    [var] - [1, 2]
insert_after_head / 3:
label(L0):
	allocate                 4 
	savecut                  y(4) 
	move                     3     a(1)     y(1) 
	list_switch              y(2)     ref(L1)     ref(L11)     ref(L11) 
label(L1):
	try_me_else              0     0     ref(L10) 
label(L2):
	move                     y(2)     a(1) 
	get_list                 a(1)     ref(L3) 
	write_variable           a(1) 
	write_variable           a(2) 
	branch                   ref(L4) 
label(L3):
	read_variable            a(1) 
	read_variable            a(2) 
label(L4):
	get_structure            a(1)     goal / 2     ref(L5) 
	write_atom               head 
	write_void           
	branch                   ref(L6) 
label(L5):
	read_atom                head 
label(L6):
	cut                      y(4)     4 
	move                     y(3)     a(3) 
	get_list                 a(3)     ref(L8) 
	write_local_value        a(1) 
	write_list           
label(L7):
	write_local_value        y(1) 
	write_local_value        a(2) 
	branch                   ref(L9) 
label(L8):
	read_value               a(1) 
	read_last_list           ref(L7) 
	read_value               y(1) 
	read_value               a(2) 
label(L9):
	branch                   ref(L14) 
label(L10):
	trust_me_inline          0     Y[1,2,3] 
label(L11):
	move                     y(3)     a(1) 
	get_list                 a(1)     ref(L12) 
	write_local_value        y(1) 
	write_local_value        y(2) 
	branch                   ref(L13) 
label(L12):
	read_value               y(1) 
	read_value               y(2) 
label(L13):
label(L14):
	exit                 

------ Test bug(7) -------
declaration_warning_handler(A, B, lists) :-
	!.
declaration_warning_handler(A, B, profile) :-
	!.
declaration_warning_handler(75, A, B) :-
	!,
	get_flag_body(A, definition_module, C, B),
	get_deprecation_advice(A, C, D),
	!,
	warning_handler(75, A, B),
	printf(warning_output, " Advice: %w%n", [D]).
declaration_warning_handler(85, A : B, C) :-
	known_library(A),
	!.
declaration_warning_handler(A, B, C) :-
	warning_handler(A, B, C).

INDEXES for disjunction [2]
1. Quality 1.7
    [] - [3, 4, 5]
    [atom] - [3, 4, 5]
    [atom, profile] - [2]
    [atom, lists] - [1]
    [var] - [1]
2. Quality 3.3
    [] - [1, 2, 5]
    [var] - [1, 2, 3]
    [integer] - [1, 2, 5]
    [integer, 85] - [1, 2, 4, 5]
    [integer, 75] - [1, 2, 3]
declaration_warning_handler / 3:
label(L0):
	allocate                 5 
	savecut                  y(1) 
label(L1):
	atom_switch              a(3) 
		profile: 	ref(L7)
		lists: 	ref(L5)
		default: 	ref(L17)

	branch                   ref(L5) 
label(L2):
label(L3):
	integer_switch           a(1) 
		85: 	ref(L19)
		75: 	ref(L20)
		default: 	ref(L18)

	branch                   ref(L20) 
label(L4):
	try_me_else              0     3     ref(L6) 
label(L5):
	get_atom                 a(3)     lists 
	cut                      y(1)     5 
	branch                   ref(L16) 
label(L6):
	retry_me_inline          0     ref(L8)     Y[1] 
label(L7):
	get_atom                 a(3)     profile 
	cut                      y(1)     5 
	branch                   ref(L16) 
label(L8):
	retry_me_inline          0     ref(L10)     Y[1] 
label(L9):
	get_integer              a(1)     75 
	cut                      y(1)     5 
	move                     2     a(2)     y(3) 
	put_atom                 a(2)     definition_module 
	put_global_variable      a(3)     y(5) 
	move2                    y(3)     a(1)     y(4)     a(4) 
	callf                    get_flag_body / 4     Y[1,3,4,5] 
	put_global_variable      a(3)     y(2) 
	move2                    y(3)     a(1)     y(5)     a(2) 
	callf                    get_deprecation_advice / 3     Y[1,2,3,4] 
	cut                      y(1)     5 
	put_integer              a(1)     75 
	move                     2     y(3)     a(2) 
	callf                    warning_handler / 3     Y[2] 
	put_list                 a(3) 
	push_local_value         y(2) 
	push_nil             
	put_atom                 a(1)     warning_output 
	put_string               a(2)     " Advice: %w%n" 
	put_atom                 a(4)     eclipse 
	callf                    sepia_kernel : printf_body / 4     Y[] 
	branch                   ref(L16) 
label(L10):
	retry_me_inline          0     ref(L14)     Y[1] 
label(L11):
	get_integer              a(1)     85 
	get_structure            a(2)     (:) / 2     ref(L12) 
	write_variable           a(1) 
	write_void           
	branch                   ref(L13) 
label(L12):
	read_variable            a(1) 
label(L13):
	callf                    known_library / 1     Y[1] 
	cut                      y(1)     5 
	branch                   ref(L16) 
label(L14):
	trust_me_inline          0     Y[] 
label(L15):
	callf                    warning_handler / 3     Y[] 
label(L16):
	exit                 
label(L17):
	try                      0     3     ref(L9) 
	retry_inline             0     ref(L11)     Y[1] 
	trust_inline             0     ref(L15)     Y[] 
label(L18):
	try                      0     3     ref(L5) 
	retry_inline             0     ref(L7)     Y[1] 
	trust_inline             0     ref(L15)     Y[] 
label(L19):
	try                      0     3     ref(L5) 
	retry_inline             0     ref(L7)     Y[1] 
	retry_inline             0     ref(L11)     Y[1] 
	trust_inline             0     ref(L15)     Y[] 
label(L20):
	try                      0     3     ref(L5) 
	retry_inline             0     ref(L7)     Y[1] 
	trust_inline             0     ref(L9)     Y[1] 

------ Test bug(8) -------
attach_suspensions(postponed, A) ?-
	!,
	postpone_suspensions(A).
attach_suspensions(A, B) :-
	atom(A),
	!,
	attach_suspensions1(A, B).
attach_suspensions(A, B) :-
	nonvar(A),
	!,
	error(5, attach_suspensions(A, B)).
attach_suspensions(A, B) :-
	error(4, attach_suspensions(A, B)).

INDEXES for disjunction [2]
1. Quality 0.8
    [] - [4]
    [handle] - [3]
    [list] - [3]
    [[]] - [2]
    [structure] - [3]
    [atom] - [2]
    [atom, postponed] - [1]
    [rational] - [3]
    [integer] - [3]
    [breal] - [3]
    [bignum] - [3]
    [string] - [3]
    [double] - [3]
    [goal] - [3]
attach_suspensions / 2:
label(L0):
	allocate                 1 
	savecut                  y(1) 
	switch_on_type           a(1) 
		meta: 	ref(L8)
		[]: 	ref(L4)
		atom: 	ref(L10)
		bignum: 	ref(L6)
		breal: 	ref(L6)
		double: 	ref(L6)
		goal: 	ref(L6)
		handle: 	ref(L6)
		integer: 	ref(L6)
		list: 	ref(L6)
		rational: 	ref(L6)
		string: 	ref(L6)
		structure: 	ref(L6)

	branch                   ref(L8) 
label(L1):
	try_me_else              0     2     ref(L3) 
label(L2):
	in_get_atom              a(1)     postponed 
	cut                      y(1)     1 
	move                     a(2)     a(1) 
	callf                    postpone_suspensions / 1     Y[] 
	branch                   ref(L9) 
label(L3):
	retry_me_inline          0     ref(L5)     Y[1] 
label(L4):
	bi_atom                  a(1) 
	cut                      y(1)     1 
	callf                    attach_suspensions1 / 2     Y[] 
	branch                   ref(L9) 
label(L5):
	retry_me_inline          0     ref(L7)     Y[1] 
label(L6):
	bi_nonvar                a(1) 
	cut                      y(1)     1 
	move                     a(2)     a(4) 
	put_structure            a(2)     attach_suspensions / 2 
	push_local_value         a(1) 
	push_local_value         a(4) 
	put_integer              a(1)     5 
	put_atom                 a(3)     eclipse 
	callf                    sepia_kernel : error_ / 3     Y[] 
	branch                   ref(L9) 
label(L7):
	trust_me_inline          0     Y[] 
label(L8):
	move                     a(2)     a(4) 
	put_structure            a(2)     attach_suspensions / 2 
	push_local_value         a(1) 
	push_local_value         a(4) 
	put_integer              a(1)     4 
	put_atom                 a(3)     eclipse 
	callf                    sepia_kernel : error_ / 3     Y[] 
label(L9):
	exit                 
label(L10):
	atom_switch              a(1) 
		postponed: 	ref(L2)
		default: 	ref(L4)


------ Test at1 -------
at1 :-
	var(f(A)),
	A == a,
	q(A, f(A)).

at1 / 0:
label(L0):
	put_structure            a(3)     f / 1 
	push_variable            a(1) 
	bi_var                   a(3) 
	in_get_atom              a(1)     a 
	put_structure            a(2)     f / 1 
	push_local_value         a(1) 
	jmp                      q / 2 

------ Test at2 -------
at2 :-
	f(A) == f(B),
	A == B,
	q(A, B).

at2 / 0:
label(L0):
	put_structure            a(3)     f / 1 
	push_variable            a(1) 
	put_structure            a(4)     f / 1 
	push_variable            a(2) 
	get_matched_value        a(3)     a(4) 
	get_matched_value        a(1)     a(2) 
	jmp                      q / 2 

------ Test at3 -------
at3 :-
	f(A) == f(B),
	A == B,
	q(f(A), f(B)).

at3 / 0:
label(L0):
	put_structure            a(3)     f / 1 
	push_variable            a(4) 
	put_structure            a(5)     f / 1 
	push_variable            a(6) 
	get_matched_value        a(3)     a(5) 
	get_matched_value        a(4)     a(6) 
	put_structure            a(1)     f / 1 
	push_local_value         a(4) 
	put_structure            a(2)     f / 1 
	push_local_value         a(6) 
	jmp                      q / 2 

------ Test at4 -------
at4 :-
	q,
	f(A) == f(B),
	A == B,
	q(A, B).

at4 / 0:
label(L0):
	allocate                 0 
	callf                    q / 0     Y[] 
	put_structure            a(3)     f / 1 
	push_variable            a(1) 
	put_structure            a(4)     f / 1 
	push_variable            a(2) 
	get_matched_value        a(3)     a(4) 
	get_matched_value        a(1)     a(2) 
	chain                    q / 2 

------ Test ag1 -------
ag1 :-
	*(f(A), f(A), f(A)).

ag1 / 0:
label(L0):
	put_structure            a(1)     f / 1 
	push_variable            a(2) 
	put_structure            a(3)     f / 1 
	push_local_value         a(2) 
	put_structure            a(4)     f / 1 
	push_local_value         a(2) 
	bi_mul                   a(1)     a(3)     a(4) 
	ret                  

------ Test ag2 -------
ag2 :-
	*(A, A, f(A)).

ag2 / 0:
label(L0):
	put_variable             a(1) 
	put_structure            a(2)     f / 1 
	push_local_value         a(1) 
	bi_mul                   a(1)     a(1)     a(2) 
	ret                  

------ Test ag3 -------
ag3 :-
	A == f(A),
	q(A).

ag3 / 0:
label(L0):
	put_variable             a(1) 
	put_structure            a(2)     f / 1 
	push_local_value         a(1) 
	get_matched_value        a(1)     a(2) 
	jmp                      q / 1 

------ Test ag5 -------
ag5 :-
	p(f(A), f(A), f(A)).

ag5 / 0:
label(L0):
	put_structure            a(1)     f / 1 
	push_variable            a(4) 
	put_structure            a(2)     f / 1 
	push_local_value         a(4) 
	put_structure            a(3)     f / 1 
	push_local_value         a(4) 
	jmp                      p / 3 

------ Test ag6 -------
ag6 :-
	p(A, A, f(A)),
	p(f(B), f(B)),
	p(C, f(C)),
	p(f(D), D).

ag6 / 0:
label(L0):
	allocate                 0 
	put_structure            a(3)     f / 1 
	push_variable            a(1) 
	move                     a(1)     a(2) 
	callf                    p / 3     Y[] 
	put_structure            a(1)     f / 1 
	push_variable            a(3) 
	put_structure            a(2)     f / 1 
	push_local_value         a(3) 
	callf                    p / 2     Y[] 
	put_structure            a(2)     f / 1 
	push_variable            a(1) 
	callf                    p / 2     Y[] 
	put_structure            a(1)     f / 1 
	push_variable            a(2) 
	chain                    p / 2 

------ Test ag8 -------
ag8 :-
	A =.. [f, B, B],
	q(A).

ag8 / 0:
label(L0):
	allocate                 1 
	put_list                 a(2) 
	write_atom               f 
	push_list            
	push_variable            a(3) 
	push_list            
	push_local_value         a(3) 
	push_nil             
	put_global_variable      a(1)     y(1) 
	callf                    (=..) / 2     Y[1] 
	move                     y(1)     a(1) 
	chain                    q / 1 

------ Test am1 -------
am1 :-
	f(A) == A.

am1 / 0:
label(L0):
	put_structure            a(1)     f / 1 
	push_variable            a(2) 
	get_matched_value        a(1)     a(2) 
	ret                  

------ Test am2 -------
am2 :-
	f(A) == A,
	q(A).

am2 / 0:
label(L0):
	put_structure            a(2)     f / 1 
	push_variable            a(1) 
	get_matched_value        a(2)     a(1) 
	jmp                      q / 1 

------ Test am3 -------
am3 :-
	f(A) == A,
	q(A),
	r.

am3 / 0:
label(L0):
	allocate                 0 
	put_structure            a(2)     f / 1 
	push_variable            a(1) 
	get_matched_value        a(2)     a(1) 
	callf                    q / 1     Y[] 
	chain                    r / 0 

------ Test am4 -------
am4 :-
	*(f(A), A, f(A)).

am4 / 0:
label(L0):
	put_structure            a(1)     f / 1 
	push_variable            a(2) 
	put_structure            a(3)     f / 1 
	push_local_value         a(2) 
	bi_mul                   a(1)     a(2)     a(3) 
	ret                  

------ Test am5 -------
am5 :-
	p(A),
	*(f(A), A, f(A)),
	q(A).

am5 / 0:
label(L0):
	allocate                 1 
	put_global_variable      a(1)     y(1) 
	callf                    p / 1     Y[1] 
	put_structure            a(2)     f / 1 
	push_local_value         y(1) 
	put_structure            a(3)     f / 1 
	push_local_value         y(1) 
	move                     y(1)     a(1) 
	bi_mul                   a(2)     a(1)     a(3) 
	chain                    q / 1 

------ Test am6 -------
am6 :-
	var(A),
	*(A, f(A), A),
	q(A).

am6 / 0:
label(L0):
	put_variable             a(1) 
	bi_var                   a(1) 
	put_structure            a(2)     f / 1 
	push_local_value         a(1) 
	bi_mul                   a(1)     a(2)     a(1) 
	jmp                      q / 1 

------ Test am7 -------
am7 :-
	p(A),
	*(f(A), A, f(A)),
	q(A).

am7 / 0:
label(L0):
	allocate                 1 
	put_global_variable      a(1)     y(1) 
	callf                    p / 1     Y[1] 
	put_structure            a(2)     f / 1 
	push_local_value         y(1) 
	put_structure            a(3)     f / 1 
	push_local_value         y(1) 
	move                     y(1)     a(1) 
	bi_mul                   a(2)     a(1)     a(3) 
	chain                    q / 1 

------ Test am8 -------
am8 :-
	p(A),
	*(A, f(A), A),
	q(A).

am8 / 0:
label(L0):
	allocate                 1 
	put_global_variable      a(1)     y(1) 
	callf                    p / 1     Y[1] 
	put_structure            a(2)     f / 1 
	push_local_value         y(1) 
	move                     y(1)     a(1) 
	bi_mul                   a(1)     a(2)     a(1) 
	chain                    q / 1 

------ Test am9 -------
am9 :-
	var(A),
	f(A) == A,
	q(A).

am9 / 0:
label(L0):
	put_variable             a(1) 
	bi_var                   a(1) 
	put_structure            a(2)     f / 1 
	push_local_value         a(1) 
	get_matched_value        a(2)     a(1) 
	jmp                      q / 1 

------ Test am10 -------
am10 :-
	p(A),
	var(A),
	f(A) == A,
	q(A).

am10 / 0:
label(L0):
	allocate                 1 
	put_global_variable      a(1)     y(1) 
	callf                    p / 1     Y[1] 
	move                     y(1)     a(1) 
	bi_var                   a(1) 
	put_structure            a(2)     f / 1 
	push_local_value         y(1) 
	get_matched_value        a(2)     a(1) 
	chain                    q / 1 

------ Test am11 -------
am11 :-
	var(A),
	f(A) == A.

am11 / 0:
label(L0):
	put_variable             a(1) 
	bi_var                   a(1) 
	put_structure            a(2)     f / 1 
	push_local_value         a(1) 
	get_matched_value        a(2)     a(1) 
	ret                  

------ Test am12 -------
am12 :-
	var(A),
	A == f(A).

am12 / 0:
label(L0):
	put_variable             a(1) 
	bi_var                   a(1) 
	put_structure            a(2)     f / 1 
	push_local_value         a(1) 
	get_matched_value        a(1)     a(2) 
	ret                  

------ Test am13 -------
am13 :-
	A == f(A).

am13 / 0:
label(L0):
	put_variable             a(1) 
	put_structure            a(2)     f / 1 
	push_local_value         a(1) 
	get_matched_value        a(1)     a(2) 
	ret                  

------ Test am14 -------
am14 :-
	eq(A, B),
	f(A) == A.

am14 / 0:
label(L0):
	allocate                 1 
	put_variable             a(2) 
	put_global_variable      a(1)     y(1) 
	callf                    eq / 2     Y[1] 
	put_structure            a(1)     f / 1 
	push_local_value         y(1) 
	move                     y(1)     a(2) 
	get_matched_value        a(1)     a(2) 
	exit                 

------ Test disj1 -------
p :-
	(
	    var(A)
	->
	    b
	;
	    c
	).

p / 0:
label(L0):
	allocate                 1 
	savecut                  y(1) 
	try_me_else              0     0     ref(L2) 
label(L1):
	put_variable             a(1) 
	bi_var                   a(1) 
	cut                      y(1)     1 
	callf                    b / 0     Y[] 
	branch                   ref(L4) 
label(L2):
	trust_me_inline          0     Y[] 
label(L3):
	callf                    c / 0     Y[] 
label(L4):
	exit                 

------ Test disj2 -------
p :-
	(
	    var(A)
	->
	    b
	;
	    (
		var(A)
	    ->
		c
	    ;
		d
	    )
	).

p / 0:
label(L0):
	allocate                 1 
	savecut                  y(1) 
	try_me_else              0     0     ref(L2) 
label(L1):
	put_variable             a(1) 
	bi_var                   a(1) 
	cut                      y(1)     1 
	callf                    b / 0     Y[] 
	branch                   ref(L6) 
label(L2):
	retry_me_inline          0     ref(L4)     Y[1] 
label(L3):
	put_variable             a(1) 
	bi_var                   a(1) 
	cut                      y(1)     1 
	callf                    c / 0     Y[] 
	branch                   ref(L6) 
label(L4):
	trust_me_inline          0     Y[] 
label(L5):
	callf                    d / 0     Y[] 
label(L6):
	exit                 

------ Test disj3 -------
p :-
	(
	    var(A)
	->
	    var(B)
	;
	    var(C)
	).

p / 0:
label(L0):
	allocate                 1 
	savecut                  y(1) 
	try_me_else              0     0     ref(L2) 
label(L1):
	put_variable             a(1) 
	bi_var                   a(1) 
	cut                      y(1)     1 
	put_variable             a(1) 
	bi_var                   a(1) 
	branch                   ref(L4) 
label(L2):
	trust_me_inline          0     Y[] 
label(L3):
	put_variable             a(1) 
	bi_var                   a(1) 
label(L4):
	exit                 

------ Test disj4 -------
p :-
	(
	    var(A)
	->
	    b
	;
	    c
	),
	e,
	f.

p / 0:
label(L0):
	allocate                 1 
	savecut                  y(1) 
	try_me_else              0     0     ref(L2) 
label(L1):
	put_variable             a(1) 
	bi_var                   a(1) 
	cut                      y(1)     1 
	callf                    b / 0     Y[] 
	branch                   ref(L4) 
label(L2):
	trust_me_inline          0     Y[] 
label(L3):
	callf                    c / 0     Y[] 
label(L4):
	callf                    e / 0     Y[] 
	chain                    f / 0 

------ Test disj5 -------
p :-
	(
	    var(A)
	->
	    b
	;
	    (
		var(A)
	    ->
		c
	    ;
		d
	    )
	),
	e,
	f.

p / 0:
label(L0):
	allocate                 1 
	savecut                  y(1) 
	try_me_else              0     0     ref(L2) 
label(L1):
	put_variable             a(1) 
	bi_var                   a(1) 
	cut                      y(1)     1 
	callf                    b / 0     Y[] 
	branch                   ref(L6) 
label(L2):
	retry_me_inline          0     ref(L4)     Y[1] 
label(L3):
	put_variable             a(1) 
	bi_var                   a(1) 
	cut                      y(1)     1 
	callf                    c / 0     Y[] 
	branch                   ref(L6) 
label(L4):
	trust_me_inline          0     Y[] 
label(L5):
	callf                    d / 0     Y[] 
label(L6):
	callf                    e / 0     Y[] 
	chain                    f / 0 

------ Test disj6 -------
p :-
	(
	    var(A)
	->
	    var(B)
	;
	    var(C)
	),
	e,
	f.

p / 0:
label(L0):
	allocate                 1 
	savecut                  y(1) 
	try_me_else              0     0     ref(L2) 
label(L1):
	put_variable             a(1) 
	bi_var                   a(1) 
	cut                      y(1)     1 
	put_variable             a(1) 
	bi_var                   a(1) 
	branch                   ref(L4) 
label(L2):
	trust_me_inline          0     Y[] 
label(L3):
	put_variable             a(1) 
	bi_var                   a(1) 
label(L4):
	callf                    e / 0     Y[] 
	chain                    f / 0 

------ Test disj7 -------
p :-
	(
	    var(A)
	;
	    var(B)
	),
	c,
	d.

p / 0:
label(L0):
	allocate                 0 
	try_me_else              0     0     ref(L2) 
label(L1):
	put_variable             a(1) 
	bi_var                   a(1) 
	branch                   ref(L4) 
label(L2):
	trust_me_inline          0     Y[] 
label(L3):
	put_variable             a(1) 
	bi_var                   a(1) 
label(L4):
	callf                    c / 0     Y[] 
	chain                    d / 0 

------ Test disj8 -------
p :-
	(
	    once true
	->
	    fail
	;
	    true
	).

p / 0:
label(L0):
	allocate                 2 
	savecut                  y(1) 
	try_me_else              0     0     ref(L2) 
label(L1):
	savecut                  y(2) 
	callf                    true / 0     Y[1,2] 
	cut                      y(2)     2 
	cut                      y(1)     2 
	failure              
	branch                   ref(L4) 
label(L2):
	trust_me_inline          0     Y[] 
label(L3):
label(L4):
	exit                 

------ Test disj9 -------
p :-
	q,
	once var(A),
	p.

p / 0:
label(L0):
	allocate                 0 
	callf                    q / 0     Y[] 
	savecut                  a(1) 
	put_variable             a(2) 
	bi_var                   a(2) 
	cut                      a(1) 
	chain                    ref(L0) 

------ Test disj10 -------
p :-
	q,
	once var(A).

p / 0:
label(L0):
	allocate                 0 
	callf                    q / 0     Y[] 
	savecut                  a(1) 
	put_variable             a(2) 
	bi_var                   a(2) 
	cut                      a(1) 
	exit                 

------ Test disj11 -------
p :-
	(
	    (
		a,
		b
	    ->
		c
	    )
	->
	    q
	).

p / 0:
label(L0):
	allocate                 2 
	savecut                  y(1) 
	savecut                  y(2) 
	callf                    a / 0     Y[1,2] 
	callf                    b / 0     Y[1,2] 
	cut                      y(2)     2 
	callf                    c / 0     Y[1] 
	cut                      y(1)     2 
	chain                    q / 0 

------ Test disj12 -------
p :-
	(
	    q,
	    var(A)
	->
	    true
	).

p / 0:
label(L0):
	allocate                 1 
	savecut                  y(1) 
	callf                    q / 0     Y[1] 
	put_variable             a(1) 
	bi_var                   a(1) 
	cut                      y(1)     1 
	exit                 

------ Test disj13 -------
p :-
	q,
	var(A),
	!,
	p(A).

p / 0:
label(L0):
	allocate                 1 
	savecut                  y(1) 
	callf                    q / 0     Y[1] 
	put_variable             a(1) 
	bi_var                   a(1) 
	cut                      y(1)     1 
	chain                    p / 1 

------ Test disj14 -------
p :-
	(
	    a
	;
	    (
		var(A)
	    ->
		var(A)
	    )
	),
	b.

p / 0:
label(L0):
	allocate                 0 
	try_me_else              0     0     ref(L2) 
label(L1):
	callf                    a / 0     Y[] 
	branch                   ref(L4) 
label(L2):
	trust_me_inline          0     Y[] 
label(L3):
	savecut                  a(1) 
	put_variable             a(2) 
	bi_var                   a(2) 
	cut                      a(1) 
	bi_var                   a(2) 
label(L4):
	chain                    b / 0 

------ Test disj15 -------
p :-
	(
	    var(A)
	->
	    var(A),
	    !
	;
	    (
		p,
		var(A),
		!
	    ;
		var(A),
		!
	    )
	).

p / 0:
label(L0):
	allocate                 2 
	savecut                  y(1) 
	savecut                  y(2) 
	try_me_else              0     0     ref(L2) 
label(L1):
	put_variable             a(1) 
	bi_var                   a(1) 
	cut                      y(2)     2 
	bi_var                   a(1) 
	cut                      y(1)     2 
	branch                   ref(L6) 
label(L2):
	retry_me_inline          0     ref(L4)     Y[1] 
label(L3):
	callf                    ref(L0)     Y[1] 
	put_variable             a(1) 
	bi_var                   a(1) 
	cut                      y(1)     2 
	branch                   ref(L6) 
label(L4):
	trust_me_inline          0     Y[1] 
label(L5):
	put_variable             a(1) 
	bi_var                   a(1) 
	cut                      y(1)     2 
label(L6):
	exit                 

------ Test disj16 -------
p :-
	not (p, !, once (a, !, b)).

p / 0:
label(L0):
	allocate                 3 
	savecut                  y(1) 
	try_me_else              0     0     ref(L2) 
label(L1):
	savecut                  y(3) 
	callf                    ref(L0)     Y[1,3] 
	cut                      y(3)     3 
	savecut                  y(2) 
	callf                    a / 0     Y[1,2] 
	cut                      y(2)     3 
	callf                    b / 0     Y[1,2] 
	cut                      y(2)     3 
	cut                      y(1)     3 
	failure              
	branch                   ref(L4) 
label(L2):
	trust_me_inline          0     Y[] 
label(L3):
label(L4):
	exit                 

------ Test disj17 -------
p :-
	(
	    q(A)
	;
	    r(B)
	).

p / 0:
label(L0):
	allocate                 0 
	try_me_else              0     0     ref(L2) 
label(L1):
	put_variable             a(1) 
	callf                    q / 1     Y[] 
	branch                   ref(L4) 
label(L2):
	trust_me_inline          0     Y[] 
label(L3):
	put_variable             a(1) 
	callf                    r / 1     Y[] 
label(L4):
	exit                 

------ Test disj18 -------
p1(A, B, f(C)) :-
	A = B,
	A = C,
	a = b,
	q,
	argc(D),
	D = a.

p1 / 3:
label(L0):
	allocate                 1 
	get_structure            a(3)     f / 1     ref(L1) 
	write_variable           a(3) 
	branch                   ref(L2) 
label(L1):
	read_variable            a(3) 
label(L2):
	get_value                a(1)     a(2) 
	get_value                a(1)     a(3) 
	failure              
	callf                    q / 0     Y[] 
	put_global_variable      a(1)     y(1) 
	callf                    argc / 1     Y[1] 
	move                     y(1)     a(1) 
	get_atom                 a(1)     a 
	exit                 

------ Test disj19 -------
t :-
	not not (!, fail).

t / 0:
label(L0):
	allocate                 2 
	savecut                  y(1) 
	try_me_else              0     0     ref(L6) 
label(L1):
	savecut                  y(2) 
	try_me_else              0     0     ref(L3) 
label(L2):
	failure              
	cut                      y(2)     2 
	failure              
	branch                   ref(L5) 
label(L3):
	trust_me_inline          0     Y[1] 
label(L4):
label(L5):
	cut                      y(1)     2 
	failure              
	branch                   ref(L8) 
label(L6):
	trust_me_inline          0     Y[] 
label(L7):
label(L8):
	exit                 

------ Test disj20 -------
t :-
	(
	    true
	->
	    not (true -> fail)
	).

t / 0:
label(L0):
	allocate                 3 
	savecut                  y(3) 
	callf                    true / 0     Y[3] 
	cut                      y(3)     3 
	savecut                  y(1) 
	try_me_else              0     0     ref(L2) 
label(L1):
	savecut                  y(2) 
	callf                    true / 0     Y[1,2] 
	cut                      y(2)     3 
	failure              
	cut                      y(1)     3 
	failure              
	branch                   ref(L4) 
label(L2):
	trust_me_inline          0     Y[] 
label(L3):
label(L4):
	exit                 

------ Test disj21 -------
t :-
	(
	    q,
	    var(A)
	->
	    p(A)
	).

t / 0:
label(L0):
	allocate                 1 
	savecut                  y(1) 
	callf                    q / 0     Y[1] 
	put_variable             a(1) 
	bi_var                   a(1) 
	cut                      y(1)     1 
	chain                    p / 1 

------ Test disj22 -------
q(A) :-
	(
	    p(a)
	->
	    r(A)
	).

q / 1:
label(L0):
	allocate                 2 
	savecut                  y(2) 
	move                     a(1)     y(1) 
	put_atom                 a(1)     a 
	callf                    p / 1     Y[1,2] 
	cut                      y(2)     2 
	move                     y(1)     a(1) 
	chain                    r / 1 

------ Test disj23 -------
g(A, B, C) :-
	copy_term(B, d(A, C, D)),
	once D.

g / 3:
label(L0):
	allocate                 2 
	move                     a(1)     a(4) 
	move                     a(2)     a(1) 
	put_structure            a(2)     d / 3 
	push_local_value         a(4) 
	push_local_value         a(3) 
	push_variable            y(2) 
	callf                    copy_term / 2     Y[2] 
	savecut                  y(1) 
	put_atom                 a(2)     eclipse 
	move                     y(2)     a(1) 
	callf                    sepia_kernel : untraced_call / 2     Y[1] 
	cut                      y(1)     2 
	exit                 

------ Test disj24 -------
p2([A|B], C, D) :-
	l(C, D, E / F),
	q(B, C, D).

p2 / 3:
label(L0):
	allocate                 3 
	get_list                 a(1)     ref(L1) 
	write_void           
	write_variable           y(1) 
	branch                   ref(L2) 
label(L1):
	read_void            
	read_variable            y(1) 
label(L2):
	move                     2     a(2)     y(2) 
	put_structure            a(3)     (/) / 2 
	push_void                2 
	move                     a(2)     a(1) 
	move                     y(3)     a(2) 
	callf                    l / 3     Y[1,2,3] 
	move                     3     y(1)     a(1) 
	chain                    q / 3 

------ Test disj25 -------
p(A) :-
	(
	    (
		A = 1,
		!
	    ;
		A = 2
	    ),
	    fail
	;
	    A = 4
	).

INDEXES for disjunction [2]
1. Quality 1.5
    [] - [1]
    [var] - [1, 2]
    [integer] - [1]
    [integer, 4] - [1, 2]
INDEXES for disjunction [2, 1, 2]
1. Quality 1.0
    [] - []
    [var] - [1]
    [integer] - []
    [integer, 1] - [1]
    [integer, 2] - [2]
p / 1:
label(L0):
	allocate                 2 
	savecut                  y(2) 
	move                     a(1)     y(1) 
label(L1):
	integer_switch           y(1) 
		4: 	ref(L2)
		default: 	ref(L3)

label(L2):
	try_me_else              0     0     ref(L10) 
label(L3):
label(L4):
	integer_switch           y(1) 
		1: 	ref(L6)
		2: 	ref(L8)
		default: 	ref(fail)

	branch                   ref(L6) 
label(L5):
	try_me_else              0     0     ref(L7) 
label(L6):
	move                     y(1)     a(1) 
	get_integer              a(1)     1 
	cut                      y(2)     2 
	branch                   ref(L9) 
label(L7):
	trust_me_inline          0     Y[1] 
label(L8):
	move                     y(1)     a(1) 
	get_integer              a(1)     2 
label(L9):
	failure              
	branch                   ref(L12) 
label(L10):
	trust_me_inline          0     Y[1] 
label(L11):
	move                     y(1)     a(1) 
	get_integer              a(1)     4 
label(L12):
	exit                 

------ Test disj26 -------
p(A, B) :-
	(
	    var(C),
	    q(C)
	->
	    r(C)
	;
	    s(A, B)
	).

p / 2:
label(L0):
	allocate                 4 
	savecut                  y(3) 
	move                     2     a(1)     y(1) 
	try_me_else              0     0     ref(L2) 
label(L1):
	put_global_variable      a(1)     y(4) 
	bi_var                   a(1) 
	callf                    q / 1     Y[3,4] 
	cut                      y(3)     4 
	move                     y(4)     a(1) 
	callf                    r / 1     Y[] 
	branch                   ref(L4) 
label(L2):
	trust_me_inline          0     Y[1,2] 
label(L3):
	move                     2     y(1)     a(1) 
	callf                    s / 2     Y[] 
label(L4):
	exit                 

------ Test disj27 -------
p3(A, B, C) :-
	(
	    A = ''
	->
	    D = "",
	    E = F
	;
	    D = "a",
	    E = [A, F]
	).

INDEXES for disjunction [2]
1. Quality 1.0
    [] - [2]
    [atom] - [2]
    [atom, ] - [1]
    [var] - [1]
p3 / 3:
label(L0):
	allocate                 2 
	savecut                  y(2) 
	move                     a(1)     y(1) 
label(L1):
	atom_switch              y(1) 
		'': 	ref(L3)
		default: 	ref(L5)

	branch                   ref(L3) 
label(L2):
	try_me_else              0     0     ref(L4) 
label(L3):
	move                     y(1)     a(1) 
	get_atom                 a(1)     '' 
	cut                      y(2)     2 
	branch                   ref(L6) 
label(L4):
	trust_me_inline          0     Y[1] 
label(L5):
label(L6):
	exit                 

------ Test disj28 -------
s :-
	(
	    A == open
	->
	    true
	;
	    (
		A == def
	    ->
		(
		    transformed(B)
		->
		    true
		;
		    true
		)
	    )
	).

s / 0:
label(L0):
	allocate                 2 
	savecut                  y(1) 
	try_me_else              0     0     ref(L2) 
label(L1):
	put_variable             a(1) 
	in_get_atom              a(1)     open 
	cut                      y(1)     2 
	branch                   ref(L8) 
label(L2):
	trust_me_inline          0     Y[] 
label(L3):
	savecut                  a(1) 
	put_variable             a(2) 
	in_get_atom              a(2)     def 
	cut                      a(1) 
	savecut                  y(2) 
	try_me_else              0     0     ref(L5) 
label(L4):
	put_variable             a(1) 
	callf                    transformed / 1     Y[2] 
	cut                      y(2)     2 
	branch                   ref(L7) 
label(L5):
	trust_me_inline          0     Y[] 
label(L6):
label(L7):
label(L8):
	exit                 

------ Test disj29 -------
test A :-
	!,
	writeln(clause1),
	(
	    A = 1
	->
	    writeln(ok)
	;
	    writeln(wrong)
	).

INDEXES for disjunction [3]
1. Quality 1.0
    [] - [2]
    [var] - [1]
    [integer] - [2]
    [integer, 1] - [1]
test / 1:
label(L0):
	allocate                 2 
	savecut                  a(3) 
	cut                      a(3) 
	move                     a(1)     y(2) 
	put_atom                 a(1)     clause1 
	put_atom                 a(2)     eclipse 
	callf                    sepia_kernel : writeln_body / 2     Y[2] 
	savecut                  y(1) 
label(L1):
	integer_switch           y(2) 
		1: 	ref(L3)
		default: 	ref(L5)

	branch                   ref(L3) 
label(L2):
	try_me_else              0     0     ref(L4) 
label(L3):
	move                     y(2)     a(3) 
	get_integer              a(3)     1 
	cut                      y(1)     2 
	put_atom                 a(1)     ok 
	put_atom                 a(2)     eclipse 
	callf                    sepia_kernel : writeln_body / 2     Y[] 
	branch                   ref(L6) 
label(L4):
	trust_me_inline          0     Y[] 
label(L5):
	put_atom                 a(1)     wrong 
	put_atom                 a(2)     eclipse 
	callf                    sepia_kernel : writeln_body / 2     Y[] 
label(L6):
	exit                 

------ Test disj30 -------
test :-
	getcond(A, B),
	(
	    A
	->
	    (
		B
	    ->
		true
	    )
	).

test / 0:
label(L0):
	allocate                 4 
	put_global_variable      a(1)     y(4) 
	put_global_variable      a(2)     y(3) 
	callf                    getcond / 2     Y[3,4] 
	savecut                  y(2) 
	put_atom                 a(2)     eclipse 
	move                     y(4)     a(1) 
	callf                    sepia_kernel : untraced_call / 2     Y[2,3] 
	cut                      y(2)     4 
	savecut                  y(1) 
	put_atom                 a(2)     eclipse 
	move                     y(3)     a(1) 
	callf                    sepia_kernel : untraced_call / 2     Y[1] 
	cut                      y(1)     4 
	exit                 

------ Test disj31 -------
go(A) :-
	A = [B, C, D],
	findall(E, member(E, A), F),
	F = [1, 2, 3],
	nl,
	write('L = '),
	write(A).

go / 1:
label(L0):
	allocate                 2 
	get_list                 a(1)     ref(L3) 
	write_void           
	write_list           
label(L1):
	write_void           
	write_list           
label(L2):
	write_void           
	write_nil            
	branch                   ref(L4) 
label(L3):
	read_void            
	read_last_list           ref(L1) 
	read_void            
	read_last_list           ref(L2) 
	read_void            
	read_nil             
label(L4):
	move                     a(1)     y(1) 
	put_structure            a(2)     member / 2 
	push_variable            a(1) 
	move                     y(1)     a(5) 
	push_local_value         a(5) 
	put_global_variable      a(3)     y(2) 
	put_atom                 a(4)     eclipse 
	callf                    sepia_kernel : findall_body / 4     Y[1,2] 
	move                     y(2)     a(1) 
	get_list                 a(1)     ref(L7) 
	write_integer            1 
	write_list           
label(L5):
	write_integer            2 
	write_list           
label(L6):
	write_integer            3 
	write_nil            
	branch                   ref(L8) 
label(L7):
	read_integer             1 
	read_last_list           ref(L5) 
	read_integer             2 
	read_last_list           ref(L6) 
	read_integer             3 
	read_nil             
label(L8):
	callf                    nl / 0     Y[1] 
	put_atom                 a(1)     'L = ' 
	put_atom                 a(2)     eclipse 
	callf                    sepia_kernel : write_ / 2     Y[1] 
	put_atom                 a(2)     eclipse 
	move                     y(1)     a(1) 
	chain                    sepia_kernel : write_ / 2 

------ Test disj32 -------
append([A|B], C, [A|D]) :-
	append(B, C, D).

append / 3:
label(L0):
	get_list                 a(1)     ref(L1) 
	write_variable           a(4) 
	write_variable           a(1) 
	branch                   ref(L2) 
label(L1):
	read_variable            a(4) 
	read_variable            a(1) 
label(L2):
	get_list                 a(3)     ref(L3) 
	write_local_value        a(4) 
	write_variable           a(3) 
	branch                   ref(L4) 
label(L3):
	read_value               a(4) 
	read_variable            a(3) 
label(L4):
	jmp                      ref(L0) 

------ Test disj33 -------
c(A, B) :-
	(
	    A = B
	->
	    a
	;
	    b
	),
	c.

c / 2:
label(L0):
	allocate                 3 
	savecut                  y(3) 
	move                     2     a(1)     y(1) 
	try_me_else              0     0     ref(L2) 
label(L1):
	get_value                y(1)     y(2) 
	cut                      y(3)     3 
	callf                    a / 0     Y[] 
	branch                   ref(L4) 
label(L2):
	trust_me_inline          0     Y[] 
label(L3):
	callf                    b / 0     Y[] 
label(L4):
	chain                    c / 0 

------ Test disj34 -------
producer(A) :-
	random(B),
	(
	    B > 0
	->
	    A = [B|C]
	;
	    A = [zero|C]
	),
	producer(C).

INDEXES for disjunction [3]
1. Quality 1.5
    [] - [1]
    [list] - [1, 2]
    [var] - [1, 2]
producer / 1:
label(L0):
	allocate                 4 
	move                     a(1)     y(4) 
	put_global_variable      a(1)     y(3) 
	callf                    random / 1     Y[3,4] 
	savecut                  y(2) 
	list_switch              y(4)     ref(L1)     ref(L2)     ref(L2) 
label(L1):
	try_me_else              0     0     ref(L5) 
label(L2):
	put_integer              a(1)     0 
	put_atom                 a(2)     eclipse 
	move                     y(3)     a(3) 
	bi_gt                    a(3)     a(1)     a(2) 
	cut                      y(2)     4 
	move                     y(4)     a(1) 
	get_list                 a(1)     ref(L3) 
	write_local_value        y(3) 
	write_variable           y(1) 
	branch                   ref(L4) 
label(L3):
	read_value               y(3) 
	read_variable            y(1) 
label(L4):
	branch                   ref(L9) 
label(L5):
	trust_me_inline          0     Y[4] 
label(L6):
	move                     y(4)     a(1) 
	get_list                 a(1)     ref(L7) 
	write_atom               zero 
	write_variable           y(1) 
	branch                   ref(L8) 
label(L7):
	read_atom                zero 
	read_variable            y(1) 
label(L8):
label(L9):
	move                     y(1)     a(1) 
	chain                    ref(L0) 
